<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shigaro</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/minyez/"/>
  <updated>2020-07-02T09:31:05.333Z</updated>
  <id>https://github.com/minyez/</id>
  
  <author>
    <name>minyez</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Emacs笔记(二)——Org-mode</title>
    <link href="https://github.com/minyez/2020/07/02/emacs-2/"/>
    <id>https://github.com/minyez/2020/07/02/emacs-2/</id>
    <published>2020-07-01T23:55:07.000Z</published>
    <updated>2020-07-02T09:31:05.333Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>Org-mode使用的学习笔记.</p></div><a id="more"></a><p>在使用Org-roam前首先是学习Org-mode的使用. 这里大量参考了Zaiste的<a href="https://www.youtube.com/watch?v=rCMh7srOqvw&amp;list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj" target="_blank" rel="noopener">Doom Emacs系列视频</a>, 特别是E09-E13.</p><h2 id="Org文件"><a href="#Org文件" class="headerlink" title="Org文件"></a>Org文件</h2><p>任何格式的纯文本都可以用Org-mode打开. 而在打开<code>.org</code>后缀文件时, Emacs会自动启用Org-mode. 与Markdown和rST等轻量标记语言类似, org文件也需要一些标记符号来激活它的功能.</p><table><thead><tr><th>标记符号</th><th>作用</th></tr></thead><tbody><tr><td><code>*</code></td><td>层级标题</td></tr><tr><td><code>&lt;&lt;nanme&gt;&gt;</code></td><td>id为<code>name</code>的锚</td></tr><tr><td><code>[[name]]</code></td><td>指向<code>name</code>的内链接</td></tr><tr><td><code>[[target][desp]]</code></td><td>文本<code>desp</code>具有指向<code>target</code>的链接. 可以是外链</td></tr><tr><td><code>*text*</code></td><td>加粗</td></tr><tr><td><code>_text_</code></td><td>下划线</td></tr><tr><td><code>*text*</code></td><td>高亮</td></tr><tr><td><code>+text+</code></td><td>删除</td></tr><tr><td><code>/text/</code></td><td>斜体</td></tr><tr><td><code>=text=</code></td><td>打字机模式</td></tr><tr><td><code>~text~</code></td><td>代码模式</td></tr></tbody></table><p>其中强调记号可以通过<code>org-emphasis-alist</code>变量进行自定义.</p><h2 id="按键操作"><a href="#按键操作" class="headerlink" title="按键操作"></a>按键操作</h2><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>M-↑/↓</code></td><td>上下移动整个层级</td></tr><tr><td><code>M-h</code></td><td>上升一个层级</td></tr><tr><td><code>M-l</code></td><td>下降一个层级</td></tr><tr><td><code>C-RET</code></td><td>新建同层级段落</td></tr><tr><td><code>SPC m l l</code></td><td>创建/编辑链接</td></tr><tr><td><code>SPC m l d</code></td><td>移除链接</td></tr><tr><td><code>SPC n l</code></td><td>为选定文本制作书签, 存入链接库备选</td></tr><tr><td><code>SPC m &#39;</code></td><td>为选中元素调用特殊编辑器</td></tr><tr><td><code>RET</code></td><td>转到链接目标</td></tr><tr><td><code>C-C C-x C-n/p</code></td><td>下/上一个链接</td></tr><tr><td><code>M-x org-mark-ring-goto</code></td><td>返回链接位置</td></tr></tbody></table><h2 id="org文件编辑"><a href="#org文件编辑" class="headerlink" title="org文件编辑"></a>org文件编辑</h2><h3 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h3><p>Org-mode尤其有用的功能是其方便的内链创建.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* Heading 1</span><br><span class="line">  ** Subheading 1</span><br><span class="line">    This is link to [[Heading 2]]</span><br><span class="line">    这是一个锚&lt;&lt;anchor&gt;&gt;</span><br><span class="line"></span><br><span class="line">  ** Subheading 2</span><br><span class="line">    跳转到锚[[anchor]]</span><br><span class="line"></span><br><span class="line">* Heading 2</span><br><span class="line">  Go to [[https://www.google.com][Google.com]]</span><br></pre></td></tr></table></figure><p>此外, Org-mode还支持多种<a href="https://orgmode.org/manual/External-Links.html#External-Links" target="_blank" rel="noopener">外部链接</a>. 除内链和网页外还支持<code>file:</code>, <code>doi:</code>, Emacs Lisp脚本<code>elisp:</code>以及Shell脚本<code>shell:</code>等. 另外它还支持自定义链接. 在<code>config.el</code>中加入下列代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建连接bilibili视频的链接</span></span><br><span class="line">(<span class="name">defun</span> make-bilibili-link (<span class="name">vid</span>)</span><br><span class="line">  (<span class="name">browse-url</span> (<span class="name">concat</span> <span class="string">"https://www.bilibili.com/video/"</span> vid))  </span><br><span class="line">)</span><br><span class="line">(<span class="name">after!</span> org</span><br><span class="line">  (<span class="name">org-add-link-type</span> <span class="string">"blbl"</span> #'make-bilibili-link)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="可执行代码块"><a href="#可执行代码块" class="headerlink" title="可执行代码块"></a>可执行代码块</h3><p>输入<code>&lt;s</code>后<code>TAB</code>, 就可用创建一个如下环境, 可在其中编写可执行的代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_SRC</span><br><span class="line"></span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure><p>比如我们在其中用C编写Hello World:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_SRC</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  printf(&quot;Hello World!&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure><p>编写完成后, 退出编辑模式. 在<code>END_SRC</code>下回车, 就会自动将输出结果添加到源代码块下方.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">: Hello World!</span><br></pre></td></tr></table></figure><p>如果改变了代码的内容, 只要选中代码块任意位置重新回车, 即可更新输出结果. <span class="label label-info">Q</span> <code>#+RESULTS</code>部分似乎不会被导出, 有待确认)</p><h3 id="LaTeX导出初探"><a href="#LaTeX导出初探" class="headerlink" title="LaTeX导出初探"></a>LaTeX导出初探</h3><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>C-c C-e l l</code></td><td>导出.org文件到.tex文件</td></tr><tr><td><code>C-c C-e l L</code></td><td>将.org文件导出为tex, 加载到新缓冲区</td></tr><tr><td><code>C-c C-e l p</code></td><td>导出.org文件到.tex文件, 并转换为pdf</td></tr><tr><td><code>C-c C-e l o</code></td><td>导出.org文件到.tex文件, 转换为pdf同时用默认浏览器打开</td></tr></tbody></table><p>在用LaTeX导出时, 用如下代码块包围的内容不会被转换器处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_LATEX</span><br><span class="line">\LaTeX</span><br><span class="line">#+END_LATEX</span><br></pre></td></tr></table></figure><p>导出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\LaTeX</span><br></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><a href="/2020/07/01/emacs-1/" title="Emacs笔记(一)——安装与配置Doom Emacs">Emacs笔记(一)——安装与配置Doom Emacs</a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Org-mode官方手册: <a href="https://orgmode.org/manual/" target="_blank" rel="noopener">https://orgmode.org/manual/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Org-mode使用的学习笔记.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="Emacs" scheme="https://github.com/minyez/tags/Emacs/"/>
    
      <category term="Org-mode" scheme="https://github.com/minyez/tags/Org-mode/"/>
    
      <category term="note-taking" scheme="https://github.com/minyez/tags/note-taking/"/>
    
  </entry>
  
  <entry>
    <title>在macOS中置顶窗口</title>
    <link href="https://github.com/minyez/2020/07/01/macos-float-window/"/>
    <id>https://github.com/minyez/2020/07/01/macos-float-window/</id>
    <published>2020-07-01T09:40:49.000Z</published>
    <updated>2020-07-01T15:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>使用MacForge和AfloatX插件, 在Mojave系统下允许窗口置顶.</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>macOS上一直困扰我的问题是没有简单的窗口置顶工具. 在PC下, 播放器之类的很多软件在任务栏上都有一个小图钉图标, 点一下就可以置顶. 但是macOS上竟然找不到自带这样功能的软件. 这归因于自Mac OS El Capitan以后苹果引入的系统完整性保护 (System Integrity Protection, SIP). 根据<a href="https://en.wikipedia.org/wiki/System_Integrity_Protection#Functions" target="_blank" rel="noopener">维基百科</a>, SIP禁止用户对根目录下<code>/System</code>和<code>/usr</code>等特定文件夹的修改, 关闭代码注入和运行时进程附着, 禁止未签名的内核扩展. 由此看来, 将窗口置顶可能涉及向Finder运行时进行代码注入从而被SIP禁止, 因此按正常流程发布的app就不可能实现这个功能了. 但另一方面, 窗口置顶是否有可能通过由app发送置顶请求到Finder, Finder向用户一次性请求权限的方式来实现呢? 这就要看今后Apple对macOS的改进了.</p><p>可是对于Mojave来说恐怕等不到那个时候, 所以还是得自己想办法. <a href="https://www.maketecheasier.com/mac-keeping-your-application-window-always-on-top/" target="_blank" rel="noopener">这篇文章</a>提供了比较完整的思路, 主要是利用mySIMBL进行代码注入, 置顶功能由<a href="https://github.com/rwu823/afloat">Afloat</a>提供. 有点遗憾的是, 这篇文章时间比较久远了, mySIMBL已经升级成了<a href="https://github.com/MacEnhance/MacForge">MacForge</a>, Afloat数年没有更新, 几乎被<a href="https://github.com/jslegendre/AfloatX">AfloatX</a>取代. 不过基本思路没有变化, 就在这里简单记录一下流程.</p><h2 id="流程记录"><a href="#流程记录" class="headerlink" title="流程记录"></a>流程记录</h2><h3 id="Step-1-部分关闭SIP"><a href="#Step-1-部分关闭SIP" class="headerlink" title="Step 1 部分关闭SIP"></a>Step 1 部分关闭SIP</h3><p>这一部分在<a href="https://github.com/MacEnhance/MacForge/wiki/Installation">MacForge Wiki页</a>上有充分的描述. 重启, 按住<code>CMD+R</code>进入recovery mode. 从左上角菜单栏打开终端, 输入以下部分关闭SIP的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil enable --without fs --without nvram --without debug</span><br></pre></td></tr></table></figure><p><code>without</code>选项指定禁止的SIP功能. 对应内容可由直接输入<code>csrutil</code>来理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ csrutil</span><br><span class="line">System Integrity Protection status: enabled (Custom Configuration).</span><br><span class="line">Configuration:</span><br><span class="line">    Apple Internal: disabled</span><br><span class="line">    Kext Signing: enabled</span><br><span class="line">    Filesystem Protections: disabled</span><br><span class="line">    Debugging Restrictions: disabled</span><br><span class="line">    DTrace Restrictions: enabled</span><br><span class="line">    NVRAM Protections: disabled</span><br><span class="line">    BaseSystem Verification: enabled</span><br><span class="line"></span><br><span class="line">This is an unsupported configuration, likely to break in the future and leave your machine in an unknown state.</span><br></pre></td></tr></table></figure><p><code>fs</code>指的是文件系统保护, <code>debug</code>指调试限制, <code>nvram</code>指非易失性存储器(<a href="https://en.wikipedia.org/wiki/Non-volatile_random-access_memory" target="_blank" rel="noopener">Non-volatile random-access memory</a>, NVRAM)保护. NVRAM是内存的一部分, 用于存储快速访问的设置, 包括<a href="https://support.apple.com/zh-cn/HT204063" target="_blank" rel="noopener">内核崩溃信息</a>.</p><h3 id="Step-2-安装MacForge"><a href="#Step-2-安装MacForge" class="headerlink" title="Step 2 安装MacForge"></a>Step 2 安装MacForge</h3><p>解压GitHub中<a href="https://github.com/w0lfschild/app_updates/raw/master/MacForge/MacForge.zip">最新发布的压缩包</a>, 然后将<code>.app</code>移到应用程序中.</p><h3 id="Step-3-安装AfloatX"><a href="#Step-3-安装AfloatX" class="headerlink" title="Step 3 安装AfloatX"></a>Step 3 安装AfloatX</h3><p>打开MacForge, 从Featured页面找到AfloatX, GET即可.</p><p><figure class="null"><img src="plugin.png" alt=" "><figcaption> </figcaption></figure></p><h3 id="Step-4-置顶窗口"><a href="#Step-4-置顶窗口" class="headerlink" title="Step 4 置顶窗口"></a>Step 4 置顶窗口</h3><p>打开想要置顶的窗口, 右击对应app的Dock图标, 在AfloatX里选择<code>Float Window</code>, 窗口置顶就完成了. 关闭一次窗口重新打开, 就可以取消置顶.</p><p><figure class="null"><img src="float-taskpaper.png" alt=" "><figcaption> </figcaption></figure></p><p>完工 (ง •̀_•́)ง 置顶GTD app窗口对于健忘+拖延的我来说就是救命恩人(bushi).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用MacForge和AfloatX插件, 在Mojave系统下允许窗口置顶.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="macOS" scheme="https://github.com/minyez/tags/macOS/"/>
    
      <category term="MacForge" scheme="https://github.com/minyez/tags/MacForge/"/>
    
      <category term="Afloatx" scheme="https://github.com/minyez/tags/Afloatx/"/>
    
      <category term="GTD" scheme="https://github.com/minyez/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>Emacs笔记(一)——安装与配置Doom Emacs</title>
    <link href="https://github.com/minyez/2020/07/01/emacs-1/"/>
    <id>https://github.com/minyez/2020/07/01/emacs-1/</id>
    <published>2020-07-01T06:51:07.000Z</published>
    <updated>2020-07-02T09:30:59.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>记录从零开始的Emacs. 目标是熟练地使用Org-roam编辑个人维基!</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因缘巧合, 今日我在搜索转化$\rm\LaTeX$到MathML的解决方案时, 偶然看到了<a href="https://github.com/org-roam/org-roam">Org-roam</a>项目. 它的个人知识库构建和展示方式引起了我很大的兴趣.</p><p>Org-roam基于Emacs的Org-mode, 后者是Emacs中纯文本笔记管理+GTD+写作系统. “Org”指代organize, “roam”则取自<a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam Research</a>. Org-roam采纳了<a href="https://zettelkasten.de/" target="_blank" rel="noopener">Zettelkasten笔记法</a>的思想.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Zettelkasten是一个德语词, 对应英语slip box, 类似于图书馆存放索引卡的盒子.">[1]</span></a></sup> 这种方法认为知识不是层级化的而是扁平化的, 重要的是知识之间的关联. 这种关联通过笔记中用<code>[[...]]</code>包围的关键词建立. Org-roam能对这种连接进行可视化.</p><p><figure class="null"><img src="org-roam-graph-demo.png" alt="Graph view, from Org-roam GitHub site"><figcaption>Graph view, from Org-roam GitHub site</figcaption></figure></p><p>相比较其他Zettelkasten实现, Org-roam的特点是</p><ol><li>完全免费开源, 数据库本地存储而不是封存托管在企业云端数据库.</li><li>基于Org-mode纯文本系统, 可利用Emacs生态扩展.</li><li>配置复杂, 学习曲线陡峭.</li><li><del>Emacs与Vim水火不容</del></li></ol><p>一直以来也接触过挺多笔记记录的方式, Agenda, Bear, OneNote, Notion, 甚至是本地文件夹, 但总是觉得不得劲. 现在又多了这样一种选择, 自然还是想试一下. 然而作为Vim用户, 第一个应该跨过的关卡应该是Emacs的基本使用. 现在就说道说道吧.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Doom-Emacs"><a href="#Doom-Emacs" class="headerlink" title="Doom Emacs"></a>Doom Emacs</h3><p>从安装开始. 为免去Emacs基本设置, 在<a href="https://www.youtube.com/watch?v=Lg61ocfxk3c" target="_blank" rel="noopener">Matt Williams</a>的推荐下安装<a href="https://github.com/d12frosted/homebrew-emacs-plus">emacs-plus</a>和<a href="https://github.com/hlissner/doom-emacs">Doom Emacs</a>. 用homebrew安装Emacs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew tap d12frosted/emacs-plus</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若出现403错误, 在前面加上all_proxy=socks5://127.0.0.1:1086</span></span><br><span class="line">brew install emacs-plus@27 --with-modern-icon-cg433n</span><br><span class="line">ln -s /usr/local/opt/emacs-plus/Emacs.app /Applications/Emacs.app</span><br></pre></td></tr></table></figure><p>完成后再从GitHub安装Doom Emacs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d</span><br><span class="line">~/.emacs.d/bin/doom install</span><br></pre></td></tr></table></figure><p>此时命令行打开Emacs, 可以看到下面这样十分炫酷的界面. 这跟我印象里面一个大白框UI迥然不同.</p><p><figure class="null"><img src="doom-ui.png" alt="Doom Emacs UI"><figcaption>Doom Emacs UI</figcaption></figure></p><p>Doom Emacs安装完后, 编辑<code>~/.doom.d/</code>下的<code>init.el</code>文件打开或关闭一些Doom模块. 一些模块包含可选功能, 需要通过<code>+</code>指定, 例如打开<a href="https://orgmode.org/" target="_blank" rel="noopener">Org-mode</a>的可选功能 (<span class="label label-info">Q</span>如何检查一个包有哪些可选功能?)</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">doom!</span> <span class="symbol">:lang</span></span><br><span class="line">  (<span class="name">org</span> +brain</span><br><span class="line">       +dragdrop</span><br><span class="line">       +gnuplot</span><br><span class="line">       +jupyter)      <span class="comment">; organize your plain life in plain text</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>在<code>~/.doom.d/packages.el</code>下用<code>package!</code>命令指定安装ELPA/MELPA上的插件包,<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="ELPA: 全称Emacs Lisp Package Archive, Emacs默认的软件包存储库. MELPA = Milkypostman ELPA">[2]</span></a></sup> 例如</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 安装ELPA或者MELPA上的包</span></span><br><span class="line">(<span class="name">package!</span> markdown-mode)</span><br><span class="line"><span class="comment">;; 从GitHub仓库安装最新版markdown-mode</span></span><br><span class="line">(<span class="name">package!</span> markdown-mode</span><br><span class="line"> <span class="symbol">:recipe</span> (<span class="symbol">:host</span> github <span class="symbol">:repo</span> jrblevin/markdown-mode))</span><br></pre></td></tr></table></figure><p>设置完后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.emacs.d/bin/doom sync</span><br></pre></td></tr></table></figure><p>以应用两个文件的变化. 如果遇到安装问题, 可在<code>packages.el</code>中注释掉对应代码, 命令行执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doom purge</span><br></pre></td></tr></table></figure><p>卸载程序包, 再反注释掉, 重新安装即可.</p><h3 id="Org-roam"><a href="#Org-roam" class="headerlink" title="Org-roam"></a>Org-roam</h3><p>Org-roam的安装可以采用<code>+</code>方式安装(<a href="https://orgroam.slack.com/archives/CV160S8EL/p1590857012127400" target="_blank" rel="noopener">slack讨论</a>)</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">doom!</span> <span class="symbol">:lang</span></span><br><span class="line">  (<span class="name">org</span> +roam)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>也可以在<code>packags.el</code>中加入</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">package!</span> org-roam)</span><br><span class="line">(<span class="name">package!</span> company-org-roam) <span class="comment">;org-roam相关的代码补全</span></span><br></pre></td></tr></table></figure><p>安装. 随后在<code>config.el</code>中用<code>use-package!</code>函数配置</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package!</span> org-roam</span><br><span class="line">  <span class="symbol">:commands</span> (<span class="name">org-roam-insert</span> org-roam-find-file org-roam)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> org-roam-directory <span class="string">"~/Documents/SelfDevelopment/org-roam/"</span>)</span><br><span class="line">  (<span class="name">setq</span> org-roam-graph-viewer <span class="string">"/usr/bin/open"</span>)</span><br><span class="line">  (<span class="name">map!</span> <span class="symbol">:leader</span></span><br><span class="line">  <span class="symbol">:prefix</span> <span class="string">"r"</span></span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Insert"</span> <span class="string">"i"</span> #'org-roam-insert</span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Find"</span>   <span class="string">"/"</span> #'org-roam-find-file</span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Buffer"</span> <span class="string">"r"</span> #'org-roam)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">org-roam-mode</span> <span class="number">+1</span>))</span><br><span class="line"><span class="comment">;(add-to-list 'exec-path' "/usr/local/Cellar/sqlite/3.32.1/bin/sqlite3");用macOS自带</span></span><br><span class="line">(<span class="name">add-hook</span> 'after-init-hook 'org-roam-mode)</span><br></pre></td></tr></table></figure><p>随后打开Emacs, <code>M-x org-roam-find-file</code>或<code>SPC r /</code>, 会检查<code>org-roam-directory</code>下的所以org文件. 输出文件名进行编辑或者新建</p><p><figure class="null"><img src="first_file.png" alt=" "><figcaption> </figcaption></figure></p><p>编辑完后<code>C-c C-c</code>保存. 对于config中不了解的函数, 可以输入<code>SPC(空格) h f</code>来查询.</p><p>更进一步的Org-mode, Org-roam配置和使用过程将会在下一篇文章中记录. 在本文接下来部分中仅涉及Emacs编辑和指令的基本使用.</p><h2 id="Emacs使用"><a href="#Emacs使用" class="headerlink" title="Emacs使用"></a>Emacs使用</h2><p><a href="https://www.youtube.com/watch?v=rCMh7srOqvw&amp;list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj" target="_blank" rel="noopener">Zaiste</a>制作了一系列非常好的Youtube视频介绍Doom Emacs和Org-mode的使用, 这里的记录基本上是练习他的Doom视频内容的整理.</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>Dired模式下可以对文件夹与文件进行操作.</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>-</code>/<code>RET</code></td><td>进入上层/子文件夹</td></tr><tr><td><code>+</code>/<code>d x</code></td><td>新建/删除文件夹</td></tr><tr><td><code>o</code></td><td>排序</td></tr><tr><td><code>M</code></td><td>修改文件权限</td></tr><tr><td><code>O</code></td><td>修改文件owner</td></tr><tr><td><code>m</code>/<code>u</code></td><td>选择/反选文件</td></tr><tr><td><code>R</code></td><td>重命名/移动文件</td></tr></tbody></table><h3 id="常用键位和命令"><a href="#常用键位和命令" class="headerlink" title="常用键位和命令"></a>常用键位和命令</h3><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>SPC .</code></td><td>打开或创建文件 (在文本编辑模式下直接回车, 相当于Vim的<code>:q</code>)</td></tr><tr><td><code>SPC f r</code></td><td>打开最近文件</td></tr><tr><td><code>SPC o i</code></td><td>在iTerm中打开当前文件夹</td></tr><tr><td>修饰键<code>C</code></td><td>Mac上为Ctrl键</td></tr><tr><td>修饰键<code>M</code></td><td>Mac上为Alt键 (在Doom中如果是第一个输入, CMD键也可以)</td></tr><tr><td>修饰键<code>s</code></td><td>Mac上为CMD键</td></tr><tr><td><code>M-x shell</code></td><td>在Emacs中打开shell(全屏)</td></tr><tr><td><code>SPC o T</code></td><td>在Emacs中打开vterm(全屏)</td></tr><tr><td><code>SPC o t</code></td><td>在Emacs中弹出vterm小窗</td></tr></tbody></table><p>如果想将vterm的默认shell设为zsh需要在<code>config.el</code>中加入</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; set zsh to default shell of vterm</span></span><br><span class="line">(<span class="name">use-package!</span> vterm</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> vterm-shell <span class="string">"zsh"</span>))</span><br></pre></td></tr></table></figure><p>此时可以用<code>SPC o T</code>打开vterm, 使用的是zsh.</p><h3 id="缓冲区和窗口操作"><a href="#缓冲区和窗口操作" class="headerlink" title="缓冲区和窗口操作"></a>缓冲区和窗口操作</h3><p>和Vim类似, 打开文件时, Emacs会打开一个缓冲区(buffer), 载入当前文件的所有内容. 所有编辑都在buffer中进行. 但buffer不必一定是文件, 它也可以是shell, 或者Dired文件树等等.</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>SPC b N</code></td><td>新建缓冲区</td></tr><tr><td><code>CMD-n</code></td><td></td></tr><tr><td><code>SPC b k</code></td><td>杀死当前缓冲区</td></tr><tr><td><code>CMD-k</code></td><td></td></tr><tr><td><code>SPC b b</code></td><td>切换工作区缓冲区</td></tr><tr><td>或<code>SPC ,</code></td><td></td></tr><tr><td><code>SPC b B</code></td><td>切换全局缓冲区</td></tr><tr><td>或<code>SPC &lt;</code></td><td></td></tr><tr><td><code>C-w v</code></td><td>水平复制缓冲区到新窗口</td></tr><tr><td><code>C-w s</code></td><td>垂直复制缓冲区到新窗口</td></tr><tr><td><code>C-w w</code></td><td>转到下一个缓冲区窗口</td></tr><tr><td><code>C-w h/j/k/l</code></td><td>Vi式窗口转移</td></tr><tr><td><code>C-w q</code></td><td>关闭窗口</td></tr><tr><td><code>C-w &gt;/&lt;</code></td><td>向右/左扩展窗口</td></tr><tr><td><code>C-w +/-</code></td><td>向上/下扩展窗口</td></tr><tr><td><code>C-w =</code></td><td>使所有窗口等宽等高</td></tr></tbody></table><h3 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h3><p>这里文本编辑想表达的是类似Vim中文本操作键位和command mode下的命令(<code>:</code>). 好在Doom Emacs将许多Vim与Emacs命令绑定在了一起, 省去了学习Emacs原生编辑操作的麻烦. 但是Domm Emacs额外提供了许多方便的编辑命令</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>C-x k</code></td><td>关闭buffer但不保存, 类似Vim <code>:q!</code>. 如果直接输入<code>:q</code>将会关闭整个Emacs</td></tr><tr><td><code>g s SPC STR</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转</td></tr><tr><td><code>g s SPC STR x</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转并剪切</td></tr><tr><td><code>g s SPC STR i</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转并提供ispell修改意见</td></tr></tbody></table><h3 id="Markdown编辑和预览"><a href="#Markdown编辑和预览" class="headerlink" title="Markdown编辑和预览"></a>Markdown编辑和预览</h3><p>markdown文件的文本渲染和快速编辑可以使用<a href="https://jblevins.org/projects/markdown-mode/" target="_blank" rel="noopener">markdown-mode</a>. <a href="https://blog.bitsandbobs.net/blog/emacs-markdown-live-preview/" target="_blank" rel="noopener">Markus Opitz</a>基于<code>simple-httpd</code>包实现了一个HTTP服务器实时预览的功能. 编辑命令可参考这个<a href="https://cheatography.com/xaon/cheat-sheets/emacs-markdown-mode/" target="_blank" rel="noopener">Cheatsheet</a>.</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><h3 id="GitHub图标显示不正常"><a href="#GitHub图标显示不正常" class="headerlink" title="GitHub图标显示不正常"></a>GitHub图标显示不正常</h3><p>安装完后打开Doom Emacs, 首页上的GitHub图标显示有可能<a href="https://github.com/hlissner/doom-emacs/issues/724">不正常</a>, 此时需要在Emacs下安装<code>all-the-icons</code>.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x all-the-icons-install-fonts</span><br></pre></td></tr></table></figure><p>如果出现403错误, 可以用<a href="https://blog.fazero.me/2015/08/31/%E5%88%A9%E7%94%A8proxychains%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">proxychains-ng</a>和SS解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 emacs</span><br></pre></td></tr></table></figure><h3 id="Package-cl-is-deprecated警告"><a href="#Package-cl-is-deprecated警告" class="headerlink" title="Package cl is deprecated警告"></a><code>Package cl is deprecated</code>警告</h3><p>在打开Doom Emacs后底部会出现这一警告. 原因是在Emacs 24后<code>cl</code>程序包已经被<code>cl-lib</code>取代, 而部分依赖于<code>cl</code>的包(如<a href="https://github.com/jrblevin/deft/issues/77#issue-616735753">deft</a>)未相应更新. 目前除了等待源码更新外, 没有好的解决办法.</p><h3 id="新建文档时安装PDF-tools出错"><a href="#新建文档时安装PDF-tools出错" class="headerlink" title="新建文档时安装PDF-tools出错"></a>新建文档时安装PDF-tools出错</h3><p>首次用<code>M-X org-roam-find-file</code>创建新文件, 会弹出build epdfinfo的请求, 确定后自动安装pdf-tools. 此时出现了build failed的情况, 主要错误信息是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configure: error: cannot find necessary  poppler-private header (see README.org)</span><br><span class="line">Build failed.  ;o(</span><br></pre></td></tr></table></figure><p>解决办法参考这个<a href="https://github.com/politza/pdf-tools/issues/480#issuecomment-472223334">issue comment</a>, 从Homebrew安装pdf-tools</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap dunn/homebrew-emacs</span><br><span class="line">brew install --HEAD pdf-tools</span><br></pre></td></tr></table></figure><p>然后在packages.el中加入</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">package!</span> pdf-tools)</span><br></pre></td></tr></table></figure><p>重新打开Emacs新建文件, 不需要重新build epdfinfo了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Master Emacs in 21 Days: <a href="http://book.emacs-china.org/" target="_blank" rel="noopener">http://book.emacs-china.org/</a></p><p>Emacs Key Bindings: <a href="https://caiorss.github.io/Emacs-Elisp-Programming/Keybindings.html" target="_blank" rel="noopener">https://caiorss.github.io/Emacs-Elisp-Programming/Keybindings.html</a></p><p><a href="http://emacslife.com/read-lisp-tweak-emacs/beginner-3-make-things-more-convenient.html" target="_blank" rel="noopener">How can I customize Emacs to make things more convenient?</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Zettelkasten是一个德语词, 对应英语slip box, 类似于图书馆存放索引卡的盒子.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">ELPA: 全称Emacs Lisp Package Archive, Emacs默认的软件包存储库. MELPA = Milkypostman ELPA<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录从零开始的Emacs. 目标是熟练地使用Org-roam编辑个人维基!&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="macOS" scheme="https://github.com/minyez/tags/macOS/"/>
    
      <category term="Emacs" scheme="https://github.com/minyez/tags/Emacs/"/>
    
      <category term="Org-roam" scheme="https://github.com/minyez/tags/Org-roam/"/>
    
  </entry>
  
  <entry>
    <title>Hexo笔记(二)——显示博文修改时间等</title>
    <link href="https://github.com/minyez/2020/06/30/hexo-2-update-time/"/>
    <id>https://github.com/minyez/2020/06/30/hexo-2-update-time/</id>
    <published>2020-06-30T04:12:12.000Z</published>
    <updated>2020-07-01T04:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>给Freemind主题增加显示博文修改时间的功能. 用hexo-browsersync实现server模式实时预览.</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在网上浏览博文的时候, 经常可以看到一些Hexo生成的站点文章有最后修改时间的属性, 所以一直以来都想给自己的博文增加这样的功能. 可惜拖着拖着到现在才想着实践. 原本想着只要在front matter上增加类似<code>update</code>属性, 然后修改ejs让它像<code>date</code>一样在边栏显示就可以了. 但是这样想的时候出现了一点问题, 因为直接从front matter提取的<code>update</code>是字符串, 没有<code>format</code>方法, 也不能传给<code>date()</code>函数. 在看了一些文章后才知道需要先将其转换为<code>moment</code>对象. 那么问题就变成了找到<code>date</code>是在哪里变成<code>moment</code>对象的即可. 另外还想实现的需求是: 如果front matter有<code>updated</code>属性, 则以<code>updated</code>为最后修改时间; 如果没有, 则获取文件的最后修改时间.</p><h2 id="搜索date-moment对象化代码"><a href="#搜索date-moment对象化代码" class="headerlink" title="搜索date moment对象化代码"></a>搜索date moment对象化代码</h2><p>采用正则表达式, <code>find</code>和<code>grep</code>搜索js文件, 寻找<code>date</code>属性的<code>moment</code>实例化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -regex <span class="string">".*\.js"</span> | xargs grep -E <span class="string">"moment\(.*date)"</span> --color -RnH</span></span><br><span class="line">./node_modules/hexo/lib/plugins/helper/date.js:9:  if (!isMoment(date)) date = moment(isDate(date) ? date : new Date(date));</span><br><span class="line">./node_modules/hexo/lib/hexo/post.js:40:  data.date = data.date ? moment(data.date) : moment();</span><br></pre></td></tr></table></figure><p>可以看到<code>date</code>实例化在<code>post.js</code>的40行. 接下来在<code>post.js</code>中加入如下代码使data获得moment对象<code>updated</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data.updated) &#123;</span><br><span class="line">      data.updated = moment(data.updated);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但这样还不能满足我们的要求, 即要求<code>updated</code>属性不存在时获取文件最后修改时间, 作为文章最后修改时间. 根据参考资料1, 为获取文件路径, 除了<code>post.js</code>中已经引入的<code>path</code>外, 需要引入<code>child_process</code>库来调用系统的date命令.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> execSync = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br></pre></td></tr></table></figure><p>于是修改上一步中的实例化if语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastMod = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (data.updated) &#123;</span><br><span class="line">    data.updated = moment(data.updated);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 对data.source进行判断, 否则在新建post时会报错</span></span><br><span class="line">  <span class="keyword">if</span> (data.source) &#123;</span><br><span class="line">    fp = pathFn.resolve(config.source_dir, data.source);</span><br><span class="line">    lastMod = execSync(<span class="string">`date -r <span class="subst">$&#123;fp&#125;</span> "+%Y-%m-%d %H:%M:%S"`</span>).toString().trim();</span><br><span class="line">    data.updated = moment(lastMod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    data.updated = data.date;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就使得每一个post对象获得了<code>updated</code>属性.</p><h2 id="修改meta-ejs"><a href="#修改meta-ejs" class="headerlink" title="修改meta.ejs"></a>修改meta.ejs</h2><p>得到<code>updated</code>属性后, 只要简单修改<code>layout/_partial/post</code>下的<code>meta.ejs</code>文件即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- date --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (item.date) &#123; %&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"meta-widget"</span>&gt;</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-clock-o"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">&lt;%= item.date.format(config.date_format) %&gt; created</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;% if (item.updated) &#123; %&gt;</span></span><br><span class="line"><span class="regexp"> &lt;% if (date(item.date) != date(item.updated)) &#123; %&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div class="meta-widget"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;i class="fa fa-pencil"&gt;&lt;/i</span>&gt;</span><br><span class="line">    &lt;%= item.updated.format(config.date_format) %&gt; last modified</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">   &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p>这里额外要求只有当<code>date</code>和<code>updated</code>两者日期不同时, 才显示<code>updated</code>的时间. 效果如下图所示</p><p><figure class="null"><img src="update_time_result.png" alt=" "><figcaption> </figcaption></figure></p><p>完工 (ง •̀_•́)ง</p><h2 id="Server模式实时预览"><a href="#Server模式实时预览" class="headerlink" title="Server模式实时预览"></a>Server模式实时预览</h2><p>每次修改博文都要重新hexo generate再server挺麻烦的. 原来用的<a href="https://github.com/hexojs/hexo-livereload">hexo-livereload</a>已被归档, 现在可以用<a href="https://github.com/hexojs/hexo-browsersync">hexo-browsersync</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g browsersync</span><br><span class="line">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure><p>之后再运行server模式. 当md文件有改动时, localhost页面会自动更新.</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><a href="/2018/02/15/Hexo-1/" title="Hexo笔记(一)——安装, Markdown写作与主题">Hexo笔记(一)——安装, Markdown写作与主题</a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/xcatliu/hexo-filter-date-from-git/blob/master/index.js">hexo-filter-date-from-git/index.js</a></li><li><a href="https://stackoverflow.com/a/20807343" target="_blank" rel="noopener">SO - Print a file’s last modified date in Bash</a></li><li><a href="https://blog.csdn.net/dengxu11/article/details/6947078?utm_source=blogxgwz0" target="_blank" rel="noopener">grep 递归指定文件遍历方法</a></li><li><a href="https://blog.singee.me/2018/05/16/hexo/hexo-auto-refresh/" target="_blank" rel="noopener">Hexo利用browsersync进行自动刷新</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给Freemind主题增加显示博文修改时间的功能. 用hexo-browsersync实现server模式实时预览.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="Hexo" scheme="https://github.com/minyez/tags/Hexo/"/>
    
      <category term="Freemind" scheme="https://github.com/minyez/tags/Freemind/"/>
    
      <category term="JavaScript" scheme="https://github.com/minyez/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>解决macOS上脚本中运行VASP时动态库未载入问题</title>
    <link href="https://github.com/minyez/2020/05/09/macos-script-runvasp/"/>
    <id>https://github.com/minyez/2020/05/09/macos-script-runvasp/</id>
    <published>2020-05-09T07:30:23.000Z</published>
    <updated>2020-06-29T07:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>解决macOS上脚本中运行程序遇到dyld: Library not loaded报错.</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>疫情在家工mo作yu期间, 准备在自己macOS上用VASP做点小的测试. 因为懒得重复输入命令, 于是写了一个最基本的shell脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">mpirun -np 4 vasp_std</span><br></pre></td></tr></table></figure><p>第一步载入的是事先写好的VASP相关环境变量. 执行, 结果报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/libmkl_intel_lp64.dylib</span><br><span class="line">  Referenced from: /Users/stevezhang/software/sci/vasp/vasp.5.4.4-intel-2018.0.1/common/bin/vasp_std</span><br><span class="line">  Reason: image not found</span><br></pre></td></tr></table></figure><p>也即<code>libmkl_intel_lp64.dylib</code>没有加到<code>DYLD_LIBRARY_PATH</code>中. 可比较奇怪的是, 在命令行里echo <code>DYLD_LIBRARY_PATH</code>, 返回的是预期结果.</p><h2 id="探索与解决"><a href="#探索与解决" class="headerlink" title="探索与解决"></a>探索与解决</h2><p>写一个非常简单的脚本，检查脚本执行过程中的环境变量.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">module load intel/2018.1</span><br><span class="line">module load mpich/3.2.1-intel-2018.0.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>运行前线载入<code>intel/2018.1</code>模块. 运行脚本发现:</p><ul><li>在module load前后, <code>LIBRARY_PATH</code>和<code>PATH</code>同echo的预期结果相同.</li><li>在module load前, <code>DYLD_LIBRARY_PATH</code>是空的.</li><li>在load后, 只有未在zshrc里载入的MPICH里定义的库路径被加入到<code>DYLD_LIBRARY_PATH</code>中.</li></ul><p>搜索后找到几个帖子描述类似问题:</p><p><a href="https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here" target="_blank" rel="noopener">https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here</a><br><a href="https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1" target="_blank" rel="noopener">https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1</a></p><p>问题原因是，从El Captian开始, macOS引入了系统完整性保护(system integrity protection, SIP), 在调用系统提供的解释器时，所有<code>DYLD_</code>环境变量会被重设. 在使用module管理环境时, 因为intel模块事先被载入过, 因此脚本里面载入intel模块的行为会被module无视, 因此只有MPICH中的变量加入到<code>DYLD_LIBRARY_PATH</code>中.</p><p>一种解决办法是, 在最开始的shell脚本里面手动设置<code>DYLD_LIBRARY_PATH</code>, 缺点是不容易复用bashrc或zshrc里的内容. 更方便的做法是在shell脚本里load完所有module后reload一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">module reload</span><br><span class="line"></span><br><span class="line">mpirun -np 4 vasp_std <span class="comment"># success</span></span><br></pre></td></tr></table></figure><p>另一种可能的办法是<a href="https://blog.csdn.net/qq285744011/article/details/82219340" target="_blank" rel="noopener">关闭SIP</a>, 不过因为reload完全解决了我的需求, 所以就没有尝试这种稍微麻烦些的办法.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决macOS上脚本中运行程序遇到dyld: Library not loaded报错.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="VASP" scheme="https://github.com/minyez/tags/VASP/"/>
    
      <category term="macOS" scheme="https://github.com/minyez/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记(四)——使用MathpixOCR API进行LaTeX公式识别</title>
    <link href="https://github.com/minyez/2019/10/28/mathpix-ocr/"/>
    <id>https://github.com/minyez/2019/10/28/mathpix-ocr/</id>
    <published>2019-10-28T08:39:23.000Z</published>
    <updated>2020-06-30T01:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>编写MathpixOCR API的Python包装器和简单的Automator workflow, 模拟Mathpix Snip Tool的公式识别体验.</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用LaTeX准备文献报告时一个比较头疼的问题是输入文献中包含复杂符号的长公式. <a href="https://mathpix.com/" target="_blank" rel="noopener">Mathpix Snip Tool</a> (MST)提供了方便的光学字符识别功能, 可以将包含公式的截图转化为LaTeX代码. 今年MST从完全免费的1.0版本升级到了2.0, 自此个人用户每月只能免费识别50次, 这对于苦逼PhD显然是不够用的.</p><p>好在作为MST底层的MathpixOCR服务, API每月可免费调用1000次, 所得结果和MST相同, 只是没有MST方便的截图和GUI功能. 归根结底, 我们想实现的无非是识别剪贴板中的公式图片, 转化图片到LaTeX代码并复制到剪贴板而已. 这可以通过将OCR与OS命令包装在一起来实现. 官方提供了简单的<a href="https://github.com/Mathpix/api-examples/tree/master/python">例子</a>供我们学习OCR API的使用, 而OS API可以通过Python包和CLI命令调用. 这篇文章是学习包装器编写的记录.</p><p>最终脚本已上传到<a href="https://github.com/minyez/mathpixocr_wrapper">GitHub仓库</a>, 欢迎下载使用.</p><h2 id="API包装"><a href="#API包装" class="headerlink" title="API包装"></a>API包装</h2><h3 id="获取API密钥"><a href="#获取API密钥" class="headerlink" title="获取API密钥"></a>获取API密钥</h3><p>首先需要在Mathpix上注册用户并填写信用卡信息, 注册后获得<code>app_key</code>和<code>app_id</code>作为API密钥. 脚本采用了两种从外部获取密钥的方式, 一种是环境变量, 另一种是从同路径下JSON读取.</p><h3 id="从系统剪贴板获取图片"><a href="#从系统剪贴板获取图片" class="headerlink" title="从系统剪贴板获取图片"></a>从系统剪贴板获取图片</h3><p>使用pillow包中的<code>ImageGrab.grabclipboard</code>获取剪贴版中的图片, 并产生<code>Image</code>对象. 注意, 此后剪贴板中的临时文件会被删除, 无法再直接通过路径获得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im = ImageGrab.grabclipboard()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(im.filename)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>因此需要先把图片保存下来才能在后续继续使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">im = ImageGrab.grabclipboard()</span><br><span class="line">fn = <span class="string">".temp_eq.png"</span></span><br><span class="line">im.save(fn, <span class="string">"PNG"</span>)</span><br></pre></td></tr></table></figure><h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p>OCR要求图片编码为base64. 编码转换可以参考官方例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_uri</span><span class="params">(fn)</span>:</span></span><br><span class="line">  image_data = open(fn, <span class="string">"rb"</span>).read()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"data:image/jpg;base64,"</span> + base64.b64encode(image_data).decode()</span><br></pre></td></tr></table></figure><p><code>b64encode</code>使用Base64规则将一串类字节字符串进行编码, <code>decode</code>方法返回编码后的普通字符串.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec = base64.b64encode(<span class="string">b"abcdefg"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec</span><br><span class="line"><span class="string">b'YWJjZGVmZw=='</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec.decode()</span><br><span class="line"><span class="string">'YWJjZGVmZw=='</span></span><br></pre></td></tr></table></figure><h3 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h3><p>通过<code>requests</code>包与OCR API进行通信. 通信数据要求为JSON, 它至少需要包含<code>src</code>和<code>format</code>两个键. <code>src</code>值就是base64编码后的图片字符串, <code>format</code>值为一个列表, 成员为所想要转换的格式, 支持的转化格式包括下面几种.</p><table><thead><tr><th style="text-align:left"><code>format</code>值</th><th style="text-align:left">转化格式</th></tr></thead><tbody><tr><td style="text-align:left"><code>text</code></td><td style="text-align:left">普通文本</td></tr><tr><td style="text-align:left"><code>wolfram</code></td><td style="text-align:left">Mathematica</td></tr><tr><td style="text-align:left"><code>latex_simplified</code></td><td style="text-align:left">简化的latex代码, 括号不包含left或right</td></tr><tr><td style="text-align:left"><code>latex_styled</code></td><td style="text-align:left">left/right控制的latex代码</td></tr></tbody></table><p>利用<code>json</code>包将字典转化成JSON字符串, 用<code>requests</code>发送API请求到<code>v3/latex</code>端点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = json.dump(&#123;<span class="string">"src"</span>: img_base64, <span class="string">"format"</span>: [<span class="string">"latex_simplified"</span>,]&#125;)</span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  <span class="string">'app_key'</span>: your_app_key,</span><br><span class="line">  <span class="string">'app_id'</span>: your_app_id,</span><br><span class="line">  &#125;</span><br><span class="line">r = requests.post(<span class="string">'https://api.mathpix.com/v3/latex'</span>,</span><br><span class="line">                  data=data, headers=headers)</span><br></pre></td></tr></table></figure><p>通信返回的<code>r.text</code>是一个JSON字符串. 如果OCR识别成功, 则它包含<code>latex_simplified</code>键, 对应值为识别号的简化LaTeX代码. 如果识别失败, 则包含<code>error</code>键, 给出具体错误信息. 更复杂的API调用参考<a href="https://docs.mathpix.com/" target="_blank" rel="noopener">官方文档</a>.</p><div class="alert alert-info"><i class="fa fa-info  float-left"></i>  <p><code>v3/latex</code>端点目前是旧端点. 官方推荐使用<code>v/3text</code>, 通信所需的JSON关键词有些许不同, 但变化不是很大, 读者可自行参考文档修改. (2020-06-29)</p></div><h3 id="拷贝转化好的LaTeX到系统剪贴板"><a href="#拷贝转化好的LaTeX到系统剪贴板" class="headerlink" title="拷贝转化好的LaTeX到系统剪贴板"></a>拷贝转化好的LaTeX到系统剪贴板</h3><p>参考了<a href="https://gist.github.com/luqmaan/d8bc61e746207bb12f11" target="_blank" rel="noopener">这个GIST</a>, 使用macOS上的<code>pbcopy</code>将字符串拷贝到系统剪贴板. 另一种办法是直接打印到标准输出, 然后用Automator服务中的功能拷贝到剪贴板.</p><h3 id="附加功能"><a href="#附加功能" class="headerlink" title="附加功能"></a>附加功能</h3><p>比如每月API调用统计以及历史记录, 都保存在JSON文件中. 实现说起来比较琐碎, 就不赘述了.</p><h2 id="Automator服务"><a href="#Automator服务" class="headerlink" title="Automator服务"></a>Automator服务</h2><p>把写好的包装器放到<code>~/bin</code>下, 编写简单的工作流<code>Mathpix Snip OCR API</code></p><p><figure class="null"><img src="automator_workflow.png" alt=" "><figcaption> </figcaption></figure></p><p>然后在系统设置-键盘-快捷键设置服务的快捷键</p><p><figure class="null"><img src="shortcut.png" alt=" "><figcaption> </figcaption></figure></p><p>如此一来, <code>cmd+shift+4</code>将公式截屏到剪贴板后<code>cmd+shift+M</code>, 等待片刻即可从剪贴板黏贴转换好的公式. 大功告成!</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>使用pillow包来获取剪贴板图片: <a href="https://zhuanlan.zhihu.com/p/83678942" target="_blank" rel="noopener">Mathpix收费了？快使用API吧，一个月免费识别1000次！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写MathpixOCR API的Python包装器和简单的Automator workflow, 模拟Mathpix Snip Tool的公式识别体验.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="LaTeX" scheme="https://github.com/minyez/tags/LaTeX/"/>
    
      <category term="MathpixOCR" scheme="https://github.com/minyez/tags/MathpixOCR/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记(三)——用pyecharts制作统计地图</title>
    <link href="https://github.com/minyez/2019/10/20/speaker-map/"/>
    <id>https://github.com/minyez/2019/10/20/speaker-map/</id>
    <published>2019-10-20T14:47:28.000Z</published>
    <updated>2019-10-20T14:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>以会议报告人所在机构的分布为例, 介绍如何基于pyecharts制作地理分布图.</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间去深圳参加一个研究方向有关的会议, 国内做实验和理论研究的老师都来了, 于是心血来潮想有没有可能做一个统计来看看老师们所在机构的地理分布. 虽然报告人并不多, 但应该也能提供一些定性的信息, 也算是学习一种图片制作和数据展示技巧.<br>经过一番搜索, 决定采用Python包<code>pyecharts</code>中的地理图标<code>Geo</code>类来制作. 使用Python版本为3.7.1, pyecharts版本为1.5.1.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先通过pip安装pyecharts</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyecharts</span><br></pre></td></tr></table></figure><p>同时安装中国省市地图包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip echarts-china-provinces-pypkg echarts-china-cities-pypkg</span><br></pre></td></tr></table></figure><p>为方便直接输出图片, 安装<code>snapshot_selenium</code>或者<code>snapshot_phantomjs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip snapshot_selenium snapshot_phantomjs</span><br></pre></td></tr></table></figure><h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><p>简化一下存放在<code>site-packages/example</code>里的<code>geo_example.py</code>, 得到下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Geo, Page</span><br><span class="line"><span class="keyword">from</span> pyecharts.faker <span class="keyword">import</span> Collector</span><br><span class="line"><span class="keyword">from</span> pyecharts.render <span class="keyword">import</span> make_snapshot</span><br><span class="line"><span class="comment">#from snapshot_selenium import snapshot</span></span><br><span class="line"><span class="keyword">from</span> snapshot_phantomjs <span class="keyword">import</span> snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># speaker.json存储了以speaker老师名字为key的字典</span></span><br><span class="line"><span class="comment"># 包含"省份"和"方向"两个key-value.</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"speaker.json"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> h:</span><br><span class="line">    speaker = json.load(h)</span><br><span class="line">provs = [s[<span class="string">"省份"</span>] <span class="keyword">for</span> s <span class="keyword">in</span> speaker.values()]</span><br><span class="line">data = [[p, provs.count(p)] <span class="keyword">for</span> p <span class="keyword">in</span> set(provs)]</span><br><span class="line"></span><br><span class="line">C = Collector</span><br><span class="line"></span><br><span class="line"><span class="meta">@C.funcs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geo_speakermap</span><span class="params">()</span> -&gt; Geo:</span></span><br><span class="line">    c = (</span><br><span class="line">        Geo()</span><br><span class="line">        .add_schema(maptype=<span class="string">"china"</span>)</span><br><span class="line">        .add(<span class="string">""</span>, data)</span><br><span class="line">        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="keyword">False</span>))</span><br><span class="line">        .set_global_opts(</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(min_=<span class="number">0</span>, max_=<span class="number">15</span>, type_=<span class="string">"size"</span>),</span><br><span class="line">            title_opts=opts.TitleOpts(title=<span class="string">"报告人分布"</span>),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">make_snapshot(snapshot, Page().add(*[fn() <span class="keyword">for</span> fn, _ <span class="keyword">in</span> C.charts]).render(),</span><br><span class="line">              <span class="string">"speakermap.png"</span>, browser=<span class="string">'Safari'</span>)</span><br></pre></td></tr></table></figure><p>得到分布图如下</p><p><figure class="null"><img src="speakermap.png" alt=" "><figcaption> </figcaption></figure></p><p>报告人主要分布在沿海城市的大学和研究所, 除了bug的帝都. 下面就作图涉及的几个点具体说明一下</p><h3 id="Collector类"><a href="#Collector类" class="headerlink" title="Collector类"></a>Collector类</h3><p><code>Collector</code>是pyechart提供的一个convenient function, 源码很短, 提供了一个列表属性和一个静态方法用<code>Collector.funcs</code>装饰后, 函数返回的<code>Geo</code>实例会加入到列表<code>Collector.charts</code>中.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collector</span>:</span></span><br><span class="line">    charts = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcs</span><span class="params">(fn)</span>:</span></span><br><span class="line">        Collector.charts.append((fn, fn.__name__))</span><br></pre></td></tr></table></figure><p><code>Geo</code>类及其方法的调用利用了方法链语法, 不需要换行符来强制换行.</p><h3 id="全局变量控制"><a href="#全局变量控制" class="headerlink" title="全局变量控制"></a>全局变量控制</h3><p>用<code>set_global_opts</code>方法调整echarts图片的全局设置. 这个方法继承自<code>Chart</code>类.<br>参数<code>visualmap_opts</code>控制左下角标尺, 需要以<code>pyecharts.options.VisualMapOpts</code>实例作为输入.<br>这里因为总人数比较少, 所以调整了最大范围为15, 并用图标尺寸而非颜色来表示数值大小(<code>type_</code>), 加强对比.<br>其他全局变量设置可以参考<a href="https://pyecharts.org/#/zh-cn/global_options" target="_blank" rel="noopener">官网</a>.</p><h3 id="图片生成"><a href="#图片生成" class="headerlink" title="图片生成"></a>图片生成</h3><p><code>pyecharts.render.snapshot</code>提供了<code>make_snapshot</code>函数. <code>make_snapshot</code>实际是selenium或phantomjs的<code>snapshot</code>同名函数的包装.</p><p>这里用phantomjs直接渲染更快一些, 且不会跳出Safari.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于pyecharts的<code>Geo</code>类制作了报告人所在机构的地理分布. 文中所描述的图片制作是一些简单尝试, 还有很多应该可以调教的地方, 比如标记的颜色, 标尺和主图的相对位置. 不过统计数据太少, 机构地点还只限制在省级, 所得到的结论比较trivial.</p><p>echarts还提供了包括全球和国内省市地图在内的其他地图以及word cloud等不同类型的图片呈现方式, 并有现成的例子可供参考, 为地理数据统计和展示提供了一种方便的选择.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/45202403" target="_blank" rel="noopener">知乎 - Python绘制中国地图</a>: 引导我使用pyecharts. 但是这个教程及其中链接的官方网站的API不适用于1.5.1版本.</p><p><a href="https://pyecharts.org/#/zh-cn/intro" target="_blank" rel="noopener">pyecharts官网</a></p><p><a href="https://ramiro.org/notebook/geopandas-choropleth/" target="_blank" rel="noopener">Creating a Choropleth Map of the World in Python using GeoPandas</a>: 做全球数据统计看上去很不错</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以会议报告人所在机构的分布为例, 介绍如何基于pyecharts制作地理分布图.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://github.com/minyez/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://github.com/minyez/tags/Python/"/>
    
      <category term="pyecharts" scheme="https://github.com/minyez/tags/pyecharts/"/>
    
      <category term="map" scheme="https://github.com/minyez/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>GPAW笔记(五)——重启GW</title>
    <link href="https://github.com/minyez/2019/09/12/gpaw-5-gw-restart/"/>
    <id>https://github.com/minyez/2019/09/12/gpaw-5-gw-restart/</id>
    <published>2019-09-12T11:07:28.000Z</published>
    <updated>2019-09-12T11:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>记录如何修改GPAW源码以允许开启ecut外推(<code>ecut_extrapolation=True</code>)的GW计算重启.</p></div><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在超算上进行大体系计算时, 经常会遇到的问题是计算因为超过了单个任务所需时间而被迫停止.</p><p>一般SCF计算可以通过读写波函数来重启, 但GW计算重启起来稍微麻烦一些, 也有不同的策略, 比如单独输出介电矩阵元.</p><p>在GPAW中, 重启GW计算可以通过指定<code>restartfile</code>参数来实现. 对于一个可能超时的计算, 在计算初始就指定<code>restartfile</code>, 那么在计算停止后以同样命令重新执行脚本, GPAW就会从停止的地方继续计算.</p><p>GPAW的GW重启机制是将已经计算好的来自<code>nQ</code>个q点的自能和自能梯度以及N存到<code>restartfile</code>里, 中断后读取之, 再从<code>nQ+1</code>个q点开始屏蔽库仑作用和自能的计算.</p><p>在1.5.2版本下, 从<code>gpaw.response.g0w0</code>的源码L1330看一下<code>restartfile</code>所存字典的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'last_q'</span>: nQ,</span><br><span class="line">    <span class="string">'sigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'nsigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'ecut_e'</span>: np.zeros(necut),</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>necut</code>是指定的介电矩阵截断的个数, 在<code>ecut_extrapolation=True</code>时等于3, 否则为1. 屏蔽库仑作用计算采用q点外循环和ecut内循环, 因此对于<code>necut</code>大于1的情况, 如果计算恰好在某个中间的ecut处停止, 那么该q点后面的ecut的计算就会被跳过.</p><p>因此若要在<code>necut</code>大于1的情况, 也即做ecut外推的情况下正确重启GW计算, 需要修改源码. 自己的做法是在字典里增加一个<code>last_ecut</code>的关键词, 定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'last_ecut'</span>: nQ * len(self.ecut_e) + iecut</span><br></pre></td></tr></table></figure><p>并在load时读取到<code>last_ecut</code>属性. 实际上<code>last_ecut</code>同时对q点和ecut进行记数. iecut则作为<code>save_restart_file</code>的额外参数传入. 相应修改跳过判定条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iq, q_c <span class="keyword">in</span> enumerate(self.qd.ibzk_kc):</span><br><span class="line">    <span class="keyword">if</span> iq &lt;= self.last_q - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> ie, ecut <span class="keyword">in</span> enumerate(self,ecut_e):</span><br><span class="line">        <span class="keyword">if</span> ie &lt;= self.last_ecut - iq * len(self.ecut_e):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">if</span> self.restartfile <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.save_restart_file(iq,ie)</span><br></pre></td></tr></table></figure><p>这样就能正确重启包含ecut外推的G0W0计算了. 尽管如此, 因为外面还有一层自洽GW迭代步数的循环, 这样的修改对自恰GW可能还是有问题, 不过对我自己已经足够了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录如何修改GPAW源码以允许开启ecut外推(&lt;code&gt;ecut_extrapolation=True&lt;/code&gt;)的GW计算重启.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="GPAW" scheme="https://github.com/minyez/tags/GPAW/"/>
    
      <category term="GW" scheme="https://github.com/minyez/tags/GW/"/>
    
  </entry>
  
  <entry>
    <title>WIEN2k笔记(二)——SCAN metaGGA计算</title>
    <link href="https://github.com/minyez/2019/08/09/wien2k-scan/"/>
    <id>https://github.com/minyez/2019/08/09/wien2k-scan/</id>
    <published>2019-08-09T06:12:16.000Z</published>
    <updated>2019-08-09T06:12:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>总结WIEN2k中进行SCAN meta-GGA泛函计算的工作流程, 进行简单的参数收敛测试.</p></div><a id="more"></a><h2 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h2><p>WIEN2k在v16.1版本后支持SCAN (Strongly Constrained and Appropriately Normed) meta-GGA泛函的DFT计算. 该泛函目前在分子和固体结构预测上取得了很大成功, 具体可以参看Sun等在2015年的PRL, 2016年的NC.</p><p>根据手册(p113, WIEN2k_17.1, release 07/03/2017), 在WIEN2k中作SCAN计算的工作流程如下</p><ol><li><p>先用和PBE相同的方式初始化. 这里在非交互模式下, 全部用默认值</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_lapw -b -numk 1000 -ecut -6 -rkmax 7.0</span><br></pre></td></tr></table></figure></li><li><p>运行一步PBE计算.</p></li><li>自洽运行SCAN计算.</li></ol><p>初始化后的流程可以用下面的脚本概括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">cn = <span class="string">"Si"</span> <span class="comment"># case name</span></span><br><span class="line"><span class="comment"># 第一步: 拷贝样例文件的case.inm_vresp</span></span><br><span class="line">cp <span class="variable">$WIENROOT</span>/SRC_templates/case.inm_vresp <span class="variable">$cn</span>.inm_vresp</span><br><span class="line"><span class="comment"># 第二步: 用PBE泛函作单步计算</span></span><br><span class="line">sed -i <span class="string">"s/XC_SCAN /XC_PBE /g"</span> <span class="variable">$cn</span>.in0</span><br><span class="line">run_lapw -i 1</span><br><span class="line"><span class="comment"># 第三步: 用SCAN作自洽场计算</span></span><br><span class="line">sed -i <span class="string">"s/XC_PBE /XC_SCAN /g"</span> <span class="variable">$cn</span>.in0</span><br><span class="line">rm -f <span class="variable">$cn</span>.broyd*</span><br><span class="line">run_lapw -ec 0.00000001 -cc 0.00001</span><br></pre></td></tr></table></figure><h2 id="相关参数测试"><a href="#相关参数测试" class="headerlink" title="相关参数测试"></a>相关参数测试</h2><p>根据手册, 主要对in0中FFT格点<code>IFFT</code>和in2中电子密度展开截断<code>GMAX</code>进行测试. 测试体系为硅, 晶格常数10.405822 Bohr, RMT取2.24.</p><p>测试针对的是总能量, 因为WIEN2k中SCAN能量泛函不是自洽包含的, 解KS方程时用的势是PBE的势, 所以在<strong>WIEN2k中</strong>用PBE和SCAN得到的带隙是相同的. 具体见这一条<a href="https://www.mail-archive.com/wien@zeus.theochem.tuwien.ac.at/msg17640.html" target="_blank" rel="noopener">WIEN2k mailing list</a>.</p><p>PBE总能量的收敛. 可以看到在默认的GMAX=12, IFFT=40的情况下, PBE总能量已经充分收敛到0.1 meV以下.</p><table><thead><tr><th style="text-align:center">GMAX</th><th style="text-align:center">IFFT=40</th><th style="text-align:center">60</th><th style="text-align:center">80</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">-1160.14169256</td><td style="text-align:center">-1160.14169460</td><td style="text-align:center">-1160.14169529</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">-1160.14169232</td><td style="text-align:center">-1160.14169441</td><td style="text-align:center">-1160.14169504</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">-1160.14169228</td><td style="text-align:center">-1160.14169437</td><td style="text-align:center">-1160.14169501</td></tr></tbody></table><p>SCAN总能量的收敛. 比较默认值和最大的参数, 差值大约为4 meV. 可见对这两个参数而言, SCAN收敛速度确实比PBE慢, 尤其是IFFT.</p><table><thead><tr><th style="text-align:center">GMAX</th><th style="text-align:center">IFFT=40</th><th style="text-align:center">60</th><th style="text-align:center">80</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">-1160.80053722</td><td style="text-align:center">-1160.80033890</td><td style="text-align:center">-1160.80026834</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">-1160.80050967</td><td style="text-align:center">-1160.80031217</td><td style="text-align:center">-1160.80024159</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">-1160.80053445</td><td style="text-align:center">-1160.80033894</td><td style="text-align:center">-1160.80026946</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Sun, J. et al. Strongly Constrained and Appropriately Normed Semilocal Density Functional. <a href="http://link.aps.org/doi/10.1103/PhysRevLett.115.036402" target="_blank" rel="noopener">Phys. Rev. Lett. 115, 036402 (2015)</a></p><p>Perdew, J. et al. Semilocal density functionals and constraint satisfaction. <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/qua.25100" target="_blank" rel="noopener">Int. J. Quantum Chem. 116, 847-851 (2016)</a></p><p>Sun, J. et al. Accurate first-principles structures and energies of diversely bonded systems from an efficient density functional. <a href="https://www.nature.com/articles/nchem.2535" target="_blank" rel="noopener">Nat. Chem. 8, 831-836 (2016)</a></p><p>Supplementary material: Performance of various density-functional approximations for cohesive properties of 64 bulk solids. <a href="https://th.fhi-berlin.mpg.de/site/uploads/Publications/suppl-mater-NJP108118-R1.pdf" target="_blank" rel="noopener">Link</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结WIEN2k中进行SCAN meta-GGA泛函计算的工作流程, 进行简单的参数收敛测试.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="WIEN2k" scheme="https://github.com/minyez/tags/WIEN2k/"/>
    
      <category term="DFT" scheme="https://github.com/minyez/tags/DFT/"/>
    
      <category term="SCAN" scheme="https://github.com/minyez/tags/SCAN/"/>
    
  </entry>
  
  <entry>
    <title>XmGrace小技巧汇总</title>
    <link href="https://github.com/minyez/2019/07/31/grace-tips/"/>
    <id>https://github.com/minyez/2019/07/31/grace-tips/</id>
    <published>2019-07-31T12:14:19.000Z</published>
    <updated>2019-07-31T12:14:19.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>收集笔者常用的(Xm)Grace使用的技巧.</p></div><a id="more"></a><p>以下的操作均可以在<a href="https://sourceforge.net/projects/qtgrace/" target="_blank" rel="noopener">qtgrace</a>下实现.</p><h2 id="数据集变换"><a href="#数据集变换" class="headerlink" title="数据集变换"></a>数据集变换</h2><p>Grace中支持多种数据处理, 从简单的求前后两点的差, 到复杂的函数变换和非线性拟合.</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>XmGrace包含差分功能, 支持三种不同差分方式: 向前差分(Forward), 向后差分(Backword)或者居中差分(centered).</p><p>$$<br>\begin{aligned}<br>\text{forward} &amp;: y’_{i, f} = \frac{y_{i+1}-y_i}{x_{i+1}-x_i}\\<br>\text{backward} &amp;: y’_{i, b} = \frac{y_i-y_{i-1}}{x_i-x_{i-1}}\\<br>\text{centered} &amp;: y’_{i, c} = \frac{y_{i+1}-y_{i-1}}{x_{i+1}-x_{i-1}}\\<br>\end{aligned}<br>$$</p><p>以函数$y=4(x-0.5)^2$为例, 其导数$y’=8x-4$.</p><ol><li><p>选中差分功能: Data-&gt;Tranformation-&gt;Differences</p><p> <figure class="null"><img src="differences_1.jpg" alt="选中XmGrace的差分功能"><figcaption>选中XmGrace的差分功能</figcaption></figure></p></li><li><p>选中一组数据, 确认差分方案</p><p> <figure class="null"><img src="differences_2.jpg" alt="差分功能界面, 向前差分"><figcaption>差分功能界面, 向前差分</figcaption></figure></p></li><li><p>Accept确认.</p></li><li><p>检查差分结果. 需要注意, 这里向前向后差分结果是相同的, 原因是向后差分的横坐标错了. 因此建议使用向前或居中差分.</p><p> <figure class="null"><img src="differences_3.jpg" alt="差分功能界面, 向前差分"><figcaption>差分功能界面, 向前差分</figcaption></figure></p></li></ol><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>用<code>Evaluate expression</code>功能, 可以对数据进行自定义的函数变换. 它可以对单组数据的xy进行操作, 也可以在多组数据间操作, 非常方便. 该功能和Differences一样在Transformations标签里, 具体位置见第一张图.</p><p><figure class="null"><img src="eval_expr_1.jpg" alt="表达式求值, 对数据作变换"><figcaption>表达式求值, 对数据作变换</figcaption></figure></p><ol><li>选中想要操作的数据.</li><li>填写函数变换的表达式.</li><li>勾选Sync. selection, 使变换后的数据直接替换原有数据set. 如果不勾选, Destination下的数据栏中也没有选中任何set, 则变换后的数据会存在新的set中.</li><li>确认.</li></ol><p>这里主要说一下第二条. 在写表达式时, <code>y</code>表示纵坐标, <code>x</code>表示横坐标. 一些常用的变换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 向上平移0.5</span><br><span class="line">y = y + 0.5</span><br><span class="line"># 以第10个数据为零点进行平移</span><br><span class="line">y = y - y[9]</span><br><span class="line"># 求G0.S0和G1.S1之间的差</span><br><span class="line">y = G0.S0.y - G1.S1.y</span><br><span class="line"># 求自然对数</span><br><span class="line">y = ln(y)</span><br><span class="line"># 将横坐标转为角度</span><br><span class="line">x = x * 180 / PI</span><br></pre></td></tr></table></figure><p>更多的函数可以参考官网<a href="http://plasma-gate.weizmann.ac.il/Xmgr/doc/trans.html" target="_blank" rel="noopener">Xmgr: transformations</a></p><h2 id="双y轴-Double-y-axis"><a href="#双y轴-Double-y-axis" class="headerlink" title="双y轴(Double y-axis)"></a>双y轴(Double y-axis)</h2><p>参考这一<a href="sachinashanbhag.blogspot.com/2012/06/grace-tutorial-how-to-plot-graph-with.html">链接</a>, 制作包含两个不同y轴的图, 以在同一张图中展示用有相同横坐标, 但纵坐标范围不同的两组数据.</p><p><figure class="null"><img src="double_y_1.jpg" alt=" "><figcaption> </figcaption></figure></p><ol><li>在窗口个中放置两张并排的图. Edit-&gt;Arrange graphs…</li><li>将cols改为2.</li><li><p>确认.</p><p> <figure class="null"><img src="double_y_2.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>将右图盖到左图上. Edit-&gt;Overlay graphs…</p></li><li>选中G1为要覆盖的图.</li><li>选中G0为被覆盖上的图.</li><li>将Smart axis hint设置为”Same X axis scaling”.</li><li><p>确认. 这个时候两张图覆盖在了一起, 都窝在整个窗口的左侧.</p><p> <figure class="null"><img src="double_y_3.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>调节图的范围. Plot-&gt;Graph appearance. 在Viewpoint设置G0的xmax, 例如1.15.</p></li><li>对G1作同样的操作.</li><li><p>确认.</p><p><figure class="null"><img src="double_y_4.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>为了分辨两个y轴, 用不同的颜色来区分. 双击右侧的y轴</p></li><li>确认在目前正在操作G1.</li><li>正常操作, 调节G1 y轴的属性.</li><li>确认.</li></ol><p>有一点需要注意的是, 当调整y轴粗细比1大的时候, 可能会在某个y轴上看到黑线. 这是图的边框, 可以通过将Graph appearance中Frame标签下Frame box的透明度调到最低来消除.</p><h2 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h2><p>在XmGrace里输入坐标轴标记或者图例时, 有时会需要输入一些希腊字母或上下标之类的复杂组合, 或者使用斜体以表示物理量.</p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>单独的上下标比较容易, 分别<code>a\Sb\N</code>是<code>c\sd\N</code>. 要输入具有上下标的符号, 用<code>a\Sb\N\sc\N</code>会使得下标或上标与符号隔得太远. 此时可以用<code>\v{}</code>或者<code>\h{}</code>分别调整垂直和水平的位置. 比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a\Sb\N\s\v&#123;0.2&#125;\h&#123;-0.5&#125;c\N</span><br></pre></td></tr></table></figure><p><figure class="null"><img src="simult_supsub.png" alt=" "><figcaption> </figcaption></figure></p><h3 id="希腊字母与字体"><a href="#希腊字母与字体" class="headerlink" title="希腊字母与字体"></a>希腊字母与字体</h3><p>希腊字符使用和字体调整本质上是相同的, 因为希腊字母实际上使用的是Symbol字体. 使用某种字体对应的语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;font&#125;text in font\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>比如斜体的Times New Roman</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;Times-Italic&#125;italic here\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>希腊字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;Symbol&#125;G\f&#123;&#125; = \xG\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>\x</code>其实等价于<code>\f{Symbol}</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集笔者常用的(Xm)Grace使用的技巧.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="XmGrace" scheme="https://github.com/minyez/tags/XmGrace/"/>
    
  </entry>
  
</feed>
