<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shigaro</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/minyez/"/>
  <updated>2019-09-12T11:52:29.000Z</updated>
  <id>https://github.com/minyez/</id>
  
  <author>
    <name>minyez</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPAW笔记(五)——重启GW</title>
    <link href="https://github.com/minyez/2019/09/12/gpaw-5-gw-restart/"/>
    <id>https://github.com/minyez/2019/09/12/gpaw-5-gw-restart/</id>
    <published>2019-09-12T11:07:28.000Z</published>
    <updated>2019-09-12T11:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文简单记录了如何修改GPAW源码以允许开启ecut外推(<code>ecut_extrapolation=True</code>)的GW计算重启.<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在超算上进行大体系计算时, 经常会遇到的问题是计算因为超过了单个任务所需时间而被迫停止.</p><p>一般SCF计算可以通过读写波函数来重启, 但GW计算重启起来稍微麻烦一些, 也有不同的策略, 比如单独输出介电矩阵元.</p><p>在GPAW中, 重启GW计算可以通过指定<code>restartfile</code>参数来实现. 对于一个可能超时的计算, 在计算初始就指定<code>restartfile</code>, 那么在计算停止后以同样命令重新执行脚本, GPAW就会从停止的地方继续计算.</p><p>GPAW的GW重启机制是将已经计算好的来自<code>nQ</code>个q点的自能和自能梯度以及N存到<code>restartfile</code>里, 中断后读取之, 再从<code>nQ+1</code>个q点开始屏蔽库仑作用和自能的计算.</p><p>在1.5.2版本下, 从<code>gpaw.response.g0w0</code>的源码L1330看一下<code>restartfile</code>所存字典的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'last_q'</span>: nQ,</span><br><span class="line">    <span class="string">'sigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'nsigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'ecut_e'</span>: np.zeros(necut),</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>necut</code>是指定的介电矩阵截断的个数, 在<code>ecut_extrapolation=True</code>时等于3, 否则为1. 屏蔽库仑作用计算采用q点外循环和ecut内循环, 因此对于<code>necut</code>大于1的情况, 如果计算恰好在某个中间的ecut处停止, 那么该q点后面的ecut的计算就会被跳过.</p><p>因此若要在<code>necut</code>大于1的情况, 也即做ecut外推的情况下正确重启GW计算, 需要修改源码. 自己的做法是在字典里增加一个<code>last_ecut</code>的关键词, 定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'last_ecut'</span>: nQ * len(self.ecut_e) + iecut</span><br></pre></td></tr></table></figure><p>并在load时读取到<code>last_ecut</code>属性. 实际上<code>last_ecut</code>同时对q点和ecut进行记数. iecut则作为<code>save_restart_file</code>的额外参数传入. 相应修改跳过判定条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iq, q_c <span class="keyword">in</span> enumerate(self.qd.ibzk_kc):</span><br><span class="line">    <span class="keyword">if</span> iq &lt;= self.last_q - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> ie, ecut <span class="keyword">in</span> enumerate(self,ecut_e):</span><br><span class="line">        <span class="keyword">if</span> ie &lt;= self.last_ecut - iq * len(self.ecut_e):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">if</span> self.restartfile <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.save_restart_file(iq,ie)</span><br></pre></td></tr></table></figure><p>这样就能正确重启包含ecut外推的G0W0计算了. 尽管如此, 因为外面还有一层自洽GW迭代步数的循环, 这样的修改对自恰GW可能还是有问题, 不过对我自己已经足够了.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文简单记录了如何修改GPAW源码以允许开启ecut外推(&lt;code&gt;ecut_extrapolation=True&lt;/code&gt;)的GW计算重启.
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="GPAW" scheme="https://github.com/minyez/tags/GPAW/"/>
    
      <category term="GW" scheme="https://github.com/minyez/tags/GW/"/>
    
  </entry>
  
  <entry>
    <title>WIEN2k笔记(二)——SCAN metaGGA计算</title>
    <link href="https://github.com/minyez/2019/08/09/wien2k-scan/"/>
    <id>https://github.com/minyez/2019/08/09/wien2k-scan/</id>
    <published>2019-08-09T06:12:16.000Z</published>
    <updated>2019-08-09T09:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总结WIEN2k中进行SCAN meta-GGA泛函计算的工作流程, 进行简单的参数收敛测试.<br><a id="more"></a></p><h2 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h2><p>WIEN2k在v16.1版本后支持SCAN (Strongly Constrained and Appropriately Normed) meta-GGA泛函的DFT计算. 该泛函目前在分子和固体结构预测上取得了很大成功, 具体可以参看Sun等在2015年的PRL, 2016年的NC.</p><p>根据手册(p113, WIEN2k_17.1, release 07/03/2017), 在WIEN2k中作SCAN计算的工作流程如下</p><ol><li><p>先用和PBE相同的方式初始化. 这里在非交互模式下, 全部用默认值</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_lapw -b -numk 1000 -ecut -6 -rkmax 7.0</span><br></pre></td></tr></table></figure></li><li><p>运行一步PBE计算.</p></li><li>自洽运行SCAN计算.</li></ol><p>初始化后的流程可以用下面的脚本概括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">cn = <span class="string">"Si"</span> <span class="comment"># case name</span></span><br><span class="line"><span class="comment"># 第一步: 拷贝样例文件的case.inm_vresp</span></span><br><span class="line">cp <span class="variable">$WIENROOT</span>/SRC_templates/case.inm_vresp <span class="variable">$cn</span>.inm_vresp</span><br><span class="line"><span class="comment"># 第二步: 用PBE泛函作单步计算</span></span><br><span class="line">sed -i <span class="string">"s/XC_SCAN /XC_PBE /g"</span> <span class="variable">$cn</span>.in0</span><br><span class="line">run_lapw -i 1</span><br><span class="line"><span class="comment"># 第三步: 用SCAN作自洽场计算</span></span><br><span class="line">sed -i <span class="string">"s/XC_PBE /XC_SCAN /g"</span> <span class="variable">$cn</span>.in0</span><br><span class="line">rm -f <span class="variable">$cn</span>.broyd*</span><br><span class="line">run_lapw -ec 0.00000001 -cc 0.00001</span><br></pre></td></tr></table></figure><h2 id="相关参数测试"><a href="#相关参数测试" class="headerlink" title="相关参数测试"></a>相关参数测试</h2><p>根据手册, 主要对in0中FFT格点<code>IFFT</code>和in2中电子密度展开截断<code>GMAX</code>进行测试. 测试体系为硅, 晶格常数10.405822 Bohr, RMT取2.24.</p><p>测试针对的是总能量, 因为WIEN2k中SCAN能量泛函不是自洽包含的, 解KS方程时用的势是PBE的势, 所以在<strong>WIEN2k中</strong>用PBE和SCAN得到的带隙是相同的. 具体见这一条<a href="https://www.mail-archive.com/wien@zeus.theochem.tuwien.ac.at/msg17640.html" target="_blank" rel="noopener">WIEN2k mailing list</a>.</p><p>PBE总能量的收敛. 可以看到在默认的GMAX=12, IFFT=40的情况下, PBE总能量已经充分收敛到0.1 meV以下.</p><table><thead><tr><th style="text-align:center">GMAX</th><th style="text-align:center">IFFT=40</th><th style="text-align:center">60</th><th style="text-align:center">80</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">-1160.14169256</td><td style="text-align:center">-1160.14169460</td><td style="text-align:center">-1160.14169529</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">-1160.14169232</td><td style="text-align:center">-1160.14169441</td><td style="text-align:center">-1160.14169504</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">-1160.14169228</td><td style="text-align:center">-1160.14169437</td><td style="text-align:center">-1160.14169501</td></tr></tbody></table><p>SCAN总能量的收敛. 比较默认值和最大的参数, 差值大约为4 meV. 可见对这两个参数而言, SCAN收敛速度确实比PBE慢, 尤其是IFFT.</p><table><thead><tr><th style="text-align:center">GMAX</th><th style="text-align:center">IFFT=40</th><th style="text-align:center">60</th><th style="text-align:center">80</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">-1160.80053722</td><td style="text-align:center">-1160.80033890</td><td style="text-align:center">-1160.80026834</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">-1160.80050967</td><td style="text-align:center">-1160.80031217</td><td style="text-align:center">-1160.80024159</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">-1160.80053445</td><td style="text-align:center">-1160.80033894</td><td style="text-align:center">-1160.80026946</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Sun, J. et al. Strongly Constrained and Appropriately Normed Semilocal Density Functional. <a href="http://link.aps.org/doi/10.1103/PhysRevLett.115.036402" target="_blank" rel="noopener">Phys. Rev. Lett. 115, 036402 (2015)</a></p><p>Perdew, J. et al. Semilocal density functionals and constraint satisfaction. <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/qua.25100" target="_blank" rel="noopener">Int. J. Quantum Chem. 116, 847-851 (2016)</a></p><p>Sun, J. et al. Accurate first-principles structures and energies of diversely bonded systems from an efficient density functional. <a href="https://www.nature.com/articles/nchem.2535" target="_blank" rel="noopener">Nat. Chem. 8, 831-836 (2016)</a></p><p>Supplementary material: Performance of various density-functional approximations for cohesive properties of 64 bulk solids. <a href="https://th.fhi-berlin.mpg.de/site/uploads/Publications/suppl-mater-NJP108118-R1.pdf" target="_blank" rel="noopener">Link</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;总结WIEN2k中进行SCAN meta-GGA泛函计算的工作流程, 进行简单的参数收敛测试.&lt;br&gt;
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="WIEN2k" scheme="https://github.com/minyez/tags/WIEN2k/"/>
    
      <category term="DFT" scheme="https://github.com/minyez/tags/DFT/"/>
    
      <category term="SCAN" scheme="https://github.com/minyez/tags/SCAN/"/>
    
  </entry>
  
  <entry>
    <title>XmGrace小技巧汇总</title>
    <link href="https://github.com/minyez/2019/07/31/grace-tips/"/>
    <id>https://github.com/minyez/2019/07/31/grace-tips/</id>
    <published>2019-07-31T12:14:19.000Z</published>
    <updated>2019-09-24T14:01:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文收集了一些笔者常用的(Xm)Grace使用的技巧.<a id="more"></a> 下面的操作均可以在<a href="https://sourceforge.net/projects/qtgrace/" target="_blank" rel="noopener">qtgrace</a>下实现.</p><h2 id="数据集变换"><a href="#数据集变换" class="headerlink" title="数据集变换"></a>数据集变换</h2><p>Grace中支持多种数据处理, 从简单的求前后两点的差, 到复杂的函数变换和非线性拟合.</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>XmGrace包含差分功能, 支持三种不同差分方式: 向前差分(Forward), 向后差分(Backword)或者居中差分(centered).</p><p>$$<br>\begin{aligned}<br>\text{forward} &amp;: y’_{i, f} = \frac{y_{i+1}-y_i}{x_{i+1}-x_i}\\<br>\text{backward} &amp;: y’_{i, b} = \frac{y_i-y_{i-1}}{x_i-x_{i-1}}\\<br>\text{centered} &amp;: y’_{i, c} = \frac{y_{i+1}-y_{i-1}}{x_{i+1}-x_{i-1}}\\<br>\end{aligned}<br>$$</p><p>以函数$y=4(x-0.5)^2$为例, 其导数$y’=8x-4$.</p><ol><li><p>选中差分功能: Data-&gt;Tranformation-&gt;Differences</p><p> <figure class="null"><img src="differences_1.jpg" alt="选中XmGrace的差分功能"><figcaption>选中XmGrace的差分功能</figcaption></figure></p></li><li><p>选中一组数据, 确认差分方案</p><p> <figure class="null"><img src="differences_2.jpg" alt="差分功能界面, 向前差分"><figcaption>差分功能界面, 向前差分</figcaption></figure></p></li><li><p>Accept确认.</p></li><li><p>检查差分结果. 需要注意, 这里向前向后差分结果是相同的, 原因是向后差分的横坐标错了. 因此建议使用向前或居中差分.</p><p> <figure class="null"><img src="differences_3.jpg" alt="差分功能界面, 向前差分"><figcaption>差分功能界面, 向前差分</figcaption></figure></p></li></ol><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>用<code>Evaluate expression</code>功能, 可以对数据进行自定义的函数变换. 它可以对单组数据的xy进行操作, 也可以在多组数据间操作, 非常方便. 该功能和Differences一样在Transformations标签里, 具体位置见第一张图.</p><p><figure class="null"><img src="eval_expr_1.jpg" alt="表达式求值, 对数据作变换"><figcaption>表达式求值, 对数据作变换</figcaption></figure></p><ol><li>选中想要操作的数据.</li><li>填写函数变换的表达式.</li><li>勾选Sync. selection, 使变换后的数据直接替换原有数据set. 如果不勾选, Destination下的数据栏中也没有选中任何set, 则变换后的数据会存在新的set中.</li><li>确认.</li></ol><p>这里主要说一下第二条. 在写表达式时, <code>y</code>表示纵坐标, <code>x</code>表示横坐标. 一些常用的变换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 向上平移0.5</span><br><span class="line">y = y + 0.5</span><br><span class="line"># 以第10个数据为零点进行平移</span><br><span class="line">y = y - y[9]</span><br><span class="line"># 求G0.S0和G1.S1之间的差</span><br><span class="line">y = G0.S0.y - G1.S1.y</span><br><span class="line"># 求自然对数</span><br><span class="line">y = ln(y)</span><br><span class="line"># 将横坐标转为角度</span><br><span class="line">x = x * 180 / PI</span><br></pre></td></tr></table></figure><p>更多的函数可以参考官网<a href="http://plasma-gate.weizmann.ac.il/Xmgr/doc/trans.html" target="_blank" rel="noopener">Xmgr: transformations</a></p><h2 id="双y轴-Double-y-axis"><a href="#双y轴-Double-y-axis" class="headerlink" title="双y轴(Double y-axis)"></a>双y轴(Double y-axis)</h2><p>参考这一<a href="sachinashanbhag.blogspot.com/2012/06/grace-tutorial-how-to-plot-graph-with.html">链接</a>, 制作包含两个不同y轴的图, 以在同一张图中展示用有相同横坐标, 但纵坐标范围不同的两组数据.</p><p><figure class="null"><img src="double_y_1.jpg" alt=" "><figcaption> </figcaption></figure></p><ol><li>在窗口个中放置两张并排的图. Edit-&gt;Arrange graphs…</li><li>将cols改为2.</li><li><p>确认.</p><p> <figure class="null"><img src="double_y_2.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>将右图盖到左图上. Edit-&gt;Overlay graphs…</p></li><li>选中G1为要覆盖的图.</li><li>选中G0为被覆盖上的图.</li><li>将Smart axis hint设置为”Same X axis scaling”.</li><li><p>确认. 这个时候两张图覆盖在了一起, 都窝在整个窗口的左侧.</p><p> <figure class="null"><img src="double_y_3.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>调节图的范围. Plot-&gt;Graph appearance. 在Viewpoint设置G0的xmax, 例如1.15.</p></li><li>对G1作同样的操作.</li><li><p>确认.</p><p><figure class="null"><img src="double_y_4.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>为了分辨两个y轴, 用不同的颜色来区分. 双击右侧的y轴</p></li><li>确认在目前正在操作G1.</li><li>正常操作, 调节G1 y轴的属性.</li><li>确认.</li></ol><p>有一点需要注意的是, 当调整y轴粗细比1大的时候, 可能会在某个y轴上看到黑线. 这是图的边框, 可以通过将Graph appearance中Frame标签下Frame box的透明度调到最低来消除.</p><h2 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h2><p>在XmGrace里输入坐标轴标记或者图例时, 有时会需要输入一些希腊字母或上下标之类的复杂组合, 或者使用斜体以表示物理量.</p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>单独的上下标比较容易, 分别<code>a\Sb\N</code>是<code>c\sd\N</code>. 要输入具有上下标的符号, 用<code>a\Sb\N\sc\N</code>会使得下标或上标与符号隔得太远. 此时可以用<code>\v{}</code>或者<code>\h{}</code>分别调整垂直和水平的位置. 比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a\Sb\N\s\v&#123;0.2&#125;\h&#123;-0.5&#125;c\N</span><br></pre></td></tr></table></figure><p><figure class="null"><img src="simult_supsub.png" alt=" "><figcaption> </figcaption></figure></p><h3 id="希腊字母与字体"><a href="#希腊字母与字体" class="headerlink" title="希腊字母与字体"></a>希腊字母与字体</h3><p>希腊字符使用和字体调整本质上是相同的, 因为希腊字母实际上使用的是Symbol字体. 使用某种字体对应的语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;font&#125;text in font\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>比如斜体的Times New Roman</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;Times-Italic&#125;italic here\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>希腊字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;Symbol&#125;G\f&#123;&#125; = \xG\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>\x</code>其实等价于<code>\f{Symbol}</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文收集了一些笔者常用的(Xm)Grace使用的技巧.
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="XmGrace" scheme="https://github.com/minyez/tags/XmGrace/"/>
    
  </entry>
  
  <entry>
    <title>Valgrind笔记(二)——编译器依赖与内存泄漏类型再探</title>
    <link href="https://github.com/minyez/2019/07/05/valgrind-2/"/>
    <id>https://github.com/minyez/2019/07/05/valgrind-2/</id>
    <published>2019-07-05T12:16:09.000Z</published>
    <updated>2019-08-09T06:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>利用Valgrind检测自定义类中内存分配和释放情况. 报告结果依赖于编译器.<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近考虑重构GAP代码, 于是学习了有关Fortran面向对象编程的知识, 接触到了设计模式(Design Pattern)的概念. 其中使用自定义类和用委派关系实现继承是自己之前很少在Fortran中用的, 主要还是面向过程的编程思维. 事实上面向对象的思维也是在研究生后学Python过程中慢慢转过去的. 有关设计模式的学习内容以后有机会再整理上来.</p><p>这篇文章算是记录一点点在Fortran中进行面向对象编程的实践, 主要用的是<a href="main.f90">main.f90</a>和<a href="mytypes.f90">mytypes.f90</a>这两段非常短的代码.</p><ul><li>mytypes.f90包含一个模块, 其中定义了<code>myarrays</code>类, 其数据包含两个可分配数组, 分别是一维整型数组和二维浮点数数组, 并定义了相关constructor和destructor例程.</li><li>main.f90是主程序, 仅调用constructor和destructor方法, 因此原则上没有内存泄漏.</li></ul><p>接下来就是用Valgrind作内存检测, 看一看. 编译用的Makefile在<a href="Makefile">这里</a>, 编译得到的可执行程序是<code>test</code>. 测试平台是Fedora 27.</p><h2 id="依赖编译器的Valgrind报告"><a href="#依赖编译器的Valgrind报告" class="headerlink" title="依赖编译器的Valgrind报告"></a>依赖编译器的Valgrind报告</h2><h3 id="gfortran编译"><a href="#gfortran编译" class="headerlink" title="gfortran编译"></a>gfortran编译</h3><p>使用gfortran (GCC 7.3.1)编译得到的<code>test</code>, Valgrind检测没有报错, 但堆调用中的alloc数为23, 比<code>new_my_array</code>例程中<code>allocate</code>语句(2)要多很多.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full --show-leak-kinds=all ./test</span><br><span class="line">==10854== Memcheck, a memory error detector</span><br><span class="line">==10854== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==10854== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==10854== Command: ./test</span><br><span class="line">==10854==</span><br><span class="line">==10854==</span><br><span class="line">==10854== HEAP SUMMARY:</span><br><span class="line">==10854==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==10854==   total heap usage: 23 allocs, 23 frees, 13,520 bytes allocated</span><br><span class="line">==10854==</span><br><span class="line">==10854== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==10854==</span><br><span class="line">==10854== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==10854== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><h3 id="Intel-Fortran编译"><a href="#Intel-Fortran编译" class="headerlink" title="Intel Fortran编译"></a>Intel Fortran编译</h3><p>用Intel Fortran (2018 update 1)编译, 堆调用中的alloc数为4, 虽然也大于2但比gfortran里的23要小. 此外, Valgrind报告了32 bytes的”still reachable”泄漏, 这一泄漏和该版本Fedora中glibc的<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1624387" target="_blank" rel="noopener">bug</a>有关. 没有报错.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full --show-leak-kinds=all ./test</span><br><span class="line">==13583== Memcheck, a memory error detector</span><br><span class="line">==13583== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==13583== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==13583== Command: ./test</span><br><span class="line">==13583==</span><br><span class="line">==13583==</span><br><span class="line">==13583== HEAP SUMMARY:</span><br><span class="line">==13583==     in use at exit: 32 bytes in 1 blocks</span><br><span class="line">==13583==   total heap usage: 4 allocs, 3 frees, 152 bytes allocated</span><br><span class="line">==13583==</span><br><span class="line">==13583== 32 bytes in 1 blocks are still reachable in loss record 1 of 1</span><br><span class="line">==13583==    at 0x4C2F01A: calloc (vg_replace_malloc.c:752)</span><br><span class="line">==13583==    by 0x5971714: _dlerror_run (in /usr/lib64/libdl-2.26.so)</span><br><span class="line">==13583==    by 0x5971129: dlsym (in /usr/lib64/libdl-2.26.so)</span><br><span class="line">==13583==    by 0x41165E: real_aio_init (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==    by 0x40849B: for__once_private (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==    by 0x4066B4: for_rtl_init_ (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==    by 0x402948: main (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==</span><br><span class="line">==13583== LEAK SUMMARY:</span><br><span class="line">==13583==    definitely lost: 0 bytes in 0 blocks</span><br><span class="line">==13583==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==13583==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==13583==    still reachable: 32 bytes in 1 blocks</span><br><span class="line">==13583==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==13583==</span><br><span class="line">==13583== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==13583== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>接下来做一些小的实验. 如果在主程序中特意省略掉destructor, 会得到104 bytes的”possibly lost”, 同时Error Summary中出现两个错误.<br>比较奇怪的是, 原则上当rank为2时, 2个整型和4个浮点数对应的内存损失为24 bytes.</p><p>进一步实验</p><ul><li>将rank从2增加到4, 损失增加到160 bytes. 原则上应该是80 (4整型, 16浮点数).</li><li>增加另一个<code>myarrays</code>对象, 损失增加到208 bytes.</li><li>修改destructor方法<code>destroy_my_array</code>, 跳过二维数组<code>rarr2d</code>的deallocate, 在主程序中调用destructor. 此时内存损失为56 (rank=2)和104 (rank 4) bytes.</li></ul><p>这表明有80 bytes好像被”附着”在每个自定义类的对象上. 更具体的, 每个可分配数组”附着”了40 bytes的内存.</p><h3 id="回看gfortran"><a href="#回看gfortran" class="headerlink" title="回看gfortran"></a>回看gfortran</h3><p>现在回到gfortran编译上, 也是有意地去掉destructor, 看看Valgrind如何响应.</p><p>当rank=2时, Valgrind报告了24 bytes的”still reachable”泄漏, 没有报错. 这个泄漏量和根据数据类型预计的量是一样的, 与此同时Valgrind类认为这一内存泄漏是不构成关键的性能问题.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full --show-leak-kinds=all ./test</span><br><span class="line">==16808== Memcheck, a memory error detector</span><br><span class="line">==16808== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==16808== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==16808== Command: ./test</span><br><span class="line">==16808==</span><br><span class="line">==16808==</span><br><span class="line">==16808== HEAP SUMMARY:</span><br><span class="line">==16808==     in use at exit: 24 bytes in 2 blocks</span><br><span class="line">==16808==   total heap usage: 23 allocs, 21 frees, 13,520 bytes allocated</span><br><span class="line">==16808==</span><br><span class="line">==16808== 8 bytes in 1 blocks are still reachable in loss record 1 of 2</span><br><span class="line">==16808==    at 0x4C2CDCB: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==16808==    by 0x400F25: __mytypes_MOD_new_my_array (mytypes.f90:17)</span><br><span class="line">==16808==    by 0x40116C: MAIN__ (main.f90:8)</span><br><span class="line">==16808==    by 0x4011AF: main (main.f90:3)</span><br><span class="line">==16808==</span><br><span class="line">==16808== 16 bytes in 1 blocks are still reachable in loss record 2 of 2</span><br><span class="line">==16808==    at 0x4C2CDCB: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==16808==    by 0x4010C1: __mytypes_MOD_new_my_array (mytypes.f90:20)</span><br><span class="line">==16808==    by 0x40116C: MAIN__ (main.f90:8)</span><br><span class="line">==16808==    by 0x4011AF: main (main.f90:3)</span><br><span class="line">==16808==</span><br><span class="line">==16808== LEAK SUMMARY:</span><br><span class="line">==16808==    definitely lost: 0 bytes in 0 blocks</span><br><span class="line">==16808==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==16808==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==16808==    still reachable: 24 bytes in 2 blocks</span><br><span class="line">==16808==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==16808==</span><br><span class="line">==16808== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==16808== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><h2 id="“内存泄漏”再探"><a href="#“内存泄漏”再探" class="headerlink" title="“内存泄漏”再探"></a>“内存泄漏”再探</h2><p>在检索上面still reachable leak问题的时候, 发现了SO上关于的一个<a href="https://stackoverflow.com/a/3857638" target="_blank" rel="noopener">回答</a></p><blockquote><p>There is more than one way to define “memory leak”. In particular, there are two primary definitions of “memory leak” that are in common usage among programmers.</p><p>The first commonly used definition of “memory leak” is, “Memory was allocated and was not subsequently freed before the program terminated.” However, many programmers (rightly) argue that certain types of memory leaks that fit this definition don’t actually pose any sort of problem, and therefore should not be considered true “memory leaks”.</p><p>An arguably stricter (and more useful) definition of “memory leak” is, “Memory was allocated and cannot be subsequently freed because the program no longer has any pointers to the allocated memory block.” In other words, you cannot free memory that you no longer have any pointers to. Such memory is therefore a “memory leak”. Valgrind uses this stricter definition of the term “memory leak”. This is the type of leak which can potentially cause significant heap depletion, especially for long lived processes.</p><p>The “still reachable” category within Valgrind’s leak report refers to allocations that fit only the first definition of “memory leak”. These blocks were not freed, but they could have been freed (if the programmer had wanted to) because the program still was keeping track of pointers to those memory blocks.</p><p>In general, there is no need to worry about “still reachable” blocks. They don’t pose the sort of problem that true memory leaks can cause. For instance, there is normally no potential for heap exhaustion from “still reachable” blocks. This is because these blocks are usually one-time allocations, references to which are kept throughout the duration of the process’s lifetime. While you could go through and ensure that your program frees all allocated memory, there is usually no practical benefit from doing so since the operating system will reclaim all of the process’s memory after the process terminates, anyway. Contrast this with true memory leaks which, if left unfixed, could cause a process to run out of memory if left running long enough, or will simply cause a process to consume far more memory than is necessary.</p></blockquote><p>翻译如下</p><blockquote><p>定义”内存泄漏”的方式不止一种. 特别的, 在程序员间常用的主要有两种”内存泄漏”的定义.</p><p>第一种常用的定义是, “内存被分配, 随后没有在程序结束前被释放”. 但是, 很多程序员(正确地)主张说符合这一定义的内存泄漏并不会造成问题, 因此并不被认为是真正的内存泄漏.</p><p>“内存泄漏”的一种可能更为严格(也更有用)的定义是, “内存被分配后, 由于程序失去了指向被分配内存块的指针而无法被释放”. 换句话说, 你无法释放没有指针指向的内存. 所以这样的内存属于”内存泄漏”. Valgrind用的是这一更为严格的定义. 这类泄漏可能产生严重的堆损耗, 特别是在长期活动的进程中.</p><p>Valgrind的泄漏报告中”still reachable”分类指的是只满足第一类定义的内存分配. 这些内存块没有被释放, 但他们是可以被释放的(只要程序员愿意), 因为程序仍然保有指向这些内存块的指针.</p><p>一般而言, 不必担心”still reachable”的内存块. 他们不会带来真正的内存泄漏会导致的问题. 比如说, “still reachable”的内存块通常不会导致堆耗尽. 这是因为这些块都是单次分配, 程序在整个生命周期中都保留对他们的指向. 你当然可以梳理整个程序, 保证这些内存块都被释放, 但这实际并没什么好处, 因为操作系统会在进程结束后回收进程的全部内存. 与之相对, 如果真正的内存泄漏没有被修正, 那么就会导致一个进程在运行足够长时间后耗尽所有内存, 或者说消耗比它所必需的多得多的内存.</p></blockquote><p>这是对之前<a href="/2019/03/23/valgrind-1/" title="Valgrind笔记(一)——Memcheck初探">Valgrind笔记(一)——Memcheck初探</a>一文最后的泄漏类型梳理的重要补充. 答主非常细心的区分了两种内存泄漏的类型. 我们重新来看当时的abc程序</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> abc</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">allocatable</span> :: <span class="keyword">data</span>(:)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">allocate</span>(<span class="keyword">data</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>*, rank(<span class="keyword">data</span>), <span class="built_in">size</span>(<span class="keyword">data</span>), loc(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, <span class="number">5</span></span><br><span class="line">        <span class="keyword">data</span>(i-<span class="number">1</span>) = i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>*, <span class="keyword">data</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>*, rank(<span class="keyword">data</span>), <span class="built_in">size</span>(<span class="keyword">data</span>), loc(<span class="keyword">data</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> abc</span><br></pre></td></tr></table></figure><p>并将<code>data</code>越界赋值语句注释. 用gfortran编译会得到20 bytes的definite loss. 如果用ifort, 则会得到60 bytes的possibly lost. 令人摸不着头脑的是, 如果把这一段代码放到main.f90中, 注释掉原来的myarrays的部分, 同样用gfortran编译, 得到的是20 bytes的still reachable leak. ifort仍给出60 bytes的possibly lost.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上非常直接的例子里可以得到的两个结论, 首先是do not oversmart your compiler. 跟人类语言互译一样, 不同编译器可能将一段高级语言翻译成风格不同的机器码, 这可能就是导致Valgrind检测结果不同的原因. 其次, 也是很自然的, 既然编译器存在这样的不确定性, 那么编程人员就应该写好内存分配和释放的语句, 从源头减少这样的不确定性.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;利用Valgrind检测自定义类中内存分配和释放情况. 报告结果依赖于编译器.&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://github.com/minyez/categories/Programming/"/>
    
    
      <category term="Compilation" scheme="https://github.com/minyez/tags/Compilation/"/>
    
      <category term="Valgrind" scheme="https://github.com/minyez/tags/Valgrind/"/>
    
      <category term="Fortran" scheme="https://github.com/minyez/tags/Fortran/"/>
    
  </entry>
  
  <entry>
    <title>GPAW笔记(四)——GW计算</title>
    <link href="https://github.com/minyez/2019/06/28/gpaw-4-gw/"/>
    <id>https://github.com/minyez/2019/06/28/gpaw-4-gw/</id>
    <published>2019-06-28T01:30:46.000Z</published>
    <updated>2019-08-09T06:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将简单介绍GPAW中的进行准粒子计算的<code>G0W0</code>类, 并使用<code>GWBands</code>类制作单层二硫化钼的能带结构图.<a id="more"></a></p><p>无论是否自洽, GW计算都需要一组单粒子态作为输入, 这组单粒子态中需要包含大量的非占据态. 目前主流是采用Kohn-Sham DFT产生的Kohn-Sham本征态. 这里主要介绍非自洽计算情形, 此时GW结果受到输入影响.</p><p>为了得到包含较多非占据态的本征态一般有两种方法. 第一种是在基态计算中包含大量的非占据态, 这种情况电子步迭代效率低. 第二种是首先在较少非占据态下得到收敛的电子密度(电子密度只与占据态有关), 然后在固定电子密度下对角化Kohn-Sham单电子Hamiltonian. 对于局域和半局域泛函, 当电子密度固定时, 久期行列式就完全确定了, 一步即可得到等于基组数量的非占据态. 对于非局域泛函, 也只需要几步以收敛非局域势算符.</p><p>这里用的例子是单层二硫化钼. 首先用ASE构造二硫化钼模型. 晶格常数相比实验上体相稳定结构略有拉伸.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> mx2</span><br><span class="line">mos2 = mx2(formula=<span class="string">'MoS2'</span>, kind=<span class="string">'2H'</span>, a=<span class="number">3.19</span>, thickness=<span class="number">3.127</span>, size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), vacuum=<span class="number">5.0</span>)</span><br></pre></td></tr></table></figure><h2 id="基态计算与对角化"><a href="#基态计算与对角化" class="headerlink" title="基态计算与对角化"></a>基态计算与对角化</h2><p>关于基态和对角化计算已经在<a href="/2019/06/18/gpaw-2-scf-bs/" title="GPAW笔记(二)——DFT自洽场与能带计算">GPAW笔记(二)——DFT自洽场与能带计算</a>和<a href="/2019/06/19/gpaw-3-diag-gs/" title="GPAW笔记(三)——求解器对全哈密顿量对角化的影响">GPAW笔记(三)——求解器对全哈密顿量对角化的影响</a>中提及. 这里用了一个比较小的平面波截断以减小计算量. 而k值设的比较大. 若k太小, 后面用<code>GWBands</code>作能带插值时VBM和CBM位置会出错.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gpaw <span class="keyword">import</span> GPAW, PW, FermiDirac</span><br><span class="line"></span><br><span class="line">Ecut = <span class="number">300</span></span><br><span class="line">kx = <span class="number">18</span></span><br><span class="line">calc = GPAW(mode=PW(Ecut), xc=<span class="string">'PBE'</span>,</span><br><span class="line">            convergence=&#123;<span class="string">"density"</span>: <span class="number">1e-8</span>&#125;,</span><br><span class="line">            kpts=&#123;<span class="string">'size'</span>: (kx, kx, <span class="number">1</span>), <span class="string">'gamma'</span>: <span class="keyword">True</span>&#125;,</span><br><span class="line">            occupations=FermiDirac(<span class="number">0.001</span>), parallel=&#123;<span class="string">'domain'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">            txt=<span class="string">'gs.txt'</span>)</span><br><span class="line">mos2.set_calculator(calc)</span><br><span class="line"><span class="comment"># 基态SCF</span></span><br><span class="line">mos2.get_potential_energy()</span><br><span class="line">calc.write(<span class="string">'gs.gpw'</span>)</span><br><span class="line"><span class="comment"># 对角化哈密顿量, 将波函数和能量写入文件, 以供GW读取</span></span><br><span class="line">calc.diagonalize_full_hamiltonian()</span><br><span class="line">calc.write(<span class="string">'fulldiag.gpw'</span>, <span class="string">'all'</span>)</span><br></pre></td></tr></table></figure><h2 id="GW计算"><a href="#GW计算" class="headerlink" title="GW计算"></a>GW计算</h2><p>这里用包含4s4p的Mo PAW setup, 因此体系共有14+6+6=26个价电子, 在自旋非极化下有13个占据态, 因此价带顶的指标是12. 现在计算其前5个价带和导带.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gpaw.response.g0w0 <span class="keyword">import</span> G0W0</span><br><span class="line"></span><br><span class="line">diagfile = <span class="string">'fulldiag.gpw'</span></span><br><span class="line">ecut = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">gw = G0W0(calc=diagfile, bands=(<span class="number">8</span>, <span class="number">18</span>), <span class="comment"># VB at index 12</span></span><br><span class="line">          method=<span class="string">"G0W0"</span>, ecut=<span class="number">50</span>, nblocksmax=<span class="keyword">True</span>,</span><br><span class="line">          truncation=<span class="string">'2D'</span>, q0_correction=<span class="keyword">True</span>,</span><br><span class="line">          domega0=<span class="number">0.03</span>, omega2=<span class="number">10</span>,</span><br><span class="line">          filename=<span class="string">'g0w0'</span>, savepckl=<span class="keyword">True</span>)</span><br><span class="line">gw.calculate()</span><br></pre></td></tr></table></figure><p>其中<code>nblocksmax</code>设为True时GPAW将最大化响应函数<code>chi0</code>的分块, 减小每个进程的内存消耗. 8进程测试的内存占用和GW总用时结果如下表, 开启<code>nblocksmax</code>后预测的单进程内存消耗减小, 但是计算消耗时间更长.</p><table><thead><tr><th style="text-align:left"><code>nlocksmax</code></th><th style="text-align:center">Estimate Mem. per proc. (MB)</th><th style="text-align:center">wall time (s)</th></tr></thead><tbody><tr><td style="text-align:left">True</td><td style="text-align:center">30</td><td style="text-align:center">1923</td></tr><tr><td style="text-align:left">False</td><td style="text-align:center">233</td><td style="text-align:center">1429</td></tr></tbody></table><p><code>truncation</code>和<code>q0_correction</code>是针对低维体系的参数, 前者加快对于真空层厚度的收敛, 后者则是加快对面内布里渊区采样格点的收敛. 具体可以参考文献1和3.</p><p>参数<code>domega0</code>和<code>omega2</code>与频率积分有关. <code>domega0</code>决定第一个频率点的位置, <code>omega2</code>决定在何处倍增格点间距. 一般来说带隙越小, <code>domega0</code>就要取得越小以对低频响应采样充分.  显然的, <code>domega0</code>越小, <code>omega2</code>越大, 频率格点数越多, 计算量越大. 目前这个设置可以使K点带隙收敛到2 meV以内.</p><h2 id="作能带图"><a href="#作能带图" class="headerlink" title="作能带图"></a>作能带图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> gpaw.response.gw_bands <span class="keyword">import</span> GWBands</span><br><span class="line"></span><br><span class="line">calcfile = <span class="string">'fulldiag.gpw'</span></span><br><span class="line">gwpckl = <span class="string">'g0w0_results.pckl'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置K点路径</span></span><br><span class="line">K = np.array([<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>])</span><br><span class="line">M = np.array([<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0</span>])</span><br><span class="line">G = np.array([<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">kpoints = np.array([G, K/<span class="number">2</span>, K, M, G])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化GWBands对象. bandrange要和G0W0设置一致, 不过这里第二个指标是要包含进去的</span></span><br><span class="line">GW = GWBands(calcfile=calcfile, gwpckl=gwpckl, kpoints=kpoints, bandrange=(<span class="number">8</span>,<span class="number">17</span>))</span><br><span class="line"><span class="comment"># 设置</span></span><br><span class="line">gwbopts=&#123;<span class="string">"nk_Int"</span>: <span class="number">100</span>, <span class="string">"interpolate"</span>: <span class="keyword">True</span>, <span class="string">"vac"</span>: <span class="keyword">False</span>&#125;</span><br><span class="line"><span class="comment"># 提取PBE, GW和GW-SOC能带插值数据</span></span><br><span class="line">pbe = GW.get_gw_bands(SO=<span class="keyword">False</span>, dft=<span class="keyword">True</span>, **gwbopts)</span><br><span class="line">gw = GW.get_gw_bands(SO=<span class="keyword">False</span>, **gwbopts)</span><br><span class="line">gwsoc = GW.get_gw_bands(SO=<span class="keyword">True</span>, **gwbopts)</span><br><span class="line"><span class="comment"># 提取K点路径的一维坐标</span></span><br><span class="line">x_x = gw[<span class="string">'x_k'</span>]</span><br><span class="line">X = gw[<span class="string">'X'</span>]/x_x[<span class="number">-1</span>]</span><br><span class="line">x_x /= x_x[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 对齐VBM</span></span><br><span class="line">ePBE_kn, eGW_kn, eGWsoc_kn = [d[<span class="string">'e_kn'</span>] - d[<span class="string">'vbm'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> [pbe, gw, gwsoc]]</span><br><span class="line"><span class="comment"># 作不同方法得到的能带</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">styles = [</span><br><span class="line">          &#123;<span class="string">'ls'</span>: <span class="string">'-.'</span>, <span class="string">'marker'</span>: <span class="string">''</span>, <span class="string">'color'</span>: <span class="string">'k'</span>, <span class="string">"lw"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">          &#123;<span class="string">'ls'</span>: <span class="string">'--'</span>, <span class="string">'marker'</span>: <span class="string">''</span>, <span class="string">'color'</span>: <span class="string">'#393b79'</span>, <span class="string">"lw"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">          &#123;<span class="string">'ls'</span>: <span class="string">'-'</span>, <span class="string">'marker'</span>: <span class="string">''</span>, <span class="string">'color'</span>: <span class="string">'#d62728'</span>, <span class="string">"lw"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">         ]</span><br><span class="line"><span class="keyword">for</span> i, bands <span class="keyword">in</span> enumerate([ePBE_kn, eGW_kn, eGWsoc_kn]):</span><br><span class="line">    ax.plot(x_x, bands, **styles[i])</span><br><span class="line"><span class="comment"># 能量零点</span></span><br><span class="line">ax.axhline(<span class="number">0.0</span>, color=<span class="string">'k'</span>, linestyle=<span class="string">':'</span>, lw=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 图例</span></span><br><span class="line">leg_handles = [mpl.lines.Line2D([], [], **style) <span class="keyword">for</span> style <span class="keyword">in</span> styles]</span><br><span class="line">leg_labels = [<span class="string">r'PBE'</span>, <span class="string">r'G$_0$W$_0$'</span>, <span class="string">r'G$_0$W$_0$-SOC'</span>]</span><br><span class="line">ax.legend(leg_handles, leg_labels, fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">0</span>, x_x[<span class="number">-1</span>])</span><br><span class="line">ax.set_ylim([<span class="number">-2</span>, <span class="number">4</span>])</span><br><span class="line">ax.set_ylabel(<span class="string">'Energy (eV)'</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"><span class="comment"># 横坐标特殊k点, 并作分割线</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> X[:<span class="number">-1</span>]:</span><br><span class="line">    plt.axvline(p, color=<span class="string">'#AAAAAA'</span>, ls=<span class="string">'--'</span>, lw=<span class="number">2</span>)</span><br><span class="line">labels_K = [<span class="string">r'$\Gamma$'</span>, <span class="string">r'$T$'</span>, <span class="string">r'$K$'</span>, <span class="string">r'$M$'</span>, <span class="string">r'$\Gamma$'</span>]</span><br><span class="line">plt.xticks(X, labels_K, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">plt.yticks(fontsize=<span class="number">17</span>)</span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'MoS2_band_GTKMG.png'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下图. 可以很容易看到, 在不包含SOC情况下, PBE预测单层MoS2具有$\Gamma-K$的间接带隙, 而GW给出的是K上的直接带隙. 包含SOC会导致K点能带裂分, 在GW下进一步增大$\Gamma$点和K点VBM的能差.</p><p><figure class="null"><img src="MoS2_band_GTKMG.png" alt="PBE, GW方法得到的MoS2能带"><figcaption>PBE, GW方法得到的MoS2能带</figcaption></figure></p><p>另外值得注意的一点是CB在$\Gamma-K$上也有一个能量较低的态(在T=0.5K附近). 在DFT下$T_c$与$K_c$能量差肉眼可见, 而在GW尤其是包含SOC下, 这两个态基本是简并的. 考虑到对未占据态的自能修正为正值, 这说明$K_c$的自能修正要大于$T_c$. 定性分析上, $T_c$主要是Mo的$d_{x^2-y^2}$和$d_{xy}$在面内成键, 而$K_c$是Mo的$d_{z^2}$.(文献2) 后者较为定域, 从GW修正DFT离域误差的角度可定性理解.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>Ismail-Beigi, S. <em>Phys. Rev. B</em> <strong>73</strong>, 233103 (2006)</li><li>Zhang, L.; Zunger, A. <em>Nano Lett.</em> <strong>15</strong>, 949-957 (2015)</li><li>Rasmussen, F. et al. <em>Phys. Rev. B</em> <strong>94</strong>, 155406 (2016)</li><li><a href="https://wiki.fysik.dtu.dk/gpaw/tutorials/gw_tutorial/gw_tutorial.html#quasi-particle-spectrum-of-two-dimensional-materials" target="_blank" rel="noopener">Quasi-particle spectrum of two-dimensional materials - GPAW tutorial</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文将简单介绍GPAW中的进行准粒子计算的&lt;code&gt;G0W0&lt;/code&gt;类, 并使用&lt;code&gt;GWBands&lt;/code&gt;类制作单层二硫化钼的能带结构图.
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="GPAW" scheme="https://github.com/minyez/tags/GPAW/"/>
    
      <category term="GW" scheme="https://github.com/minyez/tags/GW/"/>
    
  </entry>
  
  <entry>
    <title>GPAW笔记(三)——求解器对全哈密顿量对角化的影响</title>
    <link href="https://github.com/minyez/2019/06/19/gpaw-3-diag-gs/"/>
    <id>https://github.com/minyez/2019/06/19/gpaw-3-diag-gs/</id>
    <published>2019-06-19T12:43:08.000Z</published>
    <updated>2019-08-09T06:12:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文比较了GPAW中不同求解器和不同密度收敛条件下对角化哈密顿量得到的本征值. 结果显示, 为了在较大的平面波截断下全对角化得到正确的Kohn-Sham能级, SCF需要使用CG求解器, 并取较严格的密度收敛标准. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>GW, RPA和BSE等多体微扰计算需要大量的未占据态, 因此在进行这些计算前通常需要对当前基组下构造的哈密顿量进行全对角化以得到所有本征对. 在GPAW中, 这一步为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPAW.diagonalize_full_hamiltonian(nbands=<span class="keyword">None</span>, ecut=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p><code>nbands</code>和<code>ecut</code>都设为None时对角化得到的能带数量由平面波截断决定. GPAW这一方法继承自<code>gpaw.paw.PAW</code>, 实际执行对角化命令的是其中的<code>PWWaveFunctions</code>对象.</p><p>问题出现在用600 eV截断的平面波基组计算单层MoS2的GW时. 在默认能带数的PBE基态计算下, GPAW给出MoS2能谱对应于半导体, 费米能级约为-1 eV, 但对角化后的能谱对应的却是一个金属, 费米能级在-200 eV左右. 我想这种情况可能跟对角化的算法和基态收敛情况有关, 于是进行了下面的简单测试.</p><p>测试的GPAW版本是1.5.2, Python为采用Anaconda3/2019.3发行版. C扩展用Intel 2019编译, 数学库为MKL. 使用<code>mx2</code>函数构造MoS2模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> mx2</span><br><span class="line"><span class="keyword">from</span> gpaw <span class="keyword">import</span> GPAW, PW, FermiDirac</span><br><span class="line"></span><br><span class="line">mos2 = mx2(formula=<span class="string">'MoS2'</span>, kind=<span class="string">'2H'</span>, a=<span class="number">3.184</span>, thickness=<span class="number">3.127</span>,</span><br><span class="line">           size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), vacuum=<span class="number">10</span>)</span><br><span class="line">mos2.pbc = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="比较不同求解器"><a href="#比较不同求解器" class="headerlink" title="比较不同求解器"></a>比较不同求解器</h2><p>GPAW提供了五种求解器, CG, Davidson, RMM-DIIS, DirectLCAO, DirectPW. 这里主要讨论前三种. 简单测试DirectPW发现, 它计算的MoS2的$\Gamma$点带隙为1.7 eV, 要小于其他求解器和VASP的计算值2.7 eV. 初始化时求解器参数均使用GPAW的默认设置.</p><p>测试命令如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ecut_kx_pairs = [(<span class="number">300</span>, <span class="number">6</span>), (<span class="number">300</span>, <span class="number">9</span>), (<span class="number">400</span>, <span class="number">12</span>), (<span class="number">400</span>, <span class="number">18</span>), (<span class="number">600</span>, <span class="number">6</span>), (<span class="number">600</span>, <span class="number">18</span>)]</span><br><span class="line">egs = [<span class="string">"cg"</span>, <span class="string">"dav"</span>, <span class="string">"rmm-diis"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Ecut, kx <span class="keyword">in</span> Ecut_kx_pairs:</span><br><span class="line">    <span class="keyword">for</span> eg <span class="keyword">in</span> egs:</span><br><span class="line">        suffix = <span class="string">f"Ecut_<span class="subst">&#123;Ecut&#125;</span>_kx_<span class="subst">&#123;kx&#125;</span>_<span class="subst">&#123;es&#125;</span>"</span></span><br><span class="line">        calc = GPAW(mode=PW(Ecut), xc=<span class="string">"PBE"</span>, eigensolver=es</span><br><span class="line">                    kpts=&#123;<span class="string">'size'</span>: (kx, kx, <span class="number">1</span>), <span class="string">'gamma'</span>: <span class="keyword">True</span>&#125;,</span><br><span class="line">                    occupations=FermiDirac(<span class="number">0.01</span>), parallel=&#123;<span class="string">'domain'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                    txt=<span class="string">f'MoS2_gs_<span class="subst">&#123;suffix&#125;</span>.txt'</span>)</span><br><span class="line">        mos2.set_calculator(calc)</span><br><span class="line">        mos2.get_potential_energy()</span><br><span class="line">        calc.write(<span class="string">f'MoS2_gs_<span class="subst">&#123;suffix&#125;</span>.gpw'</span>)</span><br><span class="line">        calc.diagonalize_full_hamiltonian()</span><br><span class="line">        calc.write(<span class="string">f'MoS2_fulldiag_<span class="subst">&#123;suffix&#125;</span>.gpw'</span>)</span><br></pre></td></tr></table></figure><p>CG使用4核并行, Davidson和RMM-DIIS使用16核并行. 测试结果如下表, 后三列中的值是分别用对角化和基态迭代计算得到的前20个能级的本征能量差, 定义为</p><p>$$<br>\Delta_{20} \equiv \sum_k\sum^{n&lt;20}_{n=0}{|\epsilon^{diag}_{nk}-\epsilon^{gs}_{nk}|}.<br>$$</p><p>第三列是对角化得到的能带总数. 当取平面波截断到600 eV时, 使用Davidson和RMM-DIIS时的本征能量差非常大. 10次方误差来源是指标为0的能带的能量.</p><table><thead><tr><th style="text-align:left">Ecut</th><th style="text-align:left">kx</th><th style="text-align:left">$N_{pw}$</th><th style="text-align:center">CG</th><th style="text-align:center">Dav</th><th style="text-align:center">RMM-DIIS</th></tr></thead><tbody><tr><td style="text-align:left">300</td><td style="text-align:left">6</td><td style="text-align:left">2368</td><td style="text-align:center">8.2E-01</td><td style="text-align:center">2.6E+00</td><td style="text-align:center">1.6E+01</td></tr><tr><td style="text-align:left">300</td><td style="text-align:left">9</td><td style="text-align:left">2368</td><td style="text-align:center">8.2E-01</td><td style="text-align:center">1.0E+00</td><td style="text-align:center">1.9E+01</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">12</td><td style="text-align:left">3655</td><td style="text-align:center">2.7E-01</td><td style="text-align:center">1.6E+00</td><td style="text-align:center">2.5E+01</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">18</td><td style="text-align:left">3655</td><td style="text-align:center">4.5E-02</td><td style="text-align:center">2.0E+00</td><td style="text-align:center">5.2E+01</td></tr><tr><td style="text-align:left">600</td><td style="text-align:left">6</td><td style="text-align:left">6666</td><td style="text-align:center">4.7E+00</td><td style="text-align:center">5.6E+09</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">600</td><td style="text-align:left">18</td><td style="text-align:left">6666</td><td style="text-align:center">3.5E+00</td><td style="text-align:center">6.2E+10</td><td style="text-align:center">6.2E+10</td></tr></tbody></table><p>下图是设置三种不同的求解器时, 在600 eV截断下全对角化得到的所有k点上的本征值谱, 横坐标是能带指标. 当GPAW采用Davidson和RMM-DIIS时, 全对角化后部分k点上的能量系统偏低200 eV. 使用CG时怎没有这样的问题.</p><p><figure class="null"><img src="diag_eigensolver.png" alt="600 eV平面波截断时对角化所得本征值"><figcaption>600 eV平面波截断时对角化所得本征值</figcaption></figure></p><p>这里基本可以得到结论, 当需要在较大基组下对角化哈密顿量时, 基态计算采用CG求解器是比较保险的做法. 这里有一个了令人疑惑的地方是, 源码中<code>PWWaveFunctions</code>对象的对角化方法利用的是C扩展中的Scalapack功能, 与求解器应该没有直接的联系, 但结果看来求解器确实会影响对角化结果.</p><h2 id="CG下比较不同密度收敛限"><a href="#CG下比较不同密度收敛限" class="headerlink" title="CG下比较不同密度收敛限"></a>CG下比较不同密度收敛限</h2><p>下面测试密度收敛限对对角化所得的本征值的影响. 这里Ecut仍然取较大的600 eV, 求解器使用CG. 通过改变GPAW初始化时的<code>convergence</code>参数, 调整密度收敛限, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calc = GPAW(mode=PW(Ecut), xc=<span class="string">"PBE"</span>, eigensolver=es,</span><br><span class="line">            convergence=&#123;<span class="string">'density'</span>: <span class="number">1E-6</span>&#125;)</span><br></pre></td></tr></table></figure><p>测试结果如下表. 可以看出, 采用1E-08作为SCF收敛限时, 本征值收敛到非常小的阈值内, 同时SCF和对角化得到的低能能态在能量上完全一致. 另外, 如果不用CG而仍然用Davidson或者RMM-DIIS, 增大密度收敛限$\Delta_{20}$相比上一节没有改善.</p><table><thead><tr><th style="text-align:left">kx</th><th style="text-align:left">Convergence (Log10)</th><th style="text-align:center">$\sum_{nk}{\epsilon_{nk}}$ (w.r.t default)</th><th style="text-align:center">$\Delta_{20}$</th></tr></thead><tbody><tr><td style="text-align:left">6</td><td style="text-align:left">-4.61 (default)</td><td style="text-align:center">0</td><td style="text-align:center">4.7E+00</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">-6</td><td style="text-align:center">4.9383</td><td style="text-align:center">2.7E-04</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">-8</td><td style="text-align:center">5.0000</td><td style="text-align:center">4.0E-09</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">-4.61 (default)</td><td style="text-align:center">0</td><td style="text-align:center">3.5E+00</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">-6</td><td style="text-align:center">9.4296</td><td style="text-align:center">1.5E-06</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">-8</td><td style="text-align:center">10.018</td><td style="text-align:center">1.5E-08</td></tr></tbody></table><!-- 它们在VASP里也有IALGO和ALGO的相似对应, 分别是58 (Conjugate, All), 38 (Normal)和48 (Very_fast). -->]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文比较了GPAW中不同求解器和不同密度收敛条件下对角化哈密顿量得到的本征值. 结果显示, 为了在较大的平面波截断下全对角化得到正确的Kohn-Sham能级, SCF需要使用CG求解器, 并取较严格的密度收敛标准.
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="DFT" scheme="https://github.com/minyez/tags/DFT/"/>
    
      <category term="GPAW" scheme="https://github.com/minyez/tags/GPAW/"/>
    
      <category term="Band structure" scheme="https://github.com/minyez/tags/Band-structure/"/>
    
  </entry>
  
  <entry>
    <title>GPAW笔记(二)——DFT自洽场与能带计算</title>
    <link href="https://github.com/minyez/2019/06/18/gpaw-2-scf-bs/"/>
    <id>https://github.com/minyez/2019/06/18/gpaw-2-scf-bs/</id>
    <published>2019-06-18T08:54:14.000Z</published>
    <updated>2019-08-09T06:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>以金刚石结构Si为例, 演示了用GPAW计算材料电子能带结构的过程, 对结果进行了简单分析.<a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一年前我在<a href="/2018/07/20/gpaw-1/" title="GPAW笔记(一)——安装及测试">GPAW笔记(一)——安装及测试</a>一文中介绍了GPAW的安装和简单测试. 当时主要是为了比较GPAW, abinit和VASP的<em>GW</em>效率, 于是稍微研究了一下GPAW中参数含义, 运行了一些官方网站上的脚本. 在相近的参数下作了三个程序的<em>GW</em>计算交差后, 就没有再管, 当时也没有留下清楚的学习笔记.</p><p>由于最近实际计算的需要, 我又重新学习GPAW, 着重于DFT能带计算, <em>GW</em>和BSE. 这一篇笔记主要记录了基础DFT计算部分的学习, 包括SCF和能带, 简单分析标准输出. 这里使用的结构是金刚石型的硅, 晶格常数$a=5.43$ (A).</p><h2 id="SCF计算"><a href="#SCF计算" class="headerlink" title="SCF计算"></a>SCF计算</h2><p>从官网例子中改编得的一个SCF计算脚本如下.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> bulk</span><br><span class="line"><span class="keyword">from</span> gpaw <span class="keyword">import</span> GPAW, PW, FermiDirac</span><br><span class="line"></span><br><span class="line">si = bulk(<span class="string">'Si'</span>, <span class="string">'diamond'</span>, a=<span class="number">5.43</span>)</span><br><span class="line">calc = GPAW(mode=PW(<span class="number">200</span>), xc=<span class="string">'PBE'</span>, kpts=&#123;<span class="string">'size'</span>: (<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>), <span class="string">'gamma'</span>: <span class="keyword">True</span>&#125;,</span><br><span class="line">            random=<span class="keyword">True</span>, occupations=FermiDirac(<span class="number">0.01</span>), txt=<span class="string">'Si_gs.txt'</span>)</span><br><span class="line">si.calc = calc</span><br><span class="line">si.get_potential_energy()</span><br><span class="line">calc.write(<span class="string">'Si_gs.gpw'</span>)</span><br></pre></td></tr></table></figure><p>对每行的说明:</p><ul><li>行4: 用<code>bulk</code>方法构造Si模型</li><li>行5-6: 初始化GPAW. 使用平面波基组(截断为200 eV). 泛函为PBE. 布里渊区采样为$\Gamma$中心$8\times8\times8$的均匀格点. 初始波函数随机生成. 占据数计算采用Fermi-Dirac分布, . <code>txt</code>选项指定输出文件.</li><li>行7: 将Si模型的calculator指定为刚刚初始化好的GPAW.</li><li>行8: 开始SCF过程. 具体来说, <code>Atoms.get_potential_energy</code>方法用于获取<code>Atoms._calc</code>的energy属性, 操作上是从<code>Calculator.results</code>字典中提取energy键值. 对于未收敛的GPAW calculator, energy键不存在, 此时会执行<code>GPAW.calculate</code>进行SCF循环, 直到收敛, 添加energy键并返回之.</li><li>行9: 将计算过程的所有信息写入Si_gs.gpw文件中.</li></ul><h2 id="标准输出分析"><a href="#标准输出分析" class="headerlink" title="标准输出分析"></a>标准输出分析</h2><p>标准输出保存在Si_gs.txt中. 主要看三部分. 在200行附近给出SCF迭代的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                     log10-error:    total        iterations:</span><br><span class="line">           time      wfs    density  energy       fermi  poisson</span><br><span class="line">iter:   1  14:49:29  +1.03   +inf   -10.866303    7</span><br><span class="line">iter:   2  14:49:30  -1.97  -0.80   -10.866989    2</span><br><span class="line">iter:   3  14:49:30  -1.01  -0.81   -11.320728    22</span><br><span class="line">iter:   4  14:49:31  -1.94  -0.56   -10.847586    3</span><br><span class="line">iter:   5  14:49:31  -2.71  -1.11   -10.806417    8</span><br><span class="line">iter:   6  14:49:31  -2.69  -1.35   -10.780669    9</span><br><span class="line">iter:   7  14:49:32  -3.97  -2.59   -10.780801    0</span><br><span class="line">iter:   8  14:49:32  -5.11  -2.71   -10.780798    0</span><br><span class="line">iter:   9  14:49:33  -5.83  -2.71   -10.780763    0</span><br><span class="line">iter:  10  14:49:33  -6.76  -3.19   -10.780765    0</span><br><span class="line">iter:  11  14:49:34  -8.02  -3.59   -10.780765    0</span><br><span class="line">iter:  12  14:49:34  -6.82  -3.60   -10.780765    0</span><br><span class="line">iter:  13  14:49:34  -8.06  -3.60   -10.780764    0</span><br><span class="line">iter:  14  14:49:35 -10.08  -3.78   -10.780764    0</span><br><span class="line">iter:  15  14:49:35  -8.45  -3.78   -10.780764    0</span><br><span class="line">iter:  16  14:49:36  -8.00  -3.68   -10.780764    0</span><br><span class="line">iter:  17  14:49:36  -8.17  -3.80   -10.780764    0</span><br><span class="line">iter:  18  14:49:37  -9.30  -3.92   -10.780764    0</span><br><span class="line">iter:  19  14:49:37  -8.99  -3.95   -10.780764    0</span><br><span class="line">iter:  20  14:49:37  -9.83  -4.06   -10.780764    0</span><br><span class="line"></span><br><span class="line">Converged after 20 iterations.</span><br></pre></td></tr></table></figure><p>往下一点是相对PAW原子的总能量成分分析. 从GPAW分析来看, Si在形成晶体后, 电子动能增加, 势能与交换关联能降低. 后面两者容易理解, 但原子形成固体后动能增加这一点从化学成键相悖. 只能说在赝势PAW下, 直接的能量组成并没有物理意义. VASP的OUTCAR中的能量组成分析没有给出动能的部分.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Energy contributions relative to reference atoms: (reference = -15772.688500)</span><br><span class="line"></span><br><span class="line">Kinetic:        +15.782785</span><br><span class="line">Potential:      -13.855376</span><br><span class="line">External:        +0.000000</span><br><span class="line">XC:             -12.678254</span><br><span class="line">Entropy (-ST):   -0.000000</span><br><span class="line">Local:           -0.029919</span><br><span class="line">--------------------------</span><br><span class="line">Free energy:    -10.780764</span><br><span class="line">Extrapolated:   -10.780764</span><br></pre></td></tr></table></figure><p>再往下是关于能带结构的简单信息. 包括费米能级和前两个k点上的价带导带本征值和占据数. 需要注意的是这里的occupancy是该自旋轨道上的电子数乘以k点分数权重的值. 如果是自旋极化计算, 这部分会给出两个自旋通道的占据数, 占据数会变成非极化的一半. $\Gamma$点带隙为2.56 eV.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Fermi level: 5.73099</span><br><span class="line"></span><br><span class="line">Showing only first 2 kpts</span><br><span class="line"> Kpt  Band  Eigenvalues  Occupancy</span><br><span class="line">  0     2      5.31933    0.00391</span><br><span class="line">  0     3      5.31934    0.00391</span><br><span class="line">  0     4      7.87829    0.00000</span><br><span class="line">  0     5      7.87829    0.00000</span><br><span class="line"></span><br><span class="line">  1     2      4.51004    0.02344</span><br><span class="line">  1     3      4.51006    0.02344</span><br><span class="line">  1     4      7.32815    0.00000</span><br><span class="line">  1     5      9.02227    0.00000</span><br></pre></td></tr></table></figure><h2 id="能带计算"><a href="#能带计算" class="headerlink" title="能带计算"></a>能带计算</h2><p>PBE能带计算需要使用SCF得到的电子密度. 官方网站给出的一个能带计算例子如下.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calc = GPAW(<span class="string">'Si_gs.gpw'</span>, nbands=<span class="number">16</span>, fixdensity=<span class="keyword">True</span>, symmetry=<span class="string">'off'</span>,</span><br><span class="line">            kpts=&#123;<span class="string">'path'</span>: <span class="string">'GXWKL'</span>, <span class="string">'npoints'</span>: <span class="number">60</span>&#125;, convergence=&#123;<span class="string">'bands'</span>: <span class="number">8</span>&#125;)</span><br><span class="line">calc.get_potential_energy()</span><br><span class="line">calc.write(<span class="string">'Si_bs.gpw'</span>)</span><br></pre></td></tr></table></figure><p>这里主要需要理解<code>GPAW</code>一行</p><ul><li>第一个参数<code>Si_gs.gpw</code>为读入文件.</li><li><code>nbands</code>为SCF迭代所包含的能带数.</li><li><code>fixdensity=True</code>, 顾名思义, 固定电子密度.</li><li><code>kpts</code>为一个字典, 包含<code>path</code>和<code>npoints</code>两个键. <code>path</code>包含BZ特殊点记号. 这里的路径为G-X-W-K-L, 根据总k点数<code>npoints</code>自动设置所需要计算的k点, 不会重复计算特殊k点. 特殊点之间的k点数不是均匀的.</li><li><code>convergence</code>为一个字典, 包含键<code>band</code>, 值为8. 表示使用最低的8个能级的波函数的Kohn-Sham方程余矢量模方作为收敛判据. 可以使用’all’和<code>-8</code>之类的负值, 后者表示收敛除最后8个外的所有能级. 具体参考<a href="https://wiki.fysik.dtu.dk/gpaw/documentation/manual.html#accuracy-of-the-self-consistency-cycle" target="_blank" rel="noopener">Accuracy of the self-consistency cycle</a>条目.</li></ul><p><code>get_potential_energy</code>开始SCF循环, 结束后将calculator写入Si_bs.gpw.</p><p>GPAW提供了能带分析的帮助方法<code>band_structure</code>. 该方法继承自ASE的<code>Calculator</code>类. 使用方式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc = GPAW(<span class="string">'Si_bs.gpw'</span>)    <span class="comment"># 读取Si能带计算结果</span></span><br><span class="line">bs = calc.band_structure()  <span class="comment"># 调用band_structure方法</span></span><br><span class="line">bs.plot(show=<span class="keyword">True</span>, emax=<span class="number">10.0</span>, filename=<span class="string">"Si_bs.png"</span>) <span class="comment"># 作图</span></span><br></pre></td></tr></table></figure><p><code>band_structure</code>方法返回一个<code>ase.dft.band_structure.BandStructure</code>类. 得到能带图如下, 和<a href="https://wiki.fysik.dtu.dk/gpaw/tutorials/bandstructures/bandstructures.html#bandstructures" target="_blank" rel="noopener">官网例子</a>是相同的.</p><p><figure class="null"><img src="Si_bs.png" alt=" "><figcaption> </figcaption></figure></p><h2 id="与电子结构相关的GPAW方法"><a href="#与电子结构相关的GPAW方法" class="headerlink" title="与电子结构相关的GPAW方法"></a>与电子结构相关的GPAW方法</h2><p><code>BandStructure</code>作图非常方便, 但如果是自己作图或者需要能级数据做进一步处理, 就需要从<code>GPAW</code>对象直接获取k点和Kohn-Sham本征值. 一些可能用到的方法如下</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">继承</th><th style="text-align:left">作用</th><th style="text-align:center">常用参数</th><th style="text-align:center">返回</th></tr></thead><tbody><tr><td style="text-align:left"><code>get_fermi_level</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取Fermi能级</td><td style="text-align:center"></td><td style="text-align:center"><code>float</code></td></tr><tr><td style="text-align:left"><code>get_number_of_spins</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取自旋通道数量</td><td style="text-align:center"></td><td style="text-align:center"><code>int</code></td></tr><tr><td style="text-align:left"><code>get_number_of_electrons</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取价电子总数</td><td style="text-align:center"></td><td style="text-align:center"><code>float</code></td></tr><tr><td style="text-align:left"><code>get_eigenvalues</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取本征值</td><td style="text-align:center"><code>(ik=0, ispin=0)</code></td><td style="text-align:center">1D array</td></tr><tr><td style="text-align:left"><code>get_ibz_k_points</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取不可约k点</td><td style="text-align:center"></td><td style="text-align:center">2D array</td></tr><tr><td style="text-align:left"><code>get_bz_k_points</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取所有k点</td><td style="text-align:center"></td><td style="text-align:center">2D array</td></tr></tbody></table><p>例如, 获取所有能级到<code>eigens</code>数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eigens = np.array([[</span><br><span class="line">                    calc.get_eigenvalues(ik, isp) <span class="keyword">for</span> ik,_ <span class="keyword">in</span> enumerate(calc.get_ibz_k_points())</span><br><span class="line">                   ] <span class="keyword">for</span> isp <span class="keyword">in</span> range(calc.get_number_of_spins())])</span><br></pre></td></tr></table></figure><p>获取各k点的直接带隙</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vb = int(calc.get_number_of_electrons()/<span class="number">2.0</span>) - <span class="number">1</span></span><br><span class="line">direct_gaps = eigens[<span class="number">0</span>, :, vb+<span class="number">1</span>] - eigens[<span class="number">0</span>, :, vb]</span><br></pre></td></tr></table></figure><p>手动制作能带图的方法可以参考<a href="https://www.mantidproject.org/Band_Structures_With_GPAW" target="_blank" rel="noopener">Band Structures With GPAW - Mantid Project</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;以金刚石结构Si为例, 演示了用GPAW计算材料电子能带结构的过程, 对结果进行了简单分析.
    
    </summary>
    
      <category term="Software" scheme="https://github.com/minyez/categories/Software/"/>
    
    
      <category term="DFT" scheme="https://github.com/minyez/tags/DFT/"/>
    
      <category term="Tutorial" scheme="https://github.com/minyez/tags/Tutorial/"/>
    
      <category term="GPAW" scheme="https://github.com/minyez/tags/GPAW/"/>
    
      <category term="Band structure" scheme="https://github.com/minyez/tags/Band-structure/"/>
    
  </entry>
  
  <entry>
    <title>outwin算法解读</title>
    <link href="https://github.com/minyez/2019/05/24/outwin-read/"/>
    <id>https://github.com/minyez/2019/05/24/outwin-read/</id>
    <published>2019-05-24T08:14:53.000Z</published>
    <updated>2019-06-09T02:46:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>阅读WIEN2k v16.1版本中例程<code>outwin</code>的源码, 以理解其所用到的算法. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>outwin.f在WIEN2k各程序中出现, 它包含例程<code>outwin</code>. 之前大略知道它是用来计算原子球内的径向波函数的, 但对于其算法一直很模糊, 一方面由于它涉及相对论方程, 另一方面它除了输入参数的德语注释外一句注释也没有. 最近在研究局域基组生成的问题, 而这个例程出现频率非常高, 因此准备多啃一下这块代码.</p><p>不同SRC文件下的outwin.f版本也不尽同. SRC_nmr, SRC_lapw7等仍然使用Adams-Moulton四阶算法, SRC_lapw2对于第四个以外的格点允许用五阶算法. SRC_lapw7中的注释更多一些, 但仍然用的是四阶算法. 这里尝试对SRC_lapw7中的outwin.f源码进行解读.</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在Rydberg单位下, 具有量子数$\kappa$的大分量波函数$u(r)=G(r)/r$满足<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="参考这一篇[报告](https://users.wfu.edu/natalie/papers/pwpaw/notes/atompaw/scalarrelativistic.pdf)">[1]</span></a></sup></p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    \frac{d}{d r} G(r) &amp;= \frac{G(r)}{r}+M(r) F(r) \\<br>    \frac{d}{d r} F(r) &amp;= -\frac{F(r)}{r}+\left(\frac{\kappa(\kappa+1)}{r^{2}} \frac{1}{M(r)}-(E-V(r))\right) G(r)<br>\end{aligned}<br>\end{equation}\label{eq:r-GF}<br>$$</p><p>其中</p><p>$$<br>\begin{equation}<br>M(r) \equiv 1+\left(\frac{\alpha}{2}\right)^{2}(E-V(r)) = 1+\frac{E-V(r)}{c^2}<br>\end{equation}\label{eq:m}<br>$$</p><p>$\alpha$为精细结构常数, 在Rydberg单位下$\alpha=2/c$, $c$为光速. 为在步长$h$的对数格点上进行数值计算, 作变量替换$r=r_0 e^x$, $\mathrm{d}r=r\mathrm{d}x$, 得到关于$x$的方程组</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    G’ &amp;= G + M r F \\<br>    F’ &amp;= - F + \left(\frac{\kappa(\kappa+1)}{rM}-r(E-V)\right) G<br>\end{aligned}<br>\end{equation}\label{eq:x-GF}<br>$$</p><p>方便起见, 上式中略去了<em>G,F,M</em>的变量$r\equiv r(x)$, 撇号表示关于<em>x</em>求导.</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h3 id="行66-81"><a href="#行66-81" class="headerlink" title="行66-81"></a>行66-81</h3><h3 id="行83-91"><a href="#行83-91" class="headerlink" title="行83-91"></a>行83-91</h3><p>从81行开始是对第四个及以后的格点的循环. <code>X</code>为<em>-h</em>, <code>DRDI</code>为<em>rh</em>. 其他一些的中间量与式$\eqref{eq:x-GF}$中量的关系是</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>\mathrm{PHI} &amp;= rh\frac{E-V}{c}\\<br>\mathrm{U} &amp;= rhc + \mathrm{PHI} = rhc\left[1+\frac{E-V}{c^2}\right] = rhcM \\<br>\mathrm{Y} &amp;= -\kappa(\kappa+1)h^2/\mathrm{U} + \mathrm{PHI} = - \frac{h}{c}\left[\frac{\kappa(\kappa+1)}{rM} - r(E-V)\right]<br>\end{aligned}<br>\end{equation}<br>$$</p><p>从而可以将式$\eqref{eq:x-GF}$写成</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    G’ &amp;= G + \frac{\mathrm{U}}{hc}F \\<br>    F’ &amp;= - F - \frac{c}{h}\mathrm{Y} G<br>\end{aligned}<br>\end{equation}\label{eq:UYGF}<br>$$</p><p>令$A=G, B=F/c$, $A’=G’, B’=F’/c$, 得到</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    A’ &amp;= A + \frac{\mathrm{U}}{h}B \\<br>    B’ &amp;= - B - \frac{\mathrm{Y}}{h} A<br>\end{aligned}<br>\end{equation}\label{eq:UYAB}<br>$$</p><h3 id="行92-96"><a href="#行92-96" class="headerlink" title="行92-96"></a>行92-96</h3><p>由行列式解线性方程的知识可知, 这部分求解的是这样一个矩阵方程</p><p>$$\begin{equation}<br>\begin{bmatrix}<br>\frac{8}{3} + X &amp; -U \\<br>Y &amp; \frac{8}{3} - X \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>A_c \\<br>B_c \\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>B1 \\<br>B2 \\<br>\end{bmatrix}<br>\end{equation}\label{eq:mat-92-96}$$</p><p>这里下标c表示在代码(code)中的定义. <code>B1</code>和<code>B2</code>在93和94行计算, 基于<a href="https://en.wikipedia.org/wiki/Linear_multistep_method#Adams%E2%80%93Moulton_methods" target="_blank" rel="noopener">Adams-Moulton算法</a>, 因为8/3来自于四阶算法</p><p>$$<br>y_{n+3}=y_{n+2}+h\left(\frac{9}{24} f\left(t_{n+3}, y_{n+3}\right)+\frac{19}{24} f\left(t_{n+2}, y_{n+2}\right)-\frac{5}{24} f\left(t_{n+1}, y_{n+1}\right)+\frac{1}{24} f\left(t_{n}, y_{n}\right)\right)<br>$$</p><p>其中$f(t_n, y_n)=y’_n$为第n格点上y的导数. 利用上式可以将$A’_{n+3}$表示为</p><p>$$<br>hA’_{n+3} = \frac{8}{3}A_{n+3} - \frac{8}{3}A_{n+2} - \frac{19}{9}hA’_{n+2} + \frac{5h}{9}A’_{n+1} - \frac{h}{9}A’_n<br>$$</p><p>将式$\eqref{eq:UYAB}$两边乘以$h$后, 在格点$n+3$处的表达式为</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    \left[\frac{8}{3} - h\right]A_{n+3} - U_{n+3} B_{n+3} &amp;= \frac{8}{3}A_{n+2} + \frac{19}{9}hA’_{n+2} - \frac{5}{9}hA’_{n+1} + \frac{1}{9}hA’_n \\<br>    \left[\frac{8}{3} + h\right]B_{n+3} + Y_{n+3} A_{n+3} &amp;= \frac{8}{3}B_{n+2} + \frac{19}{9}hB’_{n+2} - \frac{5}{9}hB’_{n+1} + \frac{1}{9}hB’_n<br>\end{aligned}<br>\end{equation}\label{eq:n-3-UYAB}<br>$$</p><p>如果把上式看成未知数$A_{n+3}$和$B_{n+3}$的二元一次方程, 其系数矩阵和$\eqref{eq:mat-92-96}$是相同的. 检查<code>DGn</code>和<code>DFn</code>的含义(见下面一节)以及系数<code>Rn</code>, 可以发现式子$\eqref{eq:n-3-UYAB}$右侧与<code>B1</code>和<code>B2</code>也是一致的. 因此我们定义的$A$和$B$与outwin.f中的含义是一致的.</p><h3 id="行98-103"><a href="#行98-103" class="headerlink" title="行98-103"></a>行98-103</h3><p>更新最外的三个点的导数值, 以用于计算下一个格点上的<code>B1</code>和<code>B2</code>. 其中<code>Dx1</code>和<code>Dx2</code>分别用<code>Dx2</code>和<code>Dx3</code>替代, 即97, 98, 101和102行, 在格点迭代的语境下很好理解. <code>DG3</code>的更新表达式</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DG3 = U*B(K) - X*A(K)</span><br></pre></td></tr></table></figure><p>由式$\eqref{eq:UYAB}$和<code>X</code>等于<em>-h</em>, 可得</p><p>$$<br>DG3 = U_K B_K + h A_K = h(A_K + \frac{U_K}{h}B_K) = hA’_K<br>$$</p><p>因此<code>DG3</code>是$h$乘以A在格点K上的导数. 同理, <code>DF3</code>的更新表达式</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DF3 = X*B(K) - Y*A(K)</span><br></pre></td></tr></table></figure><p>意味着$DF3 = -h B_K - Y_K A_K = h B’_K$. 因此<code>DF3</code>是$h$乘以B在格点K上的导数.</p><h3 id="行107-109"><a href="#行107-109" class="headerlink" title="行107-109"></a>行107-109</h3><p>这一个循环对<em>B</em>进行了scaling, $B \to cB/2= F/2=\alpha F$. 报告<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="参考这一篇[报告](https://users.wfu.edu/natalie/papers/pwpaw/notes/atompaw/scalarrelativistic.pdf)">[1]</span></a></sup>指出<em>F</em>与小分量有关, 但具体关系暂未推导.</p><h3 id="行111-113"><a href="#行111-113" class="headerlink" title="行111-113"></a>行111-113</h3><p>由于$A=G=ru$, 因此<code>VAL</code>就是最后一个格点上的波函数值. 而<code>SLO</code>的数学表示</p><p>$$<br>(h\frac{\mathrm{d}A}{hr\mathrm{d}x}-u)/r<br>=\frac{\mathrm{d}(ru)}{r \mathrm{d}r} - \frac{u}{r}<br>=\frac{r\mathrm{d}u}{r \mathrm{d}r} = \frac{\mathrm{d}u}{\mathrm{d}r}<br>$$</p><p>为波函数在边界上的导数.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>outwin.f中的<code>outwin</code>例程利用Adams-Moulton算法求解标量相对论方程$\eqref{eq:r-GF}$, 在对数格点上得到量子数$\kappa$下的大分量波函数, 以函数乘矢径长的形式存储在$A$中.</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">参考这一篇<a href="https://users.wfu.edu/natalie/papers/pwpaw/notes/atompaw/scalarrelativistic.pdf" target="_blank" rel="noopener">报告</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;阅读WIEN2k v16.1版本中例程&lt;code&gt;outwin&lt;/code&gt;的源码, 以理解其所用到的算法.
    
    </summary>
    
      <category term="Algorithm" scheme="https://github.com/minyez/categories/Algorithm/"/>
    
    
      <category term="WIEN2k" scheme="https://github.com/minyez/tags/WIEN2k/"/>
    
      <category term="Numerical method" scheme="https://github.com/minyez/tags/Numerical-method/"/>
    
  </entry>
  
  <entry>
    <title>使用gprof2dot+dot制作Fortran程序的调用图</title>
    <link href="https://github.com/minyez/2019/05/15/profile-with-gprof-dot/"/>
    <id>https://github.com/minyez/2019/05/15/profile-with-gprof-dot/</id>
    <published>2019-05-15T08:57:40.000Z</published>
    <updated>2019-05-20T16:37:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文简要介绍如何基于gprof或Valgrind的性能分析数据, 使用gprof2dot和Graphviz制作Fortran程序的调用图, 以便对Fortran程序进行调试和优化. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>程序逻辑或者工作流是程序设计中很重要的部分, 与程序的算法实现及效率紧密相关. 通过分析程序运行中函数的调用顺序和次数等, 可以发现程序中可能存在的设计缺陷和性能瓶颈. 调用图(<a href="https://en.wikipedia.org/wiki/Call_graph" target="_blank" rel="noopener">call graph</a>)是一种展示程序工作流的手段, 包括静态和运行时两种, 前者侧重调用逻辑, 后者侧重实际工作环境中的时间效率.</p><p>之前写代码时一直不是很重视设计这个阶段, 最多用心灵导图稍微画一画需求, 也不是非常严格. 这导致过一段时间回看代码, 会对某些地方为什么要那么写产生疑问, 要想很久才能回忆起来, 很费时间. 这对于个人小型项目问题还好, 对中型或大型项目就会造成很大的困难. 在一顿无望的结果测试后, 最近我重新回到组里GAP3的开发里. 尽管理解工作流程, 但对于GAP3的<em>GW</em>计算如何调用它的各种例程, 仍然没有非常清晰的图象. 于是我希望能用调用图来把程序运行逻辑可视化, 帮助自己理清思路. 网上一顿搜索后, 发现可以用gprof和Valgrind来做性能分析, 用gprof2dot和<code>dot</code>来处理分析数据并作图.</p><p>这篇文章就是自学的一些总结. 以下所有操作都是在Linux (Fedora 27)下完成, 用到的主要工具是</p><ul><li>Fortran编译器与链接器: 这里使用Intel 2018 Update 1的<code>ifort</code></li><li><a href="https://sourceware.org/binutils/docs/gprof/" target="_blank" rel="noopener">gprof</a>: 用于分析编译器产生的性能分析文件</li><li>Valgrind: 在<a href="/2019/03/23/valgrind-1/" title="Valgrind笔记(一)——Memcheck初探">Valgrind笔记(一)——Memcheck初探</a>一文中提到了使用Valgrind的memcheck工具检测内存使用状况, 实际上它还提供了<code>callgrind</code>工具来进行函数调用的运行时分析.</li><li><a href="https://github.com/jrfonseca/gprof2dot">gprof2dot</a>: 将<code>gprof</code>或<code>callgrind</code>分析获得的信息转化成一个以<a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language" target="_blank" rel="noopener">DOT语言</a>)描述的有向图(directed graph)对象. 可以通过<code>pip</code>安装.</li><li><code>dot</code>: 利用Graphviz将DOT有向图对象渲染成图片, 属于Graphviz发行版的一部分.</li></ul><h2 id="一个接口调用的例子"><a href="#一个接口调用的例子" class="headerlink" title="一个接口调用的例子"></a>一个接口调用的例子</h2><p>先从一个简单的例子出发, 把调用图制作的逻辑弄清楚. 下面是一段简单的做整数与浮点数加法的Fortran代码</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! filename: hw.f90</span></span><br><span class="line"><span class="keyword">module</span> tools</span><br><span class="line">    <span class="keyword">interface</span> add</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> add_int</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> add_double</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span> add</span><br><span class="line"></span><br><span class="line">    <span class="keyword">contains</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> add_int(i, j)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: i</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: j</span><br><span class="line">            <span class="keyword">integer</span> :: add_int</span><br><span class="line"></span><br><span class="line">            add_int = i +j</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> add_int</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> add_double(i, j)</span><br><span class="line">            <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: i</span><br><span class="line">            <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: j</span><br><span class="line">            <span class="keyword">real</span>(<span class="number">8</span>) :: add_double</span><br><span class="line"></span><br><span class="line">            add_double = i +j</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> add_double</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hw</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> tools</span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">real</span>(<span class="number">8</span>) :: x</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str = <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">"(A20)"</span>) str</span><br><span class="line">    i = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    x = add(<span class="number">1.1d0</span>, <span class="number">2.1d0</span>)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">"(I2)"</span>) i</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">"(F6.3)"</span>) x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> hw</span><br></pre></td></tr></table></figure><p>在这里, 主程序中调用的<code>add</code>函数实际上是一个接口, 当接受两个整数时重载为<code>add_int</code>, 接受两个双精度浮点数是重载为<code>add_double</code>. 下面分别用gprof和valgrind为后端, 进行性能分析和调用图的制作.</p><h3 id="使用gprof"><a href="#使用gprof" class="headerlink" title="使用gprof"></a>使用gprof</h3><p>首先, 要使用<code>gprof</code>, 需要在程序编译时添加<code>-p</code>或<code>-pg</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifort -p -g -c hw.f90 -o hw.o</span><br><span class="line">ifort -o test.out hw.o -p</span><br></pre></td></tr></table></figure><p>这里尽量采用先编译到目标文件, 再链接到可执行文件的方式. 然后运行test.out</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.out</span><br></pre></td></tr></table></figure><p>产生gmon.out文件. 用<code>gprof</code>读取这一文件并将标准输出重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gprof test.out &gt; gprof_test.txt</span><br></pre></td></tr></table></figure><p>gprof_test.txt中包含了运行<code>test.out</code>过程中各函数的调用次数, 程序在每个函数及其子函数中的停留时间等.</p><p>接下来, 使用<code>gprof2dot</code>处理gprof_test.out</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat gprof_test.out | gprof2dot -f prof -o digraph.dot</span><br></pre></td></tr></table></figure><p>digraph.out用一个<code>digraph</code>数据类型描述了一个有向图. 用<code>dot</code>处理该文件并产生</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat digraph.dot | dot -Tpng -o hw_gprof.png</span><br></pre></td></tr></table></figure><p>得到下图. 可以看到<code>MAIN</code>中各调用了一次<code>add_int</code>和<code>add_double</code>. 每个方块中第一个百分数是在该函数及其子函数的运行时间占程序总时间的比例, 第二个数是仅在该函数内的时间的比例. 这里全都是100%, 是因为计算时间太短了, gprof_test.out里的时间都是0.00.</p><p><figure class="null"><img src="hw_gprof.png" alt="单次加法调用时, gprof产生的hw.f90调用图"><figcaption>单次加法调用时, gprof产生的hw.f90调用图</figcaption></figure></p><p>试着将加法次数增大到九千万次, 就可以看到明显的不同. 双精度耗时比整型的还是要多一些.</p><p><figure class="null"><img src="hw_9kw_gprof.png" alt="加法各九千万次时的gprof调用图"><figcaption>加法各九千万次时的gprof调用图</figcaption></figure></p><h3 id="使用callgrind"><a href="#使用callgrind" class="headerlink" title="使用callgrind"></a>使用callgrind</h3><p>若用Valgrind来做生成性能分析, 只需使用<code>valgrind</code>调用欲测试函数, 同时指明callgrind工具, 而不需要对编译做特别的改动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=callgrind ./test.out</span><br></pre></td></tr></table></figure><p>运行结束后会产生名为callgrind.out.xxx的文件, 其中xxx是运行程序进程的PID. 使用gprof2dot分析之</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat callgrind.out.xxx | gprof2dot -f callgrind -o digraph.dot</span><br></pre></td></tr></table></figure><p>生成png的命令与前面gprof的相同. 当只调用一次加法时调用图如下, 出现很多复杂的库函数调用, 猜测应该跟valgrind本身有关, 反而看不到<code>add_int</code>和<code>add_double</code>. 这时并不表示这两个函数未被调用, 而是因为占用时间太少, 被gprof2dot剪裁掉了.</p><p><figure class="null"><img src="hw_callgrind.png" alt="单次加法调用时, callgrind产生的hw.f90调用图"><figcaption>单次加法调用时, callgrind产生的hw.f90调用图</figcaption></figure></p><p>提高到九千万次调用后的分析结果看上去正常一些. 同样的, 这也不是说那些库函数未被调用, 而是在这种情况下主要耗时都在加法上, 库函数调用耗时少而被gprof2dot去掉了. 这些都是视觉表现上的考虑.</p><p><figure class="null"><img src="hw_9kw_callgrind.png" alt="加法各九千万次时的callgrind调用图"><figcaption>加法各九千万次时的callgrind调用图</figcaption></figure></p><p>比较两种工具所得的调用图, 发现Valgrind能给出包含被调用函数所在库的名称. 在九千万次加法的例子里, 使用Valgrind做性能分析所花的时间比gprof要多得多, 因此还是决定用gprof来做GAP3的分析. 上面用的所有程序和Makefile打包在<a href="fortran-profile.tar.gz">这里</a>了.</p><h2 id="GAP3的调用图"><a href="#GAP3的调用图" class="headerlink" title="GAP3的调用图"></a>GAP3的调用图</h2><p>在<code>-O3</code>下编译串行程序, 用<code>gprof</code>做运行时分析, 在真空层为9 Bohr的单层六方BN中测试. 库仑截断的开关打开, 以检查工作流是否跟自己预想的相同. 最后得到调用图如下所示.</p><p><figure class="null"><img src="cg_gap3_O3.png" alt="O3下GAP3中GW功能的调用图"><figcaption>O3下GAP3中GW功能的调用图</figcaption></figure></p><p>可以得到的比较直接的结论是</p><ol><li>花费时间最多的上层例程是: 介电矩阵计算<code>calceps</code>(63.70%), 交换自能即Fock算符<code>calcselfx</code>(26.05%), 关联自能<code>calcselfc</code>(2.63%)</li><li>花费时间最多的底层例程是<code>calcminm</code>(90.28%), 用于计算KS波函数积与MPB的重叠矩阵元$M^i_{nm}({\bf k, q})$. 原则上计算量是$\mathcal{O}(N_{\chi} N N_e N_v N^2_k)$, 其中$N_{\chi}$是MPB数量, $N$是APW+LO基组数, 价态数量$N_v$, 电子总数$N_e$, BZ中k布点数$N_k$</li></ol><p>另外发现的一个问题是, 在开启库仑截断后, 所有的库仑势计算都应该用<code>coul_barc_cutoff</code>例程, 但依然有9次<code>coul_barc</code>调用, 因此库仑势计算比关联自能更多一点. <code>coul_setvm0</code>和<code>calcmwm</code>也需要用带cutoff后缀的. 因此这样的调用图也能帮助解决一些流程控制上的bug.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中, 笔者分别用gprof和callgrind对一个简单的Fortran程序制作了调用图, 并通过调用图分析了GAP3程序中的性能瓶颈, 发现了库仑截断开启时的流程控制问题.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zengkefu/p/5642991.html" target="_blank" rel="noopener">valgrind的callgrind工具进行多线程性能分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文简要介绍如何基于gprof或Valgrind的性能分析数据, 使用gprof2dot和Graphviz制作Fortran程序的调用图, 以便对Fortran程序进行调试和优化.
    
    </summary>
    
      <category term="Programming" scheme="https://github.com/minyez/categories/Programming/"/>
    
    
      <category term="Valgrind" scheme="https://github.com/minyez/tags/Valgrind/"/>
    
      <category term="gprof" scheme="https://github.com/minyez/tags/gprof/"/>
    
      <category term="Fortran" scheme="https://github.com/minyez/tags/Fortran/"/>
    
      <category term="Call graph" scheme="https://github.com/minyez/tags/Call-graph/"/>
    
  </entry>
  
  <entry>
    <title>关于重启这个博客的思考</title>
    <link href="https://github.com/minyez/2019/05/08/restart-hexo-blog/"/>
    <id>https://github.com/minyez/2019/05/08/restart-hexo-blog/</id>
    <published>2019-05-07T17:50:24.000Z</published>
    <updated>2019-05-09T03:00:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p>碎碎念而已.<br><a id="more"></a></p><p>在经历了草稿里的一些乌龙后, Hexo又能正常工作了. 我也在过了很久一段时间后回到这里, 重新打理这片虚拟的土地, 重新开始上传技术文字. 目前大部分是存在熊掌记和Agenda里后整理出来的bugfix和初步学习笔记.</p><p>我还在考虑把其他地方的文字都移到这里来, 因为我感到这是一片属于我的独一无二的土地. 我于此耕耘, 把它定义成我想要的样貌. 在这里, 我的声音能够回响; 它不必响彻, 在我脑海里就足够了. 如果它能够进到一位陌生人的耳中, 他恰又能够给我一些呼应, 那就真是难得的美好.</p><p>更重要的是, 我渐渐想要去发出我自己的声音了. 无论在现实里还是在虚拟世界里, 自己其实一直都是个害怕发声的人: 我感到时刻被周围人的目光所裹挟, 担心无论说什么都会使人失望; 讨好他人, 很少说出自己的真实想法; 在公共场所/宿舍, 我用绝对安静, 去鄙视那些喧哗的人. 我好像保持着一个很好的形象, 但我失去了表达自己的机会; 事实上这个形象也未必就很好.</p><p>渐渐地, 我发现自己无法准确表达一些应当很容易传达的东西. 我意识到一直不去表达是不行的. 但我不希望太大张旗鼓, 尽管有时无可避免地想获得一点点真心的关注. 于是我想到这里, 这是我一手创造的空间, 这里有来来往往的冷漠又友好的陌生人, 有点像在一座完全陌生的小镇里, 拿着自己心爱的乐器独自演奏.</p><p>我会继续写下去.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;碎碎念而已.&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="https://github.com/minyez/categories/Life/"/>
    
    
      <category term="Blogging" scheme="https://github.com/minyez/tags/Blogging/"/>
    
  </entry>
  
</feed>
