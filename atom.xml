<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shigaro</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shigaro.org/"/>
  <updated>2020-10-02T00:34:52.439Z</updated>
  <id>http://shigaro.org/</id>
  
  <author>
    <name>minyez</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Emacs 笔记 (三) —— Org-mode 导出到 LaTeX 与 Beamer</title>
    <link href="http://shigaro.org/2020/10/01/emacs-3-org-latex-export/"/>
    <id>http://shigaro.org/2020/10/01/emacs-3-org-latex-export/</id>
    <published>2020-10-01T11:50:00.000Z</published>
    <updated>2020-10-02T00:34:52.439Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>简单介绍了将 org 文件导出为 LaTeX 普通文档或 Beamer 演示所需要的基本准备, 包括 org 文档格式和相关 Lisp 变量的自定义.</p></div>&lt;!-- more --&gt;</p><h2>前言</h2><p>前面两篇博文谈及 Emacs 和 Org-mode 的基本操作。经过了快三个月的练习，现在对两者也算是熟悉了一些. 目前 Emacs+Org 已经成为我整理文献，分析数据和撰写研究报告的主力工具. 其中对我最重要的一个功能就是 org 文本向 LaTeX 和 Beamer 的导出. 通过编写导出模板，可以使用同一个 org 文件，不改动正文就可以同时导出 LaTeX 和 Beamer 格式的 tex 文档，再进行编译.</p><p>本文是对我自己的 LaTeX 导出配置的一个整理和回顾。对 <code>config</code> 文件全文感兴趣的朋友可以移步我的 <a href="https://github.com/minyez/dotfiles/blob/master/doom.d/config.el" target="_blank" rel="noopener">dotfiles 项目</a>. 欢迎提出改进意见.</p><h2>LaTeX 导出的最小工作实例</h2><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+TITLE: MWE of LaTeX export</span><br><span class="line">#+LATEX_CLASS: article</span><br><span class="line">#+LATEX_COMPILER: xelatex</span><br><span class="line">#+LATEX_HEADER: \usepackage[dvipsnames]&#123;xcolor&#125;</span><br><span class="line"></span><br><span class="line">This is a \colortext&#123;Blue&#125;&#123;minimal&#125; working example for \LaTeX export of org file</span><br><span class="line"></span><br><span class="line">这是 org 文件导出为 \LaTeX 文档的最小工作实例.</span><br></pre></td></tr></table></figure></p><p>快捷键 <code>C-c C-e l l</code> 即可导出 <code>.tex</code> 后缀的同名文件, 其中就是转换好的 LaTeX 代码. <code>C-c C-e l o</code> 可以在导出后立刻编译, 清理临时文件, 随后打开编译好的 pdf. 这里有四点需要说明:</p><p>第一, 导出的核心是头部参数 <code>LATEX_CLASS</code>。前者需要在变量 <code>org-latex-classes</code> (一个 list) 中预先定义. 它的默认值是</p><p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">(</span><br><span class="line">  (<span class="string">"article"</span></span><br><span class="line">   <span class="string">"\\documentclass[11pt]&#123;article&#125;"</span></span><br><span class="line">   (<span class="string">"\\section&#123;%s&#125;"</span> . <span class="string">"\\section*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsection&#123;%s&#125;"</span> . <span class="string">"\\subsection*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsubsection&#123;%s&#125;"</span> . <span class="string">"\\subsubsection*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\paragraph&#123;%s&#125;"</span> . <span class="string">"\\paragraph*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subparagraph&#123;%s&#125;"</span> . <span class="string">"\\subparagraph*&#123;%s&#125;"</span>))</span><br><span class="line">  (<span class="string">"report"</span></span><br><span class="line">   <span class="string">"\\documentclass[11pt]&#123;report&#125;"</span></span><br><span class="line">   (<span class="string">"\\part&#123;%s&#125;"</span> . <span class="string">"\\part*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\chapter&#123;%s&#125;"</span> . <span class="string">"\\chapter*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\section&#123;%s&#125;"</span> . <span class="string">"\\section*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsection&#123;%s&#125;"</span> . <span class="string">"\\subsection*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsubsection&#123;%s&#125;"</span> . <span class="string">"\\subsubsection*&#123;%s&#125;"</span>))</span><br><span class="line">  (<span class="string">"book"</span> <span class="string">"\\documentclass[11pt]&#123;book&#125;"</span></span><br><span class="line">   (<span class="string">"\\part &#123;%s&#125;"</span> . <span class="string">"\\part*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\chapter &#123;%s&#125;"</span> . <span class="string">"\\chapter*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\section &#123;%s&#125;"</span> . <span class="string">"\\section*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsection&#123;%s&#125;"</span> . <span class="string">"\\subsection*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsubsection&#123;%s&#125;"</span> . <span class="string">"\\subsubsection*&#123;%s&#125;"</span>)))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>列表中每个元素也是一个列表, 各自对应一个预定义的 LaTeX 类. 每个类需要这样几个要素</p><ul><li>类名称 (字符串)</li><li>对应的 LaTeX 文档类 (字符串)</li><li>各标题层级的转换规则 (不定数量的 cons cell)</li></ul><p>类名称是 <code>LATEX_CLASS</code> 可以取的值. 可以看到默认值里定义了三个 LaTeX 类, 分别对应于 article, report, book 三个实际的 LaTeX 文档类. 定义文档类的 <code>documentclass</code> 语句, 再转换时会被添加到 tex 文件的最开头. 原则上写在这一行的所有内容都会被添加到 tex 的开头, 即序言部分. 因此我们可以对这一字符串做更复杂的自定义来满足自己的需求. 这一点后面会再提到. 后面的每个 cons cell 是 Org 各层级有序号和无序号标题转换的规则. 第一个对应一级标题, 第二个对应二级标题, 以此类推. 比如在 book 类中, 一级标题会被转换为 <code>part</code>, 三级无序标题会被转换为 <code>section*</code>. 可以在 <code>config.el</code> 自定义 LaTeX类. 例如添加如下代码即可增加一个 <code>beamer</code> 类</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">add-to-list</span> 'org-latex-classes</span><br><span class="line">  '(<span class="string">"beamer"</span></span><br><span class="line">    <span class="string">"\\documentclass[ignorenonframetext,presentation]&#123;beamer&#125;"</span></span><br><span class="line">    (<span class="string">"\\section&#123;%s&#125;"</span> . <span class="string">"\\section*&#123;%s&#125;"</span>)</span><br><span class="line">    (<span class="string">"\\subsection&#123;%s&#125;"</span> . <span class="string">"\\subsection*&#123;%s&#125;"</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>它对应于 LaTeX 中的 <code>beamer</code> 文档类.</p><p>第二, <code>LATEX_COMPILER</code> 指明使用何种编译器来编译转换的 tex 文件. Org 提供了一条默认的编译 tex 文件的命令, 写在变量 <code>org-latex-pdf-process</code> 中. 默认是一个包含按次序执行的 latex 指令的列表, 因为在编译 tex 时由于交叉引用等原因, 编译器通常需要与 biber 等附加程序一起对源文档多次编译. 我们可以将其修改为使用 <code>latexmk</code> 等比较智能的编译器, 比如</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">latexmk -latexoption="-interaction=nonstopmode -shell-escape" -pdf -pdflatex=%latex -bibtex -f %f</span><br></pre></td></tr></table></figure></p><p>这里的 <code>%latex</code> 对应于 <code>LATEX_COMPILER</code> 的值, <code>%f</code> 对应于所产生的 tex 文档的相对路径.</p><p>第三, 在转换为 tex 时, Org 原文中的 <code>\LaTeX</code>, <code>\colortext</code> 命令将不作任何转换, 原样导出. Org 会自动识别 <code>\</code>, <code>\begin{}..\end{}</code> 这样具有 LaTeX 特征的语句, 并在导出为 LaTeX 时保留它. 如果想编写专属 LaTeX 导出的内容, 可以使用 <code>@@latex: xxx@@</code> 的形式, 此时 <code>xxx</code> 只会在 tex 中出现, 而不会出现在 Markdown, HTML 等其他格式的导出中.</p><p>第四, <code>LATEX_HEADER</code> 允许包含任何序言区命令, 在默认情况下会添加到序言区末尾. 可添加任意行 <code>LATEX_HEADER</code>, 以便对特定文档进行序言区的定制. 如果一些序言是所有 LaTeX 导出公用的, 可以考虑添加到类声明当中. 如果是一个 package, 则可以加入到 <code>org-latex-packages-alist</code> 或 <code>org-latex-default-packages-alist</code>.</p><h2>Beamer 导出的最小工作实例</h2><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+TITLE: MWE of Beamer Export</span><br><span class="line">#+AUTHOR: minyez</span><br><span class="line">#+OPTIONS: H:3</span><br><span class="line">#+BEAMER_THEME: CambridgeUS</span><br><span class="line">#+LATEX_CLASS_OPTION: [presentation]</span><br><span class="line">#+LATEX_COMPILER: pdflatex</span><br><span class="line">#+LATEX_HEADER: \usepackage&#123;physics&#125;</span><br><span class="line">#+BEAMER_HEADER: \institute[Bed, Home]&#123;Bedroom \\ My House&#125;</span><br><span class="line"></span><br><span class="line">* This is a section</span><br><span class="line">** Subsection A</span><br><span class="line">*** Frame one</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\braket&#123;\phi_i&#125;&#123;\phi_j&#125; = \delta_&#123;ij&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">*** Frame two</span><br><span class="line">Not an empty frame</span><br><span class="line">* This is another section</span><br><span class="line">** Subsection B</span><br><span class="line">non-frame text here</span><br></pre></td></tr></table></figure></p><p>这里, <code>LATEX_COMPILER</code> 和前面 LaTeX 导出中的作用相同. OPTIONS 中用 <code>H:3</code> 指定三级标题转化为 Beamer 帧. 比如这里的 &quot;Frame one&quot; 和 &quot;Frame two&quot; 都会被转化为帧. slides 主题用 <code>BEAMER_THEME</code> 指定. 其他自定义命令用 <code>BEAMER_HEADER</code> 指定, 它们将被添加到 <code>LATEX_HEADER</code> 之后. 与 LaTeX 导出不同, <code>LATEX_CLASS</code> 不是必须的, 导出时默认使用 <code>beamer</code> 类, 但可用 <code>LATEX_CLASS_OPTION</code> 为 Beamer 文档类的 <code>\documentclass</code> 添加选项.</p><h2>自定义 LaTeX 导出类</h2><p>我们可以在 <code>org-latex-classes</code> 中定义比单独 <code>\documentclass</code> 更为复杂的序言. 事实上, Org 在导出时会检查 header 中的 <code>[DEFAULT-PACKAGES]</code>, <code>[PACKAGES]</code>, <code>[EXTRA]</code> 占位符. 如果没有这些占位符, 也未找到对应的 <code>[NO-*]</code>, 那么导出时会用 <code>org-latex-default-packages-alist</code>, <code>org-latex-packages-alist</code> 列表和文档的 <code>LATEX_HEADER</code> 语句展开对应的占位符. 如果找到了任意一个, 则会在该位置展开. 例如, 定义一个新的 <code>colorarticle</code> 类</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">add-to-list</span> 'org-latex-classes</span><br><span class="line">  '(<span class="string">"colorarticle"</span></span><br><span class="line">   <span class="string">"\\documentclass[11pt,4paper]&#123;article&#125;</span></span><br><span class="line"><span class="string">[PACKAGES]</span></span><br><span class="line"><span class="string">\\usepackage[dvipsnames,svgnames*]&#123;xcolors&#125;</span></span><br><span class="line"><span class="string">[EXTRA]</span></span><br><span class="line"><span class="string">\\definecolor&#123;bg&#125;&#123;rgb&#125;&#123;0.95,0.95,0.95&#125;</span></span><br><span class="line"><span class="string">\\definecolors&#123;AliceBlue&#125;</span></span><br><span class="line"><span class="string">[NO-DEFAULT-PACKAGES]"</span></span><br><span class="line">   (<span class="string">"\\section&#123;%s&#125;"</span> . <span class="string">"\\section*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsection&#123;%s&#125;"</span> . <span class="string">"\\subsection*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subsubsection&#123;%s&#125;"</span> . <span class="string">"\\subsubsection*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\paragraph&#123;%s&#125;"</span> . <span class="string">"\\paragraph*&#123;%s&#125;"</span>)</span><br><span class="line">   (<span class="string">"\\subparagraph&#123;%s&#125;"</span> . <span class="string">"\\subparagraph*&#123;%s&#125;"</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>这里会在 xcolors 前导入 <code>org-latex-packages-alist</code> 中定义的包, 在之后导入文档中 <code>LATEX_HEADER</code>, 但不会导入 <code>org-latex-default-packages-alist</code>. 以这种方式引入宏包的目的是方便在不同类中引入一些常用的宏包, 简化自定义类的编写.</p><p>之所以提供 <code>org-latex-packages-alist</code> 和 <code>org-latex-default-packages-alist</code> 两个参数, 可能是考虑到有的包适合在序言最开始包括 (如 <code>amsmath</code>, <code>xcolor</code> 等). 而有的包必须放在最后以避免可能的包冲突. (如 <code>hyperref</code>, <code>cleveref</code>). 笔者一般是把前者放在序言头部, 后者放在结尾.</p><h3>宏包列表</h3><p>默认宏包列表 <code>org-latex-default-packages-alist</code> 和宏包列表 <code>org-latex-packages-alist</code> 具有类似的结构. 先看默认宏包 (为简洁起见, 这里只包含一部分)</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> org-latex-default-packages-alist</span><br><span class="line">  '(</span><br><span class="line">    (<span class="string">""</span> <span class="string">"amsmath"</span> <span class="literal">t</span>) ; include first to avoid iint and iiint error</span><br><span class="line">    (<span class="string">""</span> <span class="string">"amssymb"</span> <span class="literal">t</span>)</span><br><span class="line">    (<span class="string">""</span> <span class="string">"wasysym"</span> <span class="literal">t</span>) ; include last to avoid iint and iint error</span><br><span class="line">    (<span class="string">"AUTO"</span> <span class="string">"inputenc"</span>  <span class="literal">t</span> (<span class="string">"pdflatex"</span>))</span><br><span class="line">    (<span class="string">"T1"</span>   <span class="string">"fontenc"</span>   <span class="literal">t</span> (<span class="string">"pdflatex"</span>))</span><br><span class="line">    (<span class="string">""</span>     <span class="string">"CJKutf8"</span>   <span class="literal">t</span> (<span class="string">"pdflatex"</span>))</span><br><span class="line">    (<span class="string">""</span>     <span class="string">"xeCJK"</span>     <span class="literal">nil</span> (<span class="string">"xelatex"</span>, <span class="string">"xetex"</span>))</span><br><span class="line">    (<span class="string">""</span>     <span class="string">"fontspec"</span>  <span class="literal">nil</span> (<span class="string">"xelatex"</span>, <span class="string">"xetex"</span>, <span class="string">"lualatex"</span>, <span class="string">"luatex"</span>))</span><br><span class="line">    (<span class="string">""</span>     <span class="string">"graphicx"</span>  <span class="literal">t</span>)</span><br><span class="line">    (<span class="string">""</span>     <span class="string">"xcolor"</span>  <span class="literal">t</span>)</span><br><span class="line">    (<span class="string">"newfloat,cache=true"</span>   <span class="string">"minted"</span>   <span class="literal">nil</span>)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>列表中每一个元素是一个列表, 最多包含四个参数</p><ol><li>宏包的选项 (字符串)</li><li>宏包名称 (字符串)</li><li>编译 tex 片断预览时是否导入 (布尔值)</li><li>编译器 (即 <code>LATEX_COMPILER</code>) 依赖 (列表), 只在用该编译器时导出. 留空则表示无论何编译器均导出.</li></ol><p><code>org-latex-packages-alist</code> 是类似的</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> org-latex-packages-alist</span><br><span class="line">  '(; hyperref and cleverf should be the last packages to load</span><br><span class="line">    (<span class="string">""</span>     <span class="string">"hyperref"</span>  <span class="literal">nil</span>)</span><br><span class="line">    (<span class="string">""</span>     <span class="string">"cleveref"</span>   <span class="literal">nil</span>)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>考虑到不同文档中需要 hyperref 包的选项 (链接颜色, 边框等) 不同, 因此比较灵活的办法是留空 alist 变量中 hyperref 的选项, 通过在 LaTeX 类定义的头部中指定 <code>PassOptionsToPackages</code> 来传递选项.</p><h3>代码块风格控制</h3><p>通常有两种方式来控制 LaTeX 文档中代码块的表现, listings 或 minted. 由于 minted 适用的语言更多, 风格也更为灵活, 笔者选择其作为代码块渲染</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> org-latex-listings 'minted)</span><br></pre></td></tr></table></figure></p><p>并使用 <code>org-latex-minted-options</code> 控制 minted 环境的选项</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq</span> org-latex-minted-options</span><br><span class="line">      '(</span><br><span class="line">        (<span class="string">"bgcolor"</span> <span class="string">"bg"</span>)</span><br><span class="line">        (<span class="string">"breaklines"</span> <span class="string">"true"</span>)</span><br><span class="line">        (<span class="string">"autogobble"</span> <span class="string">"true"</span>)</span><br><span class="line">        (<span class="string">"fontsize"</span> <span class="string">"\\small"</span>)</span><br><span class="line">       )</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2>结合 watchman 模拟异步编译</h2><p>在 Emacs 内编译 tex 虽然方便, 但是对于编译较大的文档, 或者交叉引用需要多次编译时, 编译动作需要较长的时间. 默认情况下, 编译是在 Emacs 进程内执行的, 这会导致我们在编译时无法进行其他操作, 造成时间的浪费. 在 Linux 下, 可以用 <code>watchman-make</code> 监控 <code>org-directory</code> 下 tex 文件的情况, 一旦有变化就执行 <code>make</code>. <a href="https://facebook.github.io/watchman/docs/watchman-make.html" target="_blank" rel="noopener">watchman-make</a> 是 Facebook 开源项目 <a href="https://facebook.github.io/watchman/" target="_blank" rel="noopener">watchman</a> 的一个组件, 用 Python 编写. 一件需要注意的事情是, 用 Homebrew 安装的 <code>watchman</code>, 在使用时会遇到 <a href="https://github.com/facebook/watchman/issues/631" target="_blank" rel="noopener">name 'basestring' is not defined</a> 错误. 简单的修复办法是, 找到它报错的一行把 <code>basestring</code> 改成 <code>str</code>, 然后就能正常使用了.</p><p>Org-mode 在内部支持异步导出和编译, 但是需要额外编辑异步导出的模板 <code>async-init.el</code>. 笔者稍微调试了一下这个文件, 但并未成功. 在导出元素比较丰富的 org 文档时, 转换本身可能就比较慢, 需要用异步的方式来提高效率. 目前需要还不是很明显, 等以后有机会研究, 届时再作更新.</p><h2>总结</h2><p>本文给出了笔者对 org 文档 LaTeX 导出的基本功能的探索, 对于普通文档的导出应当是够用了. 然而值得推敲和探索的还有很多, 比如异步导出模板, 利用 <code>LATEX_CLASS</code> 实现普通文档和 Beamer 演示导出之间的敏捷切换, 多行多列表格, 以及利用表格和 gnuplot 源代码在 org 文档内直接作图, 等等. 希望之后还有时间精力能把这些分享出来.</p><p>&lt;!-- 在 <code>org-latex-classes</code> 里准备好 <code>beamer</code> 类. 同时, 定义另外一个普通的文档类, 例如名为 <code>beamerarticle</code> 的 article 文档类,并将 <code>beamerarticle</code> 包添加到 class 的序言区 (或 <code>LATEX_HEADER</code>) 内.--&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="LaTeX" scheme="http://shigaro.org/tags/LaTeX/"/>
    
      <category term="Emacs" scheme="http://shigaro.org/tags/Emacs/"/>
    
      <category term="Org-mode" scheme="http://shigaro.org/tags/Org-mode/"/>
    
      <category term="Beamer" scheme="http://shigaro.org/tags/Beamer/"/>
    
  </entry>
  
  <entry>
    <title>fiddle-proof 与拖延症</title>
    <link href="http://shigaro.org/2020/07/19/fiddle-proof/"/>
    <id>http://shigaro.org/2020/07/19/fiddle-proof/</id>
    <published>2020-07-19T08:56:37.000Z</published>
    <updated>2020-07-19T15:44:04.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>捣鼓工具有感.</p></div>&lt;!-- more --&gt;</p><p>在捣鼓 Org-mode 的 $\rm\LaTeX$ 导出时偶然间被 refer 到一封 Org-mode 作者 Carsten Dominik 写的 <a href="https://orgmode.org/list/0277B507-1486-4172-B1C6-1B73B84148DD@science.uva.nl/" target="_blank" rel="noopener">mail-list</a> 下。原文主题是比较 Org 和另一个 GTD 软件 <a href="https://www.taskpaper.com/" target="_blank" rel="noopener">TaskPaper</a> (上一篇《<a href="/2020/07/01/macos-float-window/" title="在 macOS 中置顶窗口">在 macOS 中置顶窗口</a>》就是为了这个软件). 大意是作为纯文本 GTD, Org-mode 就是 TaskPaper. Org-mode 诚然提供了大量功能，但这并非强迫用户去使用。用户更不需要从一开始就去 (学其他人) 构建一个繁杂的 GTD 系统。更好的办法是从最基本的 TODO 和 DONE 开始，根据自己需求慢慢扩展.</p><p>笔者是赞同这个观点的。复杂的待办系统要对待办分类，加优先级，加标签，周期重复等等。这么做的终极目的是把事务做清晰的划分，方便筛选以避开来自冗余信息的影响。然而这个复杂的系统本身就可能成为 &quot;冗余信息&quot;. 别人的 GTD 系统，在自己身上可能完全是 nonsense. 与其从头理解然后套用，不如构建一个适合自己的系统。亲切和趁手比什么都重要.</p><p>让我感触最深的并不是这个观点，而是 Carsten 引出 Org-mode 高度可定制的优势时说的一句</p><blockquote><p>What is so great about taskpaper that it is (so far?) almost fiddle-proof. It is a list, and there is no way to fiddle with it. People who use fiddling with the TODO system as a way to procrastinate can clearly benefit from such a system.</p></blockquote><p>&quot;fiddle&quot; 有摆弄、把玩 (瞎搞) 的意思，而 proof 后缀表示 &quot;protecting against&quot;, 合起来就是 &quot;不给瞎搞&quot;. 跟 org-mode 相比，TaskPaper 能鼓捣的内容确实少：它支持标签 (<code>@</code>), 但不支持多种 TODO 标记，也不支持事项的作业计时 (org-mode 下有 <code>org-clock-in/out</code>), 更不用提各种代码块、导出功能。第二句 &quot;借鼓捣 GTD 系统来拖延的人显然可因此获益.&quot; 想起在 DDL 面前依然去折腾各种新旧工具和软件的自己，这一句十分扎心。特别当这些工具中的很多现在其实已经不怎么用的时候，当初 fiddling 只为拖延似乎就千真万确、难以辩驳了.</p><p>然而 TaskPaper 真的能帮助人不去 procrastinate 吗？即便是 Carsten 认为 &quot;fiddle-proof&quot; 的 TaskPaper, 我也折腾了 macOS 窗口置顶，花了不少时间做 CSS 定制，而不是去做那些 TODO 们。在看到 Org-mode 后转去鼓捣 Emacs 这一深坑，TaskPaper 自然而然被忘在了角落。</p><p>一个人如果想 procrastinate, 他总可以找到无数的办法。即使是 fiddle-proof 的东西他也能找到把玩的角度。要是手头上的东西不足以让他继续 procrastinate，他就会去找新的。今天云《对马岛之魂》时还听到这样一句话: &quot;成事在人，而非刀剑.&quot; 可能不是非常恰当，但对于任何现代工具也是一样：工具始终只是工具，解决问题的只能是人。而 Procrastinator 不是不想解决问题。他们是对真正重要的问题选择了视而不见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Comment" scheme="http://shigaro.org/categories/Comment/"/>
    
    
      <category term="GTD" scheme="http://shigaro.org/tags/GTD/"/>
    
      <category term="Org-mode" scheme="http://shigaro.org/tags/Org-mode/"/>
    
      <category term="note-taking" scheme="http://shigaro.org/tags/note-taking/"/>
    
      <category term="TaskPaper" scheme="http://shigaro.org/tags/TaskPaper/"/>
    
  </entry>
  
  <entry>
    <title>修改 macOS 上外设键盘的键位映射</title>
    <link href="http://shigaro.org/2020/07/18/remap-macos-keys/"/>
    <id>http://shigaro.org/2020/07/18/remap-macos-keys/</id>
    <published>2020-07-18T08:05:58.000Z</published>
    <updated>2020-07-20T01:51:10.610Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>用 <code>hidutil</code> 对 macOS 外设键盘改键，并设置开机自启.</p></div>&lt;!-- more --&gt;</p><h2>前言</h2><p>最近在用 Emacs 编写文本时遇到的一个问题就是频繁地缩回小拇指去按左 ctrl 很不方便。因此想着把大小写锁定键改成 ctrl. 在 macOS 上，修改内置键盘键位是比较容易的，<code>系统偏好</code> =&gt; <code>键盘</code> =&gt; <code>修饰键</code>, 就可以随便改。但这一修改不会应用到外接键盘上 (笔者用的是 Logi MX Keys). <a href="https://mic-kul.com/2020/01/25/mx-keys-remap-right-alt/" target="_blank" rel="noopener">搜索</a> 后发现可以用 <code>hidutil</code> 解决这个问题.</p><h2>修改外设键盘映射</h2><p>手册上，<code>hidutil</code> 被解释为用于管理人机接口设备 (Human Interface Device, HID) 事件系统的实用程序。我理解的 HID 就是键鼠，手柄，方向盘之类。修改键位需要用到它的 <code>property</code> 命令，通过脚本来说明可能更加直接。编写 <code>remap_keyboard.sh</code> 脚本</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">hidutil property --matching <span class="string">'&#123;"Product": "MX Keys"&#125;'</span> \</span><br><span class="line">    --<span class="built_in">set</span> <span class="string">'&#123;"UserKeyMapping": [&#123;"HIDKeyboardModifierMappingSrc":0x700000039,</span></span><br><span class="line"><span class="string">                                "HIDKeyboardModifierMappingDst":0x7000000e0&#125;]&#125;'</span></span><br></pre></td></tr></table></figure></p><p>选项的具体含义可通过 <code>hidutil property --help</code> 了解。这里做一些简单说明</p><ul><li><code>--matching</code> 选项用来匹配需要修改的外设，值是一个字典。这里用的 Key 是产品名 <code>Product</code>. 如果不知道产品名，可以用 <code>hidutil list</code> 了解设备情况. RegistryID 等信息也能从这里看到.</li><li><code>--set</code> 用来设置属性值。相应的，提取属性是 <code>--get</code>.</li><li>改键对应的 Key 是 <code>UserKeyMapping</code>, 值是一个列表。列表中每一个元素是一个字典。这里用于映射修饰键的 Key 是 <code>HIDKeyboardModifierMappingSrc</code> 和 <code>HIDKeyboardModifierMappingDst</code>. 通俗的说，<code>Src</code> 是键盘上的键，<code>Dst</code> 是机器实际接收的按键，用 16 进制数表示。键位值是 <code>0x700000000</code> 加上对应的 Usage ID, 可以在 <a href="https://developer.apple.com/library/archive/technotes/tn2450/_index.html" target="_blank" rel="noopener">Apple 文档</a> 上查到. CapsLock 是 <code>39</code>, 左 Ctrl 是 <code>e0</code>.</li></ul><p>写完后，加上权限运行即可</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x remap_keyboard.sh</span><br><span class="line">./remap_keyboard.sh</span><br></pre></td></tr></table></figure></p><h2>开机自启</h2><p>系统重启后，映射会失效。所以需要把它写进开机自启动项里。可以用 Automator 的 App, 也可以用 <code>launchctl</code>. 参考 <a href="https://stackoverflow.com/questions/6442364/running-script-upon-login-mac" target="_blank" rel="noopener">SO 回答</a>, 编写 plist</p><p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple Computer//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.user.loginscript<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>/path/to/remap_keyboard.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>命名为 <code>com.user.loginscript.plist</code>, 保存到 <code>~/Library/LaunchAgents</code> 下。然后用 <code>launchctl</code> 修改启动项</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">launchctl load ~/Library/LaunchAgents/com.user.loginscript.plist</span><br></pre></td></tr></table></figure></p><p>重启测试似乎并没有成功 (*/ω＼*) 索性放到 bin 下，发现 capslock 恢复后就手动运行，倒也算是解决了吧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
      <category term="keyboard" scheme="http://shigaro.org/tags/keyboard/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 笔记 (二) —— 初识 Org-mode</title>
    <link href="http://shigaro.org/2020/07/02/emacs-2/"/>
    <id>http://shigaro.org/2020/07/02/emacs-2/</id>
    <published>2020-07-01T23:55:07.000Z</published>
    <updated>2020-10-01T12:02:52.054Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>有关 Org-mode 基本使用的学习笔记.</p></div>&lt;!--more--&gt;</p><p>在使用 Org-roam 前首先是学习 Org-mode 的使用。这里大量参考了 Zaiste 的 <a href="https://www.youtube.com/watch?v=rCMh7srOqvw&amp;list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj" target="_blank" rel="noopener">Doom Emacs 系列视频</a>, 特别是 E09-E13.</p><h2>Org 文件</h2><p>任何格式的纯文本都可以用 Org-mode 打开。在打开 <code>.org</code> 后缀文件时，Emacs 会自动启用 Org-mode. 与 Markdown 和 rST 等轻量标记语言类似，org 文件也需要一些标记符号来激活它的功能.</p><table><thead><tr><th>标记符号</th><th>作用</th></tr></thead><tbody><tr><td><code>*</code></td><td>层级标题</td></tr><tr><td><code>+</code></td><td>无序列表</td></tr><tr><td><code>&lt;&lt;nanme&gt;&gt;</code></td><td>id 为 <code>name</code> 的锚</td></tr><tr><td><code>[[name]]</code></td><td>指向 <code>name</code> 的内链接</td></tr><tr><td><code>[[target][desp]]</code></td><td>文本 <code>desp</code> 具有指向 <code>target</code> 的链接。可以是外链</td></tr><tr><td><code>*text*</code></td><td>加粗</td></tr><tr><td><code>_text_</code></td><td>下划线</td></tr><tr><td><code>*text*</code></td><td>高亮</td></tr><tr><td><code>+text+</code></td><td>删除</td></tr><tr><td><code>/text/</code></td><td>斜体</td></tr><tr><td><code>=text=</code></td><td>打字机 (verbatim) 模式</td></tr><tr><td><code>~text~</code></td><td>代码模式</td></tr></tbody></table><p>在导出时，打字机和代码模式都统一导出为打字机模式各种强调记号可以通过 <code>org-emphasis-alist</code> 变量进行自定义.</p><h2>按键操作</h2><p>一些会经常用到的捆绑键位，作为简单的 cheatsheet</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>M-↑/↓</code></td><td>上下移动整个层级</td></tr><tr><td><code>M-h</code></td><td>上升一个层级</td></tr><tr><td><code>M-l</code></td><td>下降一个层级</td></tr><tr><td><code>C-RET</code></td><td>在下方插入新条目 (表格，清单)</td></tr><tr><td><code>C-s-RET</code></td><td>在上方插入新条目 (表格，清单)</td></tr><tr><td><code>SPC m l l</code></td><td>创建 / 编辑链接</td></tr><tr><td><code>SPC m l d</code></td><td>移除链接</td></tr><tr><td><code>SPC n l</code></td><td>为选定文本制作书签，存入链接库备选</td></tr><tr><td><code>SPC m '</code></td><td>为选中元素调用特殊编辑器</td></tr><tr><td><code>RET</code></td><td>转到链接目标</td></tr><tr><td><code>D</code> (大写 D)</td><td>返回链接位置</td></tr><tr><td><code>C-C C-x C-n/p</code></td><td>下 / 上一个链接位置</td></tr></tbody></table><p>一个小贴士是，可以用 <code>M-x general-describe-keybindings</code> 确认一个捆绑键对应的函数.</p><h2>org 文件编辑</h2><h3>创建链接</h3><p>Org-mode 尤其有用的功能是其方便的内链创建.</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Heading 1</span><br><span class="line">  ** Subheading 1</span><br><span class="line">    This is link to [[Heading 2]]</span><br><span class="line">    这是一个锚 &lt;&lt;anchor&gt;&gt;</span><br><span class="line"></span><br><span class="line">  ** Subheading 2</span><br><span class="line">    跳转到锚 [[anchor]]</span><br><span class="line"></span><br><span class="line">* Heading 2</span><br><span class="line">  Go to [[https://www.google.com][Google.com]]</span><br></pre></td></tr></table></figure></p><p>此外，Org-mode 支持多种 <a href="https://orgmode.org/manual/External-Links.html#External-Links" target="_blank" rel="noopener">外部链接</a>. 除内链和网页外还支持本地文件 <code>file:</code>, <code>doi:</code>, Emacs Lisp 脚本 <code>elisp:</code> 以及 Shell 脚本 <code>shell:</code> 等。它允许自定义链接，例如在 <code>config.el</code> 中加入下列代码可以创建由 AV 或 BV 号到 b 站视频的链接 <code>blbl:</code></p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 创建连接 bilibili 视频的链接</span></span><br><span class="line">(<span class="name">defun</span> make-bilibili-link (<span class="name">vid</span>)</span><br><span class="line">  (<span class="name">browse-url</span> (<span class="name">concat</span> <span class="string">"https://www.bilibili.com/video/"</span> vid))  </span><br><span class="line">)</span><br><span class="line">(<span class="name">after!</span> org</span><br><span class="line">  (<span class="name">org-add-link-type</span> <span class="string">"blbl"</span> #'make-bilibili-link)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h3>可执行代码块</h3><p>输入 <code>&lt;s</code> 后 <code>TAB</code>, 创建一个如下环境，可在其中编写代码.</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+BEGIN_SRC LANG</span><br><span class="line">//code here</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure></p><p>比如我们在其中用 C 编写 Hello World:</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+BEGIN_SRC c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">  printf (&quot;Hello World!&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure></p><p>编写完成后，退出编辑模式。在 <code>END_SRC</code> 下回车，就会自动将输出结果添加到源代码块下方.</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">: Hello World!</span><br></pre></td></tr></table></figure></p><p>如果改变了代码的内容，只要选中代码块任意位置重新回车，即可更新输出结果. <span class="label label-info">Q</span> <code>#+RESULTS</code> 部分似乎不会被导出，有待确认)</p><h3>LaTeX 导出初探</h3><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>C-c C-e l l</code></td><td>导出.org 文件到.tex 文件</td></tr><tr><td><code>C-c C-e l L</code></td><td>将.org 文件导出为 tex, 加载到新缓冲区</td></tr><tr><td><code>C-c C-e l p</code></td><td>导出.org 文件到.tex 文件，并转换为 pdf</td></tr><tr><td><code>C-c C-e l o</code></td><td>导出.org 文件到.tex 文件，转换为 pdf 同时用默认浏览器打开</td></tr></tbody></table><p>在用 LaTeX 导出时，用如下代码块包围的内容会被直接导出</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#+BEGIN_LATEX</span><br><span class="line">\LaTeX</span><br><span class="line">#+END_LATEX</span><br></pre></td></tr></table></figure></p><p>导出结果为</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\LaTeX</span><br></pre></td></tr></table></figure></p><h2>相关文章</h2><p><a href="/2020/07/01/emacs-1/" title="Emacs 笔记 (一) —— 安装与配置 Doom Emacs">Emacs 笔记 (一) —— 安装与配置 Doom Emacs</a></p><h2>参考资料</h2><p>Org-mode 官方手册: <a href="https://orgmode.org/manual/" target="_blank" rel="noopener">https://orgmode.org/manual/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-warning&quot;&gt;&lt;i class=&quot;fa fa-bell  float-left&quot;&gt;&lt;/i&gt;  
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="Emacs" scheme="http://shigaro.org/tags/Emacs/"/>
    
      <category term="Org-mode" scheme="http://shigaro.org/tags/Org-mode/"/>
    
      <category term="note-taking" scheme="http://shigaro.org/tags/note-taking/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 中置顶窗口</title>
    <link href="http://shigaro.org/2020/07/01/macos-float-window/"/>
    <id>http://shigaro.org/2020/07/01/macos-float-window/</id>
    <published>2020-07-01T09:40:49.000Z</published>
    <updated>2020-07-01T15:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>使用 MacForge 和 AfloatX 插件, 在 Mojave 系统下允许窗口置顶.</p></div>&lt;!--more--&gt;</p><h2>前言</h2><p>macOS 上一直困扰我的问题是没有简单的窗口置顶工具. 在 PC 下, 播放器之类的很多软件在任务栏上都有一个小图钉图标, 点一下就可以置顶. 但是 macOS 上竟然找不到自带这样功能的软件. 这归因于自 Mac OS El Capitan 以后苹果引入的系统完整性保护 (System Integrity Protection, SIP). 根据<a href="https://en.wikipedia.org/wiki/System_Integrity_Protection#Functions" target="_blank" rel="noopener">维基百科</a>, SIP 禁止用户对根目录下 <code>/System</code> 和 <code>/usr</code> 等特定文件夹的修改, 关闭代码注入和运行时进程附着, 禁止未签名的内核扩展. 由此看来, 将窗口置顶可能涉及向Finder运行时进行代码注入从而被 SIP 禁止, 因此按正常流程发布的 app 就不可能实现这个功能了. 但另一方面, 窗口置顶是否有可能通过由 app 发送置顶请求到 Finder, Finder 向用户一次性请求权限的方式来实现呢? 这就要看今后 Apple 的 macOS 更新了.</p><p>可是对于 Mojave 来说恐怕等不到那个时候, 所以还是得自己想办法. <a href="https://www.maketecheasier.com/mac-keeping-your-application-window-always-on-top/" target="_blank" rel="noopener">这篇文章</a>提供了比较完整的思路, 主要是利用 mySIMBL 进行代码注入, 置顶功能由 <a href="https://github.com/rwu823/afloat" target="_blank" rel="noopener">Afloat</a> 提供. 有点遗憾的是, 这篇文章时间比较久远了, mySIMBL 已经升级成了 <a href="https://github.com/MacEnhance/MacForge" target="_blank" rel="noopener">MacForge</a>, Afloat 数年没有更新, 几乎被 <a href="https://github.com/jslegendre/AfloatX" target="_blank" rel="noopener">AfloatX</a> 取代. 不过基本思路没有变化, 就在这里简单记录一下流程.</p><h2>流程记录</h2><h3>Step 1 部分关闭SIP</h3><p>这一部分在 <a href="https://github.com/MacEnhance/MacForge/wiki/Installation" target="_blank" rel="noopener">MacForge Wiki 页</a>上有充分的描述. 重启, 按住 <code>CMD+R</code> 进入 recovery mode. 从左上角菜单栏打开终端, 输入以下部分关闭 SIP 的命令</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">csrutil enable --without fs --without nvram --without debug</span><br></pre></td></tr></table></figure></p><p><code>without</code> 选项指定禁止的 SIP 功能. 对应内容可由直接输入 <code>csrutil</code> 来理解</p><p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ csrutil</span><br><span class="line">System Integrity Protection status: enabled (Custom Configuration).</span><br><span class="line">Configuration:</span><br><span class="line">    Apple Internal: disabled</span><br><span class="line">    Kext Signing: enabled</span><br><span class="line">    Filesystem Protections: disabled</span><br><span class="line">    Debugging Restrictions: disabled</span><br><span class="line">    DTrace Restrictions: enabled</span><br><span class="line">    NVRAM Protections: disabled</span><br><span class="line">    BaseSystem Verification: enabled</span><br><span class="line"></span><br><span class="line">This is an unsupported configuration, likely to break in the future and leave your machine in an unknown state.</span><br></pre></td></tr></table></figure></p><p><code>fs</code> 指文件系统保护, <code>debug</code> 指调试限制, <code>nvram</code> 指非易失性存储器 (<a href="https://en.wikipedia.org/wiki/Non-volatile_random-access_memory" target="_blank" rel="noopener">Non-volatile random-access memory</a>, NVRAM) 保护. NVRAM 是内存的一部分, 用于存储快速访问的设置, 包括<a href="https://support.apple.com/zh-cn/HT204063" target="_blank" rel="noopener">内核崩溃信息</a>.</p><h3>Step 2 安装MacForge</h3><p>解压 GitHub 中<a href="https://github.com/w0lfschild/app_updates/raw/master/MacForge/MacForge.zip" target="_blank" rel="noopener">最新发布的压缩包</a>, 然后将 <code>.app</code> 移到应用程序中.</p><h3>Step 3 安装AfloatX</h3><p>打开 MacForge, 从 Featured 页面找到 AfloatX, GET 即可.</p><p><figure class="null"><img src="plugin.png" alt=" "><figcaption> </figcaption></figure></p><h3>Step 4 置顶窗口</h3><p>打开想要置顶的窗口, 右击对应 app 的 Dock 图标, 在 AfloatX 里选择 <code>Float Window</code>, 窗口置顶就完成了. 关闭一次窗口重新打开, 就可以取消置顶.</p><p><figure class="null"><img src="float-taskpaper.png" alt=" "><figcaption> </figcaption></figure></p><p>完工 (ง •̀_•́)ง 置顶 GTD app 窗口对于健忘+拖延的我来说就是救命恩人 (bushi).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
      <category term="MacForge" scheme="http://shigaro.org/tags/MacForge/"/>
    
      <category term="Afloatx" scheme="http://shigaro.org/tags/Afloatx/"/>
    
      <category term="GTD" scheme="http://shigaro.org/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 笔记 (一) —— 安装与配置 Doom Emacs</title>
    <link href="http://shigaro.org/2020/07/01/emacs-1/"/>
    <id>http://shigaro.org/2020/07/01/emacs-1/</id>
    <published>2020-07-01T06:51:07.000Z</published>
    <updated>2020-10-01T11:40:52.530Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>记录从零开始的 Emacs. 目标是熟练地使用 Org-roam 编辑个人维基!</p></div>&lt;!-- more --&gt;</p><h2>前言</h2><p>因缘巧合, 今日我在搜索转化$\rm\LaTeX$到MathML的解决方案时, 偶然看到了<a href="https://github.com/org-roam/org-roam" target="_blank" rel="noopener">Org-roam</a>项目. 它的个人知识库构建和展示方式引起了我很大的兴趣.</p><p>Org-roam 基于 Emacs 的 Org-mode, 后者是 Emacs 中纯文本笔记管理+GTD+写作系统. &quot;Org&quot; 指代 organize, &quot;roam&quot; 则取自<a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam Research</a>. Org-roam 采纳了 <a href="https://zettelkasten.de/" target="_blank" rel="noopener">Zettelkasten笔记法</a>的思想.&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;Zettelkasten是一个德语词, 对应英语slip box, 类似于图书馆存放索引卡的盒子.&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; 这种方法认为知识不是层级化的而是扁平化的, 重要的是知识之间的关联. 这种关联通过笔记中用<code>[[...]]</code>包围的关键词建立. Org-roam能对这种连接进行可视化.</p><p><figure class="null"><img src="org-roam-graph-demo.png" alt="Graph view, from Org-roam GitHub site"><figcaption>Graph view, from Org-roam GitHub site</figcaption></figure></p><p>相比较其他 Zettelkasten 实现, Org-roam 的特点是</p><ol><li>完全免费开源, 数据库本地存储而不是封存托管在企业云端数据库.</li><li>基于 Org-mode 纯文本系统, 可利用 Emacs 生态扩展.</li><li>配置复杂, 学习曲线陡峭.</li></ol><p>一直以来也接触过挺多笔记记录的方式, Agenda, Bear, OneNote, Notion, 甚至是本地文件夹, 但总是觉得不得劲. 现在又多了这样一种选择, 自然还是想试一下. 然而作为 Vim 用户, 第一个应该跨过的关卡应该是 Emacs 的基本使用. 现在就说道说道吧.</p><h2>安装</h2><h3>Doom Emacs</h3><p>从安装开始. 为免去 Emacs 基本设置, 在<a href="https://www.youtube.com/watch?v=Lg61ocfxk3c" target="_blank" rel="noopener">Matt Williams</a>的推荐下安装 <a href="https://github.com/d12frosted/homebrew-emacs-plus" target="_blank" rel="noopener">emacs-plus</a> 和 <a href="https://github.com/hlissner/doom-emacs" target="_blank" rel="noopener">Doom Emacs</a>. 通过 Homebrew 安装 Emacs</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap d12frosted/emacs-plus</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若出现403错误, 在前面加上all_proxy=socks5://127.0.0.1:1086</span></span><br><span class="line">brew install emacs-plus@27 --with-modern-icon-cg433n</span><br><span class="line">ln -s /usr/local/opt/emacs-plus/Emacs.app /Applications/Emacs.app</span><br></pre></td></tr></table></figure></p><p>完成后再从 GitHub 安装 Doom Emacs</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d</span><br><span class="line">~/.emacs.d/bin/doom install</span><br></pre></td></tr></table></figure></p><p>此时命令行打开 Emacs, 可以看到下面这样十分炫酷的界面. 这跟我印象里面一个大白框UI迥然不同.</p><p><figure class="null"><img src="doom-ui.png" alt="Doom Emacs UI"><figcaption>Doom Emacs UI</figcaption></figure></p><p>Doom Emacs 安装完后, 编辑 <code>~/.doom.d/</code> 下 <code>init.el</code> 文件, 打开或关闭一些 Doom 模块. 一些模块包含可选功能, 需要通过 <code>+</code> 指定, 例如打开 <a href="https://orgmode.org/" target="_blank" rel="noopener">Org-mode</a> 的可选功能</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">doom!</span> <span class="symbol">:lang</span></span><br><span class="line">  (<span class="name">org</span> +brain</span><br><span class="line">       +dragdrop</span><br><span class="line">       +gnuplot</span><br><span class="line">       +jupyter)      <span class="comment">; organize your plain life in plain text</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p><p>在 <code>~/.doom.d/packages.el</code> 下用 <code>package!</code> 命令指定安装 ELPA/MELPA 上的插件包,&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top hint--error hint--medium hint--rounded hint--bounce&quot; aria-label=&quot;ELPA: 全称Emacs Lisp Package Archive, Emacs默认的软件包存储库. MELPA = Milkypostman ELPA&quot;&gt;[2]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt; 例如</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; 安装ELPA或者MELPA上的包</span></span><br><span class="line">(<span class="name">package!</span> markdown-mode)</span><br><span class="line"><span class="comment">;; 从GitHub仓库安装最新版markdown-mode</span></span><br><span class="line">(<span class="name">package!</span> markdown-mode</span><br><span class="line"> <span class="symbol">:recipe</span> (<span class="symbol">:host</span> github <span class="symbol">:repo</span> jrblevin/markdown-mode))</span><br></pre></td></tr></table></figure></p><p>设置完后运行</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/.emacs.d/bin/doom sync</span><br></pre></td></tr></table></figure></p><p>以应用两个文件的变化. 如果遇到安装问题, 可在 <code>packages.el</code> 中注释掉对应代码, 命令行执行</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">doom purge</span><br></pre></td></tr></table></figure></p><p>卸载程序包, 再反注释掉, 重新安装即可.</p><h3>Org-roam</h3><p>Org-roam 的安装可以采用 <code>+</code> 方式安装 (<a href="https://orgroam.slack.com/archives/CV160S8EL/p1590857012127400" target="_blank" rel="noopener">slack讨论</a>)</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">doom!</span> <span class="symbol">:lang</span></span><br><span class="line">  (<span class="name">org</span> +roam)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></p><p>也可以在 <code>packags.el</code> 中加入</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">package!</span> org-roam)</span><br><span class="line">(<span class="name">package!</span> company-org-roam) <span class="comment">;org-roam相关的代码补全</span></span><br></pre></td></tr></table></figure></p><p>安装. 随后在 <code>config.el</code> 中用 <code>use-package!</code> 函数配置</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">use-package!</span> org-roam</span><br><span class="line">  <span class="symbol">:commands</span> (<span class="name">org-roam-insert</span> org-roam-find-file org-roam)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> org-roam-directory <span class="string">"~/Documents/SelfDevelopment/org-roam/"</span>)</span><br><span class="line">  (<span class="name">setq</span> org-roam-graph-viewer <span class="string">"/usr/bin/open"</span>)</span><br><span class="line">  (<span class="name">map!</span> <span class="symbol">:leader</span></span><br><span class="line">  <span class="symbol">:prefix</span> <span class="string">"r"</span></span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Insert"</span> <span class="string">"i"</span> #'org-roam-insert</span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Find"</span>   <span class="string">"/"</span> #'org-roam-find-file</span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Buffer"</span> <span class="string">"r"</span> #'org-roam)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">org-roam-mode</span> <span class="number">+1</span>))</span><br><span class="line">(<span class="name">add-hook</span> 'after-init-hook 'org-roam-mode)</span><br></pre></td></tr></table></figure></p><p>随后打开 Emacs, <code>M-x org-roam-find-file</code> 或 <code>SPC r /</code>, 会检查 <code>org-roam-directory</code> 下的所有 org 文件. 输出文件名进行编辑或者新建</p><p><figure class="null"><img src="first_file.png" alt=" "><figcaption> </figcaption></figure></p><p>编辑完后 <code>C-c C-c</code> 保存. 对于 config 中不了解的函数, 可以输入 <code>SPC(空格) h f</code> 来查询.</p><p>更进一步的 Org-mode, Org-roam 配置和使用将会在今后的文章中记录. 在本文接下来部分中仅涉及 Emacs 编辑和指令的基本使用.</p><h2>Emacs使用</h2><p><a href="https://www.youtube.com/watch?v=rCMh7srOqvw&amp;list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj" target="_blank" rel="noopener">Zaiste</a> 制作了一系列非常好的 Youtube 视频介绍 Doom Emacs 和 Org-mode 的使用, 这里的记录基本上是练习他的 Doom 视频内容的整理.</p><h3>文件操作</h3><p>Dired 模式下可以对文件夹与文件进行操作.</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>-</code>/<code>RET</code></td><td>进入上层/子文件夹</td></tr><tr><td><code>+</code></td><td>新建文件夹</td></tr><tr><td><code>d x</code></td><td>标记要删除的文件(夹), 执行删除</td></tr><tr><td><code>o</code></td><td>排序</td></tr><tr><td><code>M</code></td><td>修改文件权限</td></tr><tr><td><code>O</code></td><td>修改文件owner</td></tr><tr><td><code>m</code>/<code>u</code></td><td>选择/取消选择文件</td></tr><tr><td><code>U</code></td><td>取消所有选择</td></tr><tr><td><code>R</code></td><td>重命名/移动文件</td></tr><tr><td><code>C</code></td><td>复制文件</td></tr><tr><td><code>c</code></td><td>压缩选中文件</td></tr></tbody></table><h3>常用键位和命令</h3><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>SPC .</code></td><td>打开或创建文件 (在文本编辑模式下直接回车, 相当于Vim的<code>:q</code>)</td></tr><tr><td><code>SPC f r</code></td><td>打开最近文件</td></tr><tr><td><code>SPC o i</code></td><td>在iTerm中打开当前文件夹</td></tr><tr><td>修饰键<code>C</code></td><td>Mac上为Ctrl键</td></tr><tr><td>修饰键<code>M</code></td><td>Mac上为Alt键 (在Doom中如果是第一个输入, CMD键也可以)</td></tr><tr><td>修饰键<code>s</code></td><td>Mac上为CMD键</td></tr><tr><td><code>M-x shell</code></td><td>在Emacs中打开shell(全屏)</td></tr><tr><td><code>SPC o T</code></td><td>在Emacs中打开vterm(全屏)</td></tr><tr><td><code>SPC o t</code></td><td>在Emacs中弹出vterm小窗</td></tr></tbody></table><p>如果想将vterm的默认shell设为zsh需要在<code>config.el</code>中加入</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line"><span class="comment">;; set zsh to default shell of vterm</span></span><br><span class="line">(<span class="name">use-package!</span> vterm</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> vterm-shell <span class="string">"zsh"</span>))</span><br></pre></td></tr></table></figure></p><p>此时可以用 <code>SPC o T</code> 打开 vterm, 使用的是 zsh.</p><h3>缓冲区和窗口操作</h3><p>和 Vim 类似, 打开文件时, Emacs 会打开一个缓冲区 (buffer), 载入当前文件的所有内容. 所有编辑都在 buffer 中进行. 但 buffer 不必一定是文件, 它也可以是 shell, 或者 Dired 文件树等等.</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>SPC b N</code> 或 <code>CMD-n</code></td><td>新建缓冲区</td></tr><tr><td><code>SPC b k</code> 或 <code>CMD-k</code></td><td>杀死当前缓冲区</td></tr><tr><td><code>SPC b b</code> 或 <code>SPC ,</code></td><td>切换工作区缓冲区</td></tr><tr><td><code>SPC b B</code> 或 <code>SPC &lt;</code></td><td>切换全局缓冲区</td></tr><tr><td><code>C-w v</code></td><td>水平复制缓冲区到新窗口</td></tr><tr><td><code>C-w s</code></td><td>垂直复制缓冲区到新窗口</td></tr><tr><td><code>C-w w</code></td><td>转到下一个缓冲区窗口</td></tr><tr><td><code>C-w h/j/k/l</code></td><td>Vi式窗口转移</td></tr><tr><td><code>C-w q</code></td><td>关闭窗口</td></tr><tr><td><code>C-w &gt;/&lt;</code></td><td>向右/左扩展窗口</td></tr><tr><td><code>C-w +/-</code></td><td>向上/下扩展窗口</td></tr><tr><td><code>C-w =</code></td><td>使所有窗口等宽等高</td></tr></tbody></table><h3>文本编辑命令</h3><p>这里文本编辑想表达的是类似 Vim 中文本操作键位和 command mode 下的命令(<code>:</code>). 好在 Doom Emacs 将许多 Vim 与 Emacs 命令绑定在了一起, 省去了学习 Emacs原生编辑操作的麻烦. 同时 Domm Emacs 额外提供了许多方便的编辑命令</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>C-x k</code></td><td>关闭buffer但不保存, 类似Vim <code>:q!</code>. 如果直接输入<code>:q</code>将会关闭整个Emacs</td></tr><tr><td><code>g s SPC STR</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转</td></tr><tr><td><code>g s SPC STR x</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转并剪切</td></tr><tr><td><code>g s SPC STR i</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转并提供ispell修改意见</td></tr></tbody></table><h3>Markdown编辑和预览</h3><p>Markdown 文件的文本渲染和快速编辑可以使用 <a href="https://jblevins.org/projects/markdown-mode/" target="_blank" rel="noopener">markdown-mode</a>. <a href="https://blog.bitsandbobs.net/blog/emacs-markdown-live-preview/" target="_blank" rel="noopener">Markus Opitz</a> 基于 <code>simple-httpd</code> 包实现了一个 HTTP 服务器实时预览的功能. 编辑命令可参考这个 <a href="https://cheatography.com/xaon/cheat-sheets/emacs-markdown-mode/" target="_blank" rel="noopener">Cheatsheet</a>.</p><h2>Troubleshooting</h2><h3>GitHub图标显示不正常</h3><p>安装完后打开 Doom Emacs, 首页上的 GitHub 图标显示有可能<a href="https://github.com/hlissner/doom-emacs/issues/724" target="_blank" rel="noopener">不正常</a>, 此时需要在 Emacs 下安装<code>all-the-icons</code>.</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">M-x all-the-icons-install-fonts</span><br></pre></td></tr></table></figure></p><p>如果出现 403 错误, 可以用 <a href="https://blog.fazero.me/2015/08/31/%E5%88%A9%E7%94%A8proxychains%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">proxychains-ng</a>和 SS 解决</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains4 emacs</span><br></pre></td></tr></table></figure></p><h3><code>Package cl is deprecated</code> 警告</h3><p>在打开 Doom Emacs 后底部会出现这一警告. 原因是在 Emacs 24 后 <code>cl</code> 程序包已经被 <code>cl-lib</code> 取代, 而部分依赖于 <code>cl</code> 的包 (如 <a href="https://github.com/jrblevin/deft/issues/77#issue-616735753" target="_blank" rel="noopener">deft</a>) 未相应更新. 目前除了等待源码更新外, 没有好的解决办法.</p><h3>新建文档时安装 PDF-tools 出错</h3><p>首次用 <code>M-X org-roam-find-file</code> 创建新文件, 会弹出 build epdfinfo 的请求, 确定后自动安装 pdf-tools. 此时出现了 build failed 的情况, 主要错误信息是</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">configure: error: cannot find necessary  poppler-private header (see README.org)</span><br><span class="line">Build failed.  ;o(</span><br></pre></td></tr></table></figure></p><p>解决办法参考这个 <a href="https://github.com/politza/pdf-tools/issues/480#issuecomment-472223334" target="_blank" rel="noopener">issue comment</a>, 从 Homebrew 安装 pdf-tools</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap dunn/homebrew-emacs</span><br><span class="line">brew install --HEAD pdf-tools</span><br></pre></td></tr></table></figure></p><p>然后在 <code>packages.el</code> 中加入</p><p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">package!</span> pdf-tools)</span><br></pre></td></tr></table></figure></p><p>重新打开 Emacs 新建文件, 不需要重新 build epdfinfo了.</p><h2>参考资料</h2><p>Master Emacs in 21 Days: <a href="http://book.emacs-china.org/" target="_blank" rel="noopener">http://book.emacs-china.org/</a></p><p>Emacs Key Bindings: <a href="https://caiorss.github.io/Emacs-Elisp-Programming/Keybindings.html" target="_blank" rel="noopener">https://caiorss.github.io/Emacs-Elisp-Programming/Keybindings.html</a></p><p><a href="http://emacslife.com/read-lisp-tweak-emacs/beginner-3-make-things-more-convenient.html" target="_blank" rel="noopener">How can I customize Emacs to make things more convenient?</a></p><p>Using Emacs Series: <a href="https://cestlaz.github.io/stories/emacs/" target="_blank" rel="noopener">https://cestlaz.github.io/stories/emacs/</a>&lt;div id=&quot;footnotes&quot;&gt;&lt;hr&gt;&lt;div id=&quot;footnotelist&quot;&gt;&lt;ol style=&quot;list-style: none; padding-left: 0; margin-left: 40px&quot;&gt;&lt;li id=&quot;fn:1&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px&quot;&gt;1.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; margin-left: 10px;&quot;&gt;Zettelkasten是一个德语词, 对应英语slip box, 类似于图书馆存放索引卡的盒子.&lt;a href=&quot;#fnref:1&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot;&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px&quot;&gt;2.&lt;/span&gt;&lt;span style=&quot;display: inline-block; vertical-align: top; margin-left: 10px;&quot;&gt;ELPA: 全称Emacs Lisp Package Archive, Emacs默认的软件包存储库. MELPA = Milkypostman ELPA&lt;a href=&quot;#fnref:2&quot; rev=&quot;footnote&quot;&gt; ↩&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-warning&quot;&gt;&lt;i class=&quot;fa fa-bell  float-left&quot;&gt;&lt;/i&gt;  
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
      <category term="Emacs" scheme="http://shigaro.org/tags/Emacs/"/>
    
      <category term="Org-roam" scheme="http://shigaro.org/tags/Org-roam/"/>
    
  </entry>
  
  <entry>
    <title>Hexo笔记(二)——显示博文修改时间等</title>
    <link href="http://shigaro.org/2020/06/30/hexo-2-update-time/"/>
    <id>http://shigaro.org/2020/06/30/hexo-2-update-time/</id>
    <published>2020-06-30T04:12:12.000Z</published>
    <updated>2020-07-01T04:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>给Freemind主题增加显示博文修改时间的功能. 用hexo-browsersync实现server模式实时预览.</p></div>&lt;!-- more --&gt;</p><h2>背景</h2><p>在网上浏览博文的时候, 经常可以看到一些Hexo生成的站点文章有最后修改时间的属性, 所以一直以来都想给自己的博文增加这样的功能. 可惜拖着拖着到现在才想着实践. 原本想着只要在front matter上增加类似<code>update</code>属性, 然后修改ejs让它像<code>date</code>一样在边栏显示就可以了. 但是这样想的时候出现了一点问题, 因为直接从front matter提取的<code>update</code>是字符串, 没有<code>format</code>方法, 也不能传给<code>date()</code>函数. 在看了一些文章后才知道需要先将其转换为<code>moment</code>对象. 那么问题就变成了找到<code>date</code>是在哪里变成<code>moment</code>对象的即可. 另外还想实现的需求是: 如果front matter有<code>updated</code>属性, 则以<code>updated</code>为最后修改时间; 如果没有, 则获取文件的最后修改时间.</p><h2>搜索date moment对象化代码</h2><p>采用正则表达式, <code>find</code>和<code>grep</code>搜索js文件, 寻找<code>date</code>属性的<code>moment</code>实例化</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -regex <span class="string">".*\.js"</span> | xargs grep -E <span class="string">"moment\(.*date)"</span> --color -RnH</span></span><br><span class="line">./node_modules/hexo/lib/plugins/helper/date.js:9:  if (!isMoment(date)) date = moment(isDate(date) ? date : new Date(date));</span><br><span class="line">./node_modules/hexo/lib/hexo/post.js:40:  data.date = data.date ? moment(data.date) : moment();</span><br></pre></td></tr></table></figure></p><p>可以看到<code>date</code>实例化在<code>post.js</code>的40行. 接下来在<code>post.js</code>中加入如下代码使data获得moment对象<code>updated</code>.</p><p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data.updated) &#123;</span><br><span class="line">      data.updated = moment(data.updated);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>但这样还不能满足我们的要求, 即要求<code>updated</code>属性不存在时获取文件最后修改时间, 作为文章最后修改时间. 根据参考资料1, 为获取文件路径, 除了<code>post.js</code>中已经引入的<code>path</code>外, 需要引入<code>child_process</code>库来调用系统的date命令.</p><p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> execSync = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br></pre></td></tr></table></figure></p><p>于是修改上一步中的实例化if语句</p><p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lastMod = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (data.updated) &#123;</span><br><span class="line">    data.updated = moment(data.updated);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 对data.source进行判断, 否则在新建post时会报错</span></span><br><span class="line">  <span class="keyword">if</span> (data.source) &#123;</span><br><span class="line">    fp = pathFn.resolve(config.source_dir, data.source);</span><br><span class="line">    lastMod = execSync(<span class="string">`date -r <span class="subst">$&#123;fp&#125;</span> "+%Y-%m-%d %H:%M:%S"`</span>).toString().trim();</span><br><span class="line">    data.updated = moment(lastMod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    data.updated = data.date;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就使得每一个post对象获得了<code>updated</code>属性.</p><h2>修改meta.ejs</h2><p>得到<code>updated</code>属性后, 只要简单修改<code>layout/_partial/post</code>下的<code>meta.ejs</code>文件即可</p><p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- date --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (item.date) &#123; %&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"meta-widget"</span>&gt;</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-clock-o"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">&lt;%= item.date.format(config.date_format) %&gt; created</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (item.updated) &#123; %&gt;</span><br><span class="line"> &lt;% <span class="keyword">if</span> (date(item.date) != date(item.updated)) &#123; %&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"meta-widget"</span>&gt;</span><br><span class="line">    &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-pencil"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%= item.updated.format(config.date_format) %&gt; last modified</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">   &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p><p>这里额外要求只有当<code>date</code>和<code>updated</code>两者日期不同时, 才显示<code>updated</code>的时间. 效果如下图所示</p><p><figure class="null"><img src="update_time_result.png" alt=" "><figcaption> </figcaption></figure></p><p>完工 (ง •̀_•́)ง</p><h2>Server模式实时预览</h2><p>每次修改博文都要重新hexo generate再server挺麻烦的. 原来用的<a href="https://github.com/hexojs/hexo-livereload" target="_blank" rel="noopener">hexo-livereload</a>已被归档, 现在可以用<a href="https://github.com/hexojs/hexo-browsersync" target="_blank" rel="noopener">hexo-browsersync</a></p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g browsersync</span><br><span class="line">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure></p><p>之后再运行server模式. 当md文件有改动时, localhost页面会自动更新.</p><h2>相关文章</h2><p><a href="/2018/02/15/Hexo-1/" title="Hexo笔记(一)——安装, Markdown写作与主题">Hexo笔记(一)——安装, Markdown写作与主题</a></p><h2>参考资料</h2><ol><li><a href="https://github.com/xcatliu/hexo-filter-date-from-git/blob/master/index.js" target="_blank" rel="noopener">hexo-filter-date-from-git/index.js</a></li><li><a href="https://stackoverflow.com/a/20807343" target="_blank" rel="noopener">SO - Print a file's last modified date in Bash</a></li><li><a href="https://blog.csdn.net/dengxu11/article/details/6947078?utm_source=blogxgwz0" target="_blank" rel="noopener">grep 递归指定文件遍历方法</a></li><li><a href="https://blog.singee.me/2018/05/16/hexo/hexo-auto-refresh/" target="_blank" rel="noopener">Hexo利用browsersync进行自动刷新</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="Hexo" scheme="http://shigaro.org/tags/Hexo/"/>
    
      <category term="Freemind" scheme="http://shigaro.org/tags/Freemind/"/>
    
      <category term="JavaScript" scheme="http://shigaro.org/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>解决macOS上脚本中运行VASP时动态库未载入问题</title>
    <link href="http://shigaro.org/2020/05/09/macos-script-runvasp/"/>
    <id>http://shigaro.org/2020/05/09/macos-script-runvasp/</id>
    <published>2020-05-09T07:30:23.000Z</published>
    <updated>2020-06-29T07:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>解决macOS上脚本中运行程序遇到dyld: Library not loaded报错.</p></div>&lt;!-- more --&gt;</p><h2>背景</h2><p>疫情在家工mo作yu期间, 准备在自己macOS上用VASP做点小的测试. 因为懒得重复输入命令, 于是写了一个最基本的shell脚本</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">mpirun -np 4 vasp_std</span><br></pre></td></tr></table></figure></p><p>第一步载入的是事先写好的VASP相关环境变量. 执行, 结果报错</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/libmkl_intel_lp64.dylib</span><br><span class="line">  Referenced from: /Users/stevezhang/software/sci/vasp/vasp.5.4.4-intel-2018.0.1/common/bin/vasp_std</span><br><span class="line">  Reason: image not found</span><br></pre></td></tr></table></figure></p><p>也即<code>libmkl_intel_lp64.dylib</code>没有加到<code>DYLD_LIBRARY_PATH</code>中. 可比较奇怪的是, 在命令行里echo <code>DYLD_LIBRARY_PATH</code>, 返回的是预期结果.</p><h2>探索与解决</h2><p>写一个非常简单的脚本，检查脚本执行过程中的环境变量.</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">module load intel/2018.1</span><br><span class="line">module load mpich/3.2.1-intel-2018.0.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p><p>运行前线载入<code>intel/2018.1</code>模块. 运行脚本发现:</p><ul><li>在module load前后, <code>LIBRARY_PATH</code>和<code>PATH</code>同echo的预期结果相同.</li><li>在module load前, <code>DYLD_LIBRARY_PATH</code>是空的.</li><li>在load后, 只有未在zshrc里载入的MPICH里定义的库路径被加入到<code>DYLD_LIBRARY_PATH</code>中.</li></ul><p>搜索后找到几个帖子描述类似问题:</p><p><a href="https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here" target="_blank" rel="noopener">https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here</a><a href="https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1" target="_blank" rel="noopener">https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1</a></p><p>问题原因是，从El Captian开始, macOS引入了系统完整性保护(system integrity protection, SIP), 在调用系统提供的解释器时，所有<code>DYLD_</code>环境变量会被重设. 在使用module管理环境时, 因为intel模块事先被载入过, 因此脚本里面载入intel模块的行为会被module无视, 因此只有MPICH中的变量加入到<code>DYLD_LIBRARY_PATH</code>中.</p><p>一种解决办法是, 在最开始的shell脚本里面手动设置<code>DYLD_LIBRARY_PATH</code>, 缺点是不容易复用bashrc或zshrc里的内容. 更方便的做法是在shell脚本里load完所有module后reload一下，</p><p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">module reload</span><br><span class="line"></span><br><span class="line">mpirun -np 4 vasp_std <span class="comment"># success</span></span><br></pre></td></tr></table></figure></p><p>另一种可能的办法是<a href="https://blog.csdn.net/qq285744011/article/details/82219340" target="_blank" rel="noopener">关闭SIP</a>, 不过因为reload完全解决了我的需求, 所以就没有尝试这种稍微麻烦些的办法.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="VASP" scheme="http://shigaro.org/tags/VASP/"/>
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记(四)——使用MathpixOCR API进行LaTeX公式识别</title>
    <link href="http://shigaro.org/2019/10/28/mathpix-ocr/"/>
    <id>http://shigaro.org/2019/10/28/mathpix-ocr/</id>
    <published>2019-10-28T08:39:23.000Z</published>
    <updated>2020-06-30T01:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>编写MathpixOCR API的Python包装器和简单的Automator workflow, 模拟Mathpix Snip Tool的公式识别体验.</p></div>&lt;!-- more --&gt;</p><h2>前言</h2><p>用LaTeX准备文献报告时一个比较头疼的问题是输入文献中包含复杂符号的长公式. <a href="https://mathpix.com/" target="_blank" rel="noopener">Mathpix Snip Tool</a> (MST)提供了方便的光学字符识别功能, 可以将包含公式的截图转化为LaTeX代码. 今年MST从完全免费的1.0版本升级到了2.0, 自此个人用户每月只能免费识别50次, 这对于苦逼PhD显然是不够用的.</p><p>好在作为MST底层的MathpixOCR服务, API每月可免费调用1000次, 所得结果和MST相同, 只是没有MST方便的截图和GUI功能. 归根结底, 我们想实现的无非是识别剪贴板中的公式图片, 转化图片到LaTeX代码并复制到剪贴板而已. 这可以通过将OCR与OS命令包装在一起来实现. 官方提供了简单的<a href="https://github.com/Mathpix/api-examples/tree/master/python" target="_blank" rel="noopener">例子</a>供我们学习OCR API的使用, 而OS API可以通过Python包和CLI命令调用. 这篇文章是学习包装器编写的记录.</p><p>最终脚本已上传到<a href="https://github.com/minyez/mathpixocr_wrapper" target="_blank" rel="noopener">GitHub仓库</a>, 欢迎下载使用.</p><h2>API包装</h2><h3>获取API密钥</h3><p>首先需要在Mathpix上注册用户并填写信用卡信息, 注册后获得<code>app_key</code>和<code>app_id</code>作为API密钥. 脚本采用了两种从外部获取密钥的方式, 一种是环境变量, 另一种是从同路径下JSON读取.</p><h3>从系统剪贴板获取图片</h3><p>使用pillow包中的<code>ImageGrab.grabclipboard</code>获取剪贴版中的图片, 并产生<code>Image</code>对象. 注意, 此后剪贴板中的临时文件会被删除, 无法再直接通过路径获得</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im = ImageGrab.grabclipboard()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(im.filename)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p><p>因此需要先把图片保存下来才能在后续继续使用</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im = ImageGrab.grabclipboard()</span><br><span class="line">fn = <span class="string">".temp_eq.png"</span></span><br><span class="line">im.save(fn, <span class="string">"PNG"</span>)</span><br></pre></td></tr></table></figure></p><h3>base64编码</h3><p>OCR要求图片编码为base64. 编码转换可以参考官方例子</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_uri</span><span class="params">(fn)</span>:</span></span><br><span class="line">  image_data = open(fn, <span class="string">"rb"</span>).read()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"data:image/jpg;base64,"</span> + base64.b64encode(image_data).decode()</span><br></pre></td></tr></table></figure></p><p><code>b64encode</code>使用Base64规则将一串类字节字符串进行编码, <code>decode</code>方法返回编码后的普通字符串.</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec = base64.b64encode(<span class="string">b"abcdefg"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec</span><br><span class="line"><span class="string">b'YWJjZGVmZw=='</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec.decode()</span><br><span class="line"><span class="string">'YWJjZGVmZw=='</span></span><br></pre></td></tr></table></figure></p><h3>调用API</h3><p>通过<code>requests</code>包与OCR API进行通信. 通信数据要求为JSON, 它至少需要包含<code>src</code>和<code>format</code>两个键. <code>src</code>值就是base64编码后的图片字符串, <code>format</code>值为一个列表, 成员为所想要转换的格式, 支持的转化格式包括下面几种.</p><table><thead><tr><th style="text-align:left"><code>format</code>值</th><th style="text-align:left">转化格式</th></tr></thead><tbody><tr><td style="text-align:left"><code>text</code></td><td style="text-align:left">普通文本</td></tr><tr><td style="text-align:left"><code>wolfram</code></td><td style="text-align:left">Mathematica</td></tr><tr><td style="text-align:left"><code>latex_simplified</code></td><td style="text-align:left">简化的latex代码, 括号不包含left或right</td></tr><tr><td style="text-align:left"><code>latex_styled</code></td><td style="text-align:left">left/right控制的latex代码</td></tr></tbody></table><p>利用<code>json</code>包将字典转化成JSON字符串, 用<code>requests</code>发送API请求到<code>v3/latex</code>端点</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = json.dump(&#123;<span class="string">"src"</span>: img_base64, <span class="string">"format"</span>: [<span class="string">"latex_simplified"</span>,]&#125;)</span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  <span class="string">'app_key'</span>: your_app_key,</span><br><span class="line">  <span class="string">'app_id'</span>: your_app_id,</span><br><span class="line">  &#125;</span><br><span class="line">r = requests.post(<span class="string">'https://api.mathpix.com/v3/latex'</span>,</span><br><span class="line">                  data=data, headers=headers)</span><br></pre></td></tr></table></figure></p><p>通信返回的<code>r.text</code>是一个JSON字符串. 如果OCR识别成功, 则它包含<code>latex_simplified</code>键, 对应值为识别号的简化LaTeX代码. 如果识别失败, 则包含<code>error</code>键, 给出具体错误信息. 更复杂的API调用参考<a href="https://docs.mathpix.com/" target="_blank" rel="noopener">官方文档</a>.</p><p><div class="alert alert-info"><i class="fa fa-info  float-left"></i>  <p><code>v3/latex</code>端点目前是旧端点. 官方推荐使用<code>v/3text</code>, 通信所需的JSON关键词有些许不同, 但变化不是很大, 读者可自行参考文档修改. (2020-06-29)</p></div></p><h3>拷贝转化好的LaTeX到系统剪贴板</h3><p>参考了<a href="https://gist.github.com/luqmaan/d8bc61e746207bb12f11" target="_blank" rel="noopener">这个GIST</a>, 使用macOS上的<code>pbcopy</code>将字符串拷贝到系统剪贴板. 另一种办法是直接打印到标准输出, 然后用Automator服务中的功能拷贝到剪贴板.</p><h3>附加功能</h3><p>比如每月API调用统计以及历史记录, 都保存在JSON文件中. 实现说起来比较琐碎, 就不赘述了.</p><h2>Automator服务</h2><p>把写好的包装器放到<code>~/bin</code>下, 编写简单的工作流<code>Mathpix Snip OCR API</code></p><p><figure class="null"><img src="automator_workflow.png" alt=" "><figcaption> </figcaption></figure></p><p>然后在系统设置-键盘-快捷键设置服务的快捷键</p><p><figure class="null"><img src="shortcut.png" alt=" "><figcaption> </figcaption></figure></p><p>如此一来, <code>cmd+shift+4</code>将公式截屏到剪贴板后<code>cmd+shift+M</code>, 等待片刻即可从剪贴板黏贴转换好的公式. 大功告成!</p><h2>黏贴到到Word公式中</h2><h2>参考资料</h2><p>使用pillow包来获取剪贴板图片: <a href="https://zhuanlan.zhihu.com/p/83678942" target="_blank" rel="noopener">Mathpix收费了？快使用API吧，一个月免费识别1000次！</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="LaTeX" scheme="http://shigaro.org/tags/LaTeX/"/>
    
      <category term="MathpixOCR" scheme="http://shigaro.org/tags/MathpixOCR/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记(三)——用pyecharts制作统计地图</title>
    <link href="http://shigaro.org/2019/10/20/speaker-map/"/>
    <id>http://shigaro.org/2019/10/20/speaker-map/</id>
    <published>2019-10-20T14:47:28.000Z</published>
    <updated>2019-10-20T14:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>以会议报告人所在机构的分布为例, 介绍如何基于pyecharts制作地理分布图.</p></div>&lt;!-- more --&gt;</p><h2>前言</h2><p>前段时间去深圳参加一个研究方向有关的会议, 国内做实验和理论研究的老师都来了, 于是心血来潮想有没有可能做一个统计来看看老师们所在机构的地理分布. 虽然报告人并不多, 但应该也能提供一些定性的信息, 也算是学习一种图片制作和数据展示技巧.经过一番搜索, 决定采用Python包<code>pyecharts</code>中的地理图标<code>Geo</code>类来制作. 使用Python版本为3.7.1, pyecharts版本为1.5.1.</p><h2>准备</h2><p>首先通过pip安装pyecharts</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pyecharts</span><br></pre></td></tr></table></figure></p><p>同时安装中国省市地图包</p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip echarts-china-provinces-pypkg echarts-china-cities-pypkg</span><br></pre></td></tr></table></figure></p><p>为方便直接输出图片, 安装<code>snapshot_selenium</code>或者<code>snapshot_phantomjs</code></p><p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip snapshot_selenium snapshot_phantomjs</span><br></pre></td></tr></table></figure></p><h2>初步尝试</h2><p>简化一下存放在<code>site-packages/example</code>里的<code>geo_example.py</code>, 得到下面的代码</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Geo, Page</span><br><span class="line"><span class="keyword">from</span> pyecharts.faker <span class="keyword">import</span> Collector</span><br><span class="line"><span class="keyword">from</span> pyecharts.render <span class="keyword">import</span> make_snapshot</span><br><span class="line"><span class="comment">#from snapshot_selenium import snapshot</span></span><br><span class="line"><span class="keyword">from</span> snapshot_phantomjs <span class="keyword">import</span> snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># speaker.json存储了以speaker老师名字为key的字典</span></span><br><span class="line"><span class="comment"># 包含"省份"和"方向"两个key-value.</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"speaker.json"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> h:</span><br><span class="line">    speaker = json.load(h)</span><br><span class="line">provs = [s[<span class="string">"省份"</span>] <span class="keyword">for</span> s <span class="keyword">in</span> speaker.values()]</span><br><span class="line">data = [[p, provs.count(p)] <span class="keyword">for</span> p <span class="keyword">in</span> set(provs)]</span><br><span class="line"></span><br><span class="line">C = Collector</span><br><span class="line"></span><br><span class="line"><span class="meta">@C.funcs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geo_speakermap</span><span class="params">()</span> -&gt; Geo:</span></span><br><span class="line">    c = (</span><br><span class="line">        Geo()</span><br><span class="line">        .add_schema(maptype=<span class="string">"china"</span>)</span><br><span class="line">        .add(<span class="string">""</span>, data)</span><br><span class="line">        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>))</span><br><span class="line">        .set_global_opts(</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(min_=<span class="number">0</span>, max_=<span class="number">15</span>, type_=<span class="string">"size"</span>),</span><br><span class="line">            title_opts=opts.TitleOpts(title=<span class="string">"报告人分布"</span>),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">make_snapshot(snapshot, Page().add(*[fn() <span class="keyword">for</span> fn, _ <span class="keyword">in</span> C.charts]).render(),</span><br><span class="line">              <span class="string">"speakermap.png"</span>, browser=<span class="string">'Safari'</span>)</span><br></pre></td></tr></table></figure></p><p>得到分布图如下</p><p><figure class="null"><img src="speakermap.png" alt=" "><figcaption> </figcaption></figure></p><p>报告人主要分布在沿海城市的大学和研究所, 除了bug的帝都. 下面就作图涉及的几个点具体说明一下</p><h3>Collector类</h3><p><code>Collector</code>是pyechart提供的一个convenient function, 源码很短, 提供了一个列表属性和一个静态方法用<code>Collector.funcs</code>装饰后, 函数返回的<code>Geo</code>实例会加入到列表<code>Collector.charts</code>中.</p><p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collector</span>:</span></span><br><span class="line">    charts = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcs</span><span class="params">(fn)</span>:</span></span><br><span class="line">        Collector.charts.append((fn, fn.__name__))</span><br></pre></td></tr></table></figure></p><p><code>Geo</code>类及其方法的调用利用了方法链语法, 不需要换行符来强制换行.</p><h3>全局变量控制</h3><p>用<code>set_global_opts</code>方法调整echarts图片的全局设置. 这个方法继承自<code>Chart</code>类.参数<code>visualmap_opts</code>控制左下角标尺, 需要以<code>pyecharts.options.VisualMapOpts</code>实例作为输入.这里因为总人数比较少, 所以调整了最大范围为15, 并用图标尺寸而非颜色来表示数值大小(<code>type_</code>), 加强对比.其他全局变量设置可以参考<a href="https://pyecharts.org/#/zh-cn/global_options" target="_blank" rel="noopener">官网</a>.</p><h3>图片生成</h3><p><code>pyecharts.render.snapshot</code>提供了<code>make_snapshot</code>函数. <code>make_snapshot</code>实际是selenium或phantomjs的<code>snapshot</code>同名函数的包装.</p><p>这里用phantomjs直接渲染更快一些, 且不会跳出Safari.</p><h2>总结</h2><p>本文基于pyecharts的<code>Geo</code>类制作了报告人所在机构的地理分布. 文中所描述的图片制作是一些简单尝试, 还有很多应该可以调教的地方, 比如标记的颜色, 标尺和主图的相对位置. 不过统计数据太少, 机构地点还只限制在省级, 所得到的结论比较trivial.</p><p>echarts还提供了包括全球和国内省市地图在内的其他地图以及word cloud等不同类型的图片呈现方式, 并有现成的例子可供参考, 为地理数据统计和展示提供了一种方便的选择.</p><h2>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/45202403" target="_blank" rel="noopener">知乎 - Python绘制中国地图</a>: 引导我使用pyecharts. 但是这个教程及其中链接的官方网站的API不适用于1.5.1版本.</p><p><a href="https://pyecharts.org/#/zh-cn/intro" target="_blank" rel="noopener">pyecharts官网</a></p><p><a href="https://ramiro.org/notebook/geopandas-choropleth/" target="_blank" rel="noopener">Creating a Choropleth Map of the World in Python using GeoPandas</a>: 做全球数据统计看上去很不错</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/css/hint.min.css&quot;&gt;&lt;p&gt;&lt;div class=&quot;alert alert-success&quot;&gt;&lt;i class=&quot;fa fa-lightbulb-o  float-left&quot;
      
    
    </summary>
    
      <category term="Programming" scheme="http://shigaro.org/categories/Programming/"/>
    
    
      <category term="Python" scheme="http://shigaro.org/tags/Python/"/>
    
      <category term="pyecharts" scheme="http://shigaro.org/tags/pyecharts/"/>
    
      <category term="map" scheme="http://shigaro.org/tags/map/"/>
    
  </entry>
  
</feed>
