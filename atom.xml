<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shigaro</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shigaro.org/"/>
  <updated>2020-07-19T15:44:04.808Z</updated>
  <id>http://shigaro.org/</id>
  
  <author>
    <name>minyez</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fiddle-proof 与拖延症</title>
    <link href="http://shigaro.org/2020/07/19/fiddle-proof/"/>
    <id>http://shigaro.org/2020/07/19/fiddle-proof/</id>
    <published>2020-07-19T08:56:37.000Z</published>
    <updated>2020-07-19T15:44:04.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>捣鼓工具有感.</p></div><a id="more"></a><p>在捣鼓 Org-mode 的 $\rm\LaTeX$ 导出时偶然间被 refer 到一封 Org-mode 作者 Carsten Dominik 写的 <a href="https://orgmode.org/list/0277B507-1486-4172-B1C6-1B73B84148DD@science.uva.nl/" target="_blank" rel="noopener">mail-list</a> 下。原文主题是比较 Org 和另一个 GTD 软件 <a href="https://www.taskpaper.com/" target="_blank" rel="noopener">TaskPaper</a> (上一篇《<a href="/2020/07/01/macos-float-window/" title="在macOS中置顶窗口">在macOS中置顶窗口</a>》就是为了这个软件). 大意是作为纯文本 GTD, Org-mode 就是 TaskPaper. Org-mode 诚然提供了大量功能，但这并非强迫用户去使用。用户更不需要从一开始就去 (学其他人) 构建一个繁杂的 GTD 系统。更好的办法是从最基本的 TODO 和 DONE 开始，根据自己需求慢慢扩展.</p><p>笔者是赞同这个观点的。复杂的待办系统要对待办分类，加优先级，加标签，周期重复等等。这么做的终极目的是把事务做清晰的划分，方便筛选以避开来自冗余信息的影响。然而这个复杂的系统本身就可能成为 “冗余信息”. 别人的 GTD 系统，在自己身上可能完全是 nonsense. 与其从头理解然后套用，不如构建一个适合自己的系统。亲切和趁手比什么都重要.</p><p>让我感触最深的并不是这个观点，而是 Carsten 引出 Org-mode 高度可定制的优势时说的一句</p><blockquote><p>What is so great about taskpaper that it is (so far?) almost fiddle-proof. It is a list, and there is no way to fiddle with it. People who use fiddling with the TODO system as a way to procrastinate can clearly benefit from such a system.</p></blockquote><p>“fiddle” 有摆弄、把玩 (瞎搞) 的意思，而 proof 后缀表示 “protecting against”, 合起来就是 “不给瞎搞”. 跟 org-mode 相比，TaskPaper 能鼓捣的内容确实少：它支持标签 (<code>@</code>), 但不支持多种 TODO 标记，也不支持事项的作业计时 (org-mode 下有 <code>org-clock-in/out</code>), 更不用提各种代码块、导出功能。第二句 “借鼓捣 GTD 系统来拖延的人显然可因此获益.” 想起在 DDL 面前依然去折腾各种新旧工具和软件的自己，这一句十分扎心。特别当这些工具中的很多现在其实已经不怎么用的时候，当初 fiddling 只为拖延似乎就千真万确、难以辩驳了.</p><p>然而 TaskPaper 真的能帮助人不去 procrastinate 吗？即便是 Carsten 认为 “fiddle-proof” 的 TaskPaper, 我也折腾了 macOS 窗口置顶，花了不少时间做 CSS 定制，而不是去做那些 TODO 们。在看到 Org-mode 后转去鼓捣 Emacs 这一深坑，TaskPaper 自然而然被忘在了角落。</p><p>一个人如果想 procrastinate, 他总可以找到无数的办法。即使是 fiddle-proof 的东西他也能找到把玩的角度。要是手头上的东西不足以让他继续 procrastinate，他就会去找新的。今天云《对马岛之魂》时还听到这样一句话: “成事在人，而非刀剑.” 可能不是非常恰当，但对于任何现代工具也是一样：工具始终只是工具，解决问题的只能是人。而 Procrastinator 不是不想解决问题。他们是对真正重要的问题选择了视而不见。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;捣鼓工具有感.&lt;/p&gt;
    
    </summary>
    
      <category term="Comment" scheme="http://shigaro.org/categories/Comment/"/>
    
    
      <category term="note-taking" scheme="http://shigaro.org/tags/note-taking/"/>
    
      <category term="TaskPaper" scheme="http://shigaro.org/tags/TaskPaper/"/>
    
      <category term="Org-mode" scheme="http://shigaro.org/tags/Org-mode/"/>
    
      <category term="GTD" scheme="http://shigaro.org/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>修改 macOS 上外设键盘的键位映射</title>
    <link href="http://shigaro.org/2020/07/18/remap-macos-keys/"/>
    <id>http://shigaro.org/2020/07/18/remap-macos-keys/</id>
    <published>2020-07-18T08:05:58.000Z</published>
    <updated>2020-07-20T01:51:10.610Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>用 <code>hidutil</code> 对 macOS 外设键盘改键，并设置开机自启.</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在用 Emacs 编写文本时遇到的一个问题就是频繁地缩回小拇指去按左 ctrl 很不方便。因此想着把大小写锁定键改成 ctrl. 在 macOS 上，修改内置键盘键位是比较容易的，<code>系统偏好</code> =&gt; <code>键盘</code> =&gt; <code>修饰键</code>, 就可以随便改。但这一修改不会应用到外接键盘上 (笔者用的是 Logi MX Keys). <a href="https://mic-kul.com/2020/01/25/mx-keys-remap-right-alt/" target="_blank" rel="noopener">搜索</a> 后发现可以用 <code>hidutil</code> 解决这个问题.</p><h2 id="修改外设键盘映射"><a href="#修改外设键盘映射" class="headerlink" title="修改外设键盘映射"></a>修改外设键盘映射</h2><p>手册上，<code>hidutil</code> 被解释为用于管理人机接口设备 (Human Interface Device, HID) 事件系统的实用程序。我理解的 HID 就是键鼠，手柄，方向盘之类。修改键位需要用到它的 <code>property</code> 命令，通过脚本来说明可能更加直接。编写 <code>remap_keyboard.sh</code> 脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">hidutil property --matching <span class="string">'&#123;"Product": "MX Keys"&#125;'</span> \</span><br><span class="line">    --<span class="built_in">set</span> <span class="string">'&#123;"UserKeyMapping": [&#123;"HIDKeyboardModifierMappingSrc":0x700000039,</span></span><br><span class="line"><span class="string">                                "HIDKeyboardModifierMappingDst":0x7000000e0&#125;]&#125;'</span></span><br></pre></td></tr></table></figure><p>选项的具体含义可通过 <code>hidutil property --help</code> 了解。这里做一些简单说明</p><ul><li><code>--matching</code> 选项用来匹配需要修改的外设，值是一个字典。这里用的 Key 是产品名 <code>Product</code>. 如果不知道产品名，可以用 <code>hidutil list</code> 了解设备情况. RegistryID 等信息也能从这里看到.</li><li><code>--set</code> 用来设置属性值。相应的，提取属性是 <code>--get</code>.</li><li>改键对应的 Key 是 <code>UserKeyMapping</code>, 值是一个列表。列表中每一个元素是一个字典。这里用于映射修饰键的 Key 是 <code>HIDKeyboardModifierMappingSrc</code> 和 <code>HIDKeyboardModifierMappingDst</code>. 通俗的说，<code>Src</code> 是键盘上的键，<code>Dst</code> 是机器实际接收的按键，用 16 进制数表示。键位值是 <code>0x700000000</code> 加上对应的 Usage ID, 可以在 <a href="https://developer.apple.com/library/archive/technotes/tn2450/_index.html" target="_blank" rel="noopener">Apple 文档</a> 上查到. CapsLock 是 <code>39</code>, 左 Ctrl 是 <code>e0</code>.</li></ul><p>写完后，加上权限运行即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x remap_keyboard.sh</span><br><span class="line">./remap_keyboard.sh</span><br></pre></td></tr></table></figure><h2 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h2><p>系统重启后，映射会失效。所以需要把它写进开机自启动项里。可以用 Automator 的 App, 也可以用 <code>launchctl</code>. 参考 <a href="https://stackoverflow.com/questions/6442364/running-script-upon-login-mac" target="_blank" rel="noopener">SO 回答</a>, 编写 plist</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple Computer//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.user.loginscript<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">array</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>/path/to/remap_keyboard.sh<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>命名为 <code>com.user.loginscript.plist</code>, 保存到 <code>~/Library/LaunchAgents</code> 下。然后用 <code>launchctl</code> 修改启动项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl load ~/Library/LaunchAgents/com.user.loginscript.plist</span><br></pre></td></tr></table></figure><p>重启测试似乎并没有成功 (*/ω＼*) 索性放到 bin 下，发现 capslock 恢复后就手动运行，倒也算是解决了吧.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 &lt;code&gt;hidutil&lt;/code&gt; 对 macOS 外设键盘改键，并设置开机自启.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
      <category term="keyboard" scheme="http://shigaro.org/tags/keyboard/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 笔记 (二)——Org-mode</title>
    <link href="http://shigaro.org/2020/07/02/emacs-2/"/>
    <id>http://shigaro.org/2020/07/02/emacs-2/</id>
    <published>2020-07-01T23:55:07.000Z</published>
    <updated>2020-07-19T09:51:25.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>Org-mode 使用的学习笔记.</p></div><a id="more"></a><p>在使用 Org-roam 前首先是学习 Org-mode 的使用。这里大量参考了 Zaiste 的 <a href="https://www.youtube.com/watch?v=rCMh7srOqvw&amp;list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj" target="_blank" rel="noopener">Doom Emacs 系列视频</a>, 特别是 E09-E13.</p><h2 id="Org-文件"><a href="#Org-文件" class="headerlink" title="Org 文件"></a>Org 文件</h2><p>任何格式的纯文本都可以用 Org-mode 打开。在打开 <code>.org</code> 后缀文件时，Emacs 会自动启用 Org-mode. 与 Markdown 和 rST 等轻量标记语言类似，org 文件也需要一些标记符号来激活它的功能.</p><table><thead><tr><th>标记符号</th><th>作用</th></tr></thead><tbody><tr><td><code>*</code></td><td>层级标题</td></tr><tr><td><code>+</code></td><td>无序列表</td></tr><tr><td><code>&lt;&lt;nanme&gt;&gt;</code></td><td>id 为 <code>name</code> 的锚</td></tr><tr><td><code>[[name]]</code></td><td>指向 <code>name</code> 的内链接</td></tr><tr><td><code>[[target][desp]]</code></td><td>文本 <code>desp</code> 具有指向 <code>target</code> 的链接。可以是外链</td></tr><tr><td><code>*text*</code></td><td>加粗</td></tr><tr><td><code>_text_</code></td><td>下划线</td></tr><tr><td><code>*text*</code></td><td>高亮</td></tr><tr><td><code>+text+</code></td><td>删除</td></tr><tr><td><code>/text/</code></td><td>斜体</td></tr><tr><td><code>=text=</code></td><td>打字机 (verbatim) 模式</td></tr><tr><td><code>~text~</code></td><td>代码模式</td></tr></tbody></table><p>在导出时，打字机和代码模式都统一导出为打字机模式各种强调记号可以通过 <code>org-emphasis-alist</code> 变量进行自定义.</p><h2 id="按键操作"><a href="#按键操作" class="headerlink" title="按键操作"></a>按键操作</h2><p>一些会经常用到的捆绑键位，作为简单的 cheatsheet</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>M-↑/↓</code></td><td>上下移动整个层级</td></tr><tr><td><code>M-h</code></td><td>上升一个层级</td></tr><tr><td><code>M-l</code></td><td>下降一个层级</td></tr><tr><td><code>C-RET</code></td><td>在下方插入新条目 (表格，清单)</td></tr><tr><td><code>C-s-RET</code></td><td>在上方插入新条目 (表格，清单)</td></tr><tr><td><code>SPC m l l</code></td><td>创建 / 编辑链接</td></tr><tr><td><code>SPC m l d</code></td><td>移除链接</td></tr><tr><td><code>SPC n l</code></td><td>为选定文本制作书签，存入链接库备选</td></tr><tr><td><code>SPC m &#39;</code></td><td>为选中元素调用特殊编辑器</td></tr><tr><td><code>RET</code></td><td>转到链接目标</td></tr><tr><td><code>D</code> (大写 D)</td><td>返回链接位置</td></tr><tr><td><code>C-C C-x C-n/p</code></td><td>下 / 上一个链接位置</td></tr></tbody></table><p>一个小贴士是，可以用 <code>M-x general-describe-keybindings</code> 确认一个捆绑键对应的函数.</p><h2 id="org-文件编辑"><a href="#org-文件编辑" class="headerlink" title="org 文件编辑"></a>org 文件编辑</h2><h3 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h3><p>Org-mode 尤其有用的功能是其方便的内链创建.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* Heading 1</span><br><span class="line">  ** Subheading 1</span><br><span class="line">    This is link to [[Heading 2]]</span><br><span class="line">    这是一个锚 &lt;&lt;anchor&gt;&gt;</span><br><span class="line"></span><br><span class="line">  ** Subheading 2</span><br><span class="line">    跳转到锚 [[anchor]]</span><br><span class="line"></span><br><span class="line">* Heading 2</span><br><span class="line">  Go to [[https://www.google.com][Google.com]]</span><br></pre></td></tr></table></figure><p>此外，Org-mode 支持多种 <a href="https://orgmode.org/manual/External-Links.html#External-Links" target="_blank" rel="noopener">外部链接</a>. 除内链和网页外还支持本地文件 <code>file:</code>, <code>doi:</code>, Emacs Lisp 脚本 <code>elisp:</code> 以及 Shell 脚本 <code>shell:</code> 等。它允许自定义链接，例如在 <code>config.el</code> 中加入下列代码可以创建由 AV 或 BV 号到 b 站视频的链接 <code>blbl:</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建连接 bilibili 视频的链接</span></span><br><span class="line">(<span class="name">defun</span> make-bilibili-link (<span class="name">vid</span>)</span><br><span class="line">  (<span class="name">browse-url</span> (<span class="name">concat</span> <span class="string">"https://www.bilibili.com/video/"</span> vid))  </span><br><span class="line">)</span><br><span class="line">(<span class="name">after!</span> org</span><br><span class="line">  (<span class="name">org-add-link-type</span> <span class="string">"blbl"</span> #'make-bilibili-link)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="可执行代码块"><a href="#可执行代码块" class="headerlink" title="可执行代码块"></a>可执行代码块</h3><p>输入 <code>&lt;s</code> 后 <code>TAB</code>, 创建一个如下环境，可在其中编写代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_SRC LANG</span><br><span class="line">//code here</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure><p>比如我们在其中用 C 编写 Hello World:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_SRC c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main () &#123;</span><br><span class="line">  printf (&quot;Hello World!&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">#+END_SRC</span><br></pre></td></tr></table></figure><p>编写完成后，退出编辑模式。在 <code>END_SRC</code> 下回车，就会自动将输出结果添加到源代码块下方.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#+RESULTS:</span><br><span class="line">: Hello World!</span><br></pre></td></tr></table></figure><p>如果改变了代码的内容，只要选中代码块任意位置重新回车，即可更新输出结果. <span class="label label-info">Q</span> <code>#+RESULTS</code> 部分似乎不会被导出，有待确认)</p><h3 id="LaTeX-导出初探"><a href="#LaTeX-导出初探" class="headerlink" title="LaTeX 导出初探"></a>LaTeX 导出初探</h3><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>C-c C-e l l</code></td><td>导出.org 文件到.tex 文件</td></tr><tr><td><code>C-c C-e l L</code></td><td>将.org 文件导出为 tex, 加载到新缓冲区</td></tr><tr><td><code>C-c C-e l p</code></td><td>导出.org 文件到.tex 文件，并转换为 pdf</td></tr><tr><td><code>C-c C-e l o</code></td><td>导出.org 文件到.tex 文件，转换为 pdf 同时用默认浏览器打开</td></tr></tbody></table><p>在用 LaTeX 导出时，用如下代码块包围的内容会被直接导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#+BEGIN_LATEX</span><br><span class="line">\LaTeX</span><br><span class="line">#+END_LATEX</span><br></pre></td></tr></table></figure><p>导出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\LaTeX</span><br></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><a href="/2020/07/01/emacs-1/" title="Emacs笔记(一)——安装与配置Doom Emacs">Emacs笔记(一)——安装与配置Doom Emacs</a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Org-mode 官方手册: <a href="https://orgmode.org/manual/" target="_blank" rel="noopener">https://orgmode.org/manual/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Org-mode 使用的学习笔记.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="Emacs" scheme="http://shigaro.org/tags/Emacs/"/>
    
      <category term="note-taking" scheme="http://shigaro.org/tags/note-taking/"/>
    
      <category term="Org-mode" scheme="http://shigaro.org/tags/Org-mode/"/>
    
  </entry>
  
  <entry>
    <title>在macOS中置顶窗口</title>
    <link href="http://shigaro.org/2020/07/01/macos-float-window/"/>
    <id>http://shigaro.org/2020/07/01/macos-float-window/</id>
    <published>2020-07-01T09:40:49.000Z</published>
    <updated>2020-07-01T15:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>使用MacForge和AfloatX插件, 在Mojave系统下允许窗口置顶.</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>macOS上一直困扰我的问题是没有简单的窗口置顶工具. 在PC下, 播放器之类的很多软件在任务栏上都有一个小图钉图标, 点一下就可以置顶. 但是macOS上竟然找不到自带这样功能的软件. 这归因于自Mac OS El Capitan以后苹果引入的系统完整性保护 (System Integrity Protection, SIP). 根据<a href="https://en.wikipedia.org/wiki/System_Integrity_Protection#Functions" target="_blank" rel="noopener">维基百科</a>, SIP禁止用户对根目录下<code>/System</code>和<code>/usr</code>等特定文件夹的修改, 关闭代码注入和运行时进程附着, 禁止未签名的内核扩展. 由此看来, 将窗口置顶可能涉及向Finder运行时进行代码注入从而被SIP禁止, 因此按正常流程发布的app就不可能实现这个功能了. 但另一方面, 窗口置顶是否有可能通过由app发送置顶请求到Finder, Finder向用户一次性请求权限的方式来实现呢? 这就要看今后Apple对macOS的改进了.</p><p>可是对于Mojave来说恐怕等不到那个时候, 所以还是得自己想办法. <a href="https://www.maketecheasier.com/mac-keeping-your-application-window-always-on-top/" target="_blank" rel="noopener">这篇文章</a>提供了比较完整的思路, 主要是利用mySIMBL进行代码注入, 置顶功能由<a href="https://github.com/rwu823/afloat" target="_blank" rel="noopener">Afloat</a>提供. 有点遗憾的是, 这篇文章时间比较久远了, mySIMBL已经升级成了<a href="https://github.com/MacEnhance/MacForge" target="_blank" rel="noopener">MacForge</a>, Afloat数年没有更新, 几乎被<a href="https://github.com/jslegendre/AfloatX" target="_blank" rel="noopener">AfloatX</a>取代. 不过基本思路没有变化, 就在这里简单记录一下流程.</p><h2 id="流程记录"><a href="#流程记录" class="headerlink" title="流程记录"></a>流程记录</h2><h3 id="Step-1-部分关闭SIP"><a href="#Step-1-部分关闭SIP" class="headerlink" title="Step 1 部分关闭SIP"></a>Step 1 部分关闭SIP</h3><p>这一部分在<a href="https://github.com/MacEnhance/MacForge/wiki/Installation" target="_blank" rel="noopener">MacForge Wiki页</a>上有充分的描述. 重启, 按住<code>CMD+R</code>进入recovery mode. 从左上角菜单栏打开终端, 输入以下部分关闭SIP的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrutil enable --without fs --without nvram --without debug</span><br></pre></td></tr></table></figure><p><code>without</code>选项指定禁止的SIP功能. 对应内容可由直接输入<code>csrutil</code>来理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ csrutil</span><br><span class="line">System Integrity Protection status: enabled (Custom Configuration).</span><br><span class="line">Configuration:</span><br><span class="line">    Apple Internal: disabled</span><br><span class="line">    Kext Signing: enabled</span><br><span class="line">    Filesystem Protections: disabled</span><br><span class="line">    Debugging Restrictions: disabled</span><br><span class="line">    DTrace Restrictions: enabled</span><br><span class="line">    NVRAM Protections: disabled</span><br><span class="line">    BaseSystem Verification: enabled</span><br><span class="line"></span><br><span class="line">This is an unsupported configuration, likely to break in the future and leave your machine in an unknown state.</span><br></pre></td></tr></table></figure><p><code>fs</code>指的是文件系统保护, <code>debug</code>指调试限制, <code>nvram</code>指非易失性存储器(<a href="https://en.wikipedia.org/wiki/Non-volatile_random-access_memory" target="_blank" rel="noopener">Non-volatile random-access memory</a>, NVRAM)保护. NVRAM是内存的一部分, 用于存储快速访问的设置, 包括<a href="https://support.apple.com/zh-cn/HT204063" target="_blank" rel="noopener">内核崩溃信息</a>.</p><h3 id="Step-2-安装MacForge"><a href="#Step-2-安装MacForge" class="headerlink" title="Step 2 安装MacForge"></a>Step 2 安装MacForge</h3><p>解压GitHub中<a href="https://github.com/w0lfschild/app_updates/raw/master/MacForge/MacForge.zip" target="_blank" rel="noopener">最新发布的压缩包</a>, 然后将<code>.app</code>移到应用程序中.</p><h3 id="Step-3-安装AfloatX"><a href="#Step-3-安装AfloatX" class="headerlink" title="Step 3 安装AfloatX"></a>Step 3 安装AfloatX</h3><p>打开MacForge, 从Featured页面找到AfloatX, GET即可.</p><p><figure class="null"><img src="plugin.png" alt=" "><figcaption> </figcaption></figure></p><h3 id="Step-4-置顶窗口"><a href="#Step-4-置顶窗口" class="headerlink" title="Step 4 置顶窗口"></a>Step 4 置顶窗口</h3><p>打开想要置顶的窗口, 右击对应app的Dock图标, 在AfloatX里选择<code>Float Window</code>, 窗口置顶就完成了. 关闭一次窗口重新打开, 就可以取消置顶.</p><p><figure class="null"><img src="float-taskpaper.png" alt=" "><figcaption> </figcaption></figure></p><p>完工 (ง •̀_•́)ง 置顶GTD app窗口对于健忘+拖延的我来说就是救命恩人(bushi).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用MacForge和AfloatX插件, 在Mojave系统下允许窗口置顶.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
      <category term="GTD" scheme="http://shigaro.org/tags/GTD/"/>
    
      <category term="MacForge" scheme="http://shigaro.org/tags/MacForge/"/>
    
      <category term="Afloatx" scheme="http://shigaro.org/tags/Afloatx/"/>
    
  </entry>
  
  <entry>
    <title>Emacs笔记(一)——安装与配置Doom Emacs</title>
    <link href="http://shigaro.org/2020/07/01/emacs-1/"/>
    <id>http://shigaro.org/2020/07/01/emacs-1/</id>
    <published>2020-07-01T06:51:07.000Z</published>
    <updated>2020-07-10T16:09:16.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>记录从零开始的Emacs. 目标是熟练地使用Org-roam编辑个人维基!</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因缘巧合, 今日我在搜索转化$\rm\LaTeX$到MathML的解决方案时, 偶然看到了<a href="https://github.com/org-roam/org-roam" target="_blank" rel="noopener">Org-roam</a>项目. 它的个人知识库构建和展示方式引起了我很大的兴趣.</p><p>Org-roam基于Emacs的Org-mode, 后者是Emacs中纯文本笔记管理+GTD+写作系统. “Org”指代organize, “roam”则取自<a href="https://roamresearch.com/" target="_blank" rel="noopener">Roam Research</a>. Org-roam采纳了<a href="https://zettelkasten.de/" target="_blank" rel="noopener">Zettelkasten笔记法</a>的思想.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Zettelkasten是一个德语词, 对应英语slip box, 类似于图书馆存放索引卡的盒子.">[1]</span></a></sup> 这种方法认为知识不是层级化的而是扁平化的, 重要的是知识之间的关联. 这种关联通过笔记中用<code>[[...]]</code>包围的关键词建立. Org-roam能对这种连接进行可视化.</p><p><figure class="null"><img src="org-roam-graph-demo.png" alt="Graph view, from Org-roam GitHub site"><figcaption>Graph view, from Org-roam GitHub site</figcaption></figure></p><p>相比较其他Zettelkasten实现, Org-roam的特点是</p><ol><li>完全免费开源, 数据库本地存储而不是封存托管在企业云端数据库.</li><li>基于Org-mode纯文本系统, 可利用Emacs生态扩展.</li><li>配置复杂, 学习曲线陡峭.</li><li><del>Emacs与Vim水火不容</del></li></ol><p>一直以来也接触过挺多笔记记录的方式, Agenda, Bear, OneNote, Notion, 甚至是本地文件夹, 但总是觉得不得劲. 现在又多了这样一种选择, 自然还是想试一下. 然而作为Vim用户, 第一个应该跨过的关卡应该是Emacs的基本使用. 现在就说道说道吧.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Doom-Emacs"><a href="#Doom-Emacs" class="headerlink" title="Doom Emacs"></a>Doom Emacs</h3><p>从安装开始. 为免去Emacs基本设置, 在<a href="https://www.youtube.com/watch?v=Lg61ocfxk3c" target="_blank" rel="noopener">Matt Williams</a>的推荐下安装<a href="https://github.com/d12frosted/homebrew-emacs-plus" target="_blank" rel="noopener">emacs-plus</a>和<a href="https://github.com/hlissner/doom-emacs" target="_blank" rel="noopener">Doom Emacs</a>. 用homebrew安装Emacs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew tap d12frosted/emacs-plus</span><br><span class="line"><span class="meta">#</span><span class="bash"> 若出现403错误, 在前面加上all_proxy=socks5://127.0.0.1:1086</span></span><br><span class="line">brew install emacs-plus@27 --with-modern-icon-cg433n</span><br><span class="line">ln -s /usr/local/opt/emacs-plus/Emacs.app /Applications/Emacs.app</span><br></pre></td></tr></table></figure><p>完成后再从GitHub安装Doom Emacs</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d</span><br><span class="line">~/.emacs.d/bin/doom install</span><br></pre></td></tr></table></figure><p>此时命令行打开Emacs, 可以看到下面这样十分炫酷的界面. 这跟我印象里面一个大白框UI迥然不同.</p><p><figure class="null"><img src="doom-ui.png" alt="Doom Emacs UI"><figcaption>Doom Emacs UI</figcaption></figure></p><p>Doom Emacs安装完后, 编辑<code>~/.doom.d/</code>下的<code>init.el</code>文件打开或关闭一些Doom模块. 一些模块包含可选功能, 需要通过<code>+</code>指定, 例如打开<a href="https://orgmode.org/" target="_blank" rel="noopener">Org-mode</a>的可选功能 (<span class="label label-info">Q</span>如何检查一个包有哪些可选功能?)</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">doom!</span> <span class="symbol">:lang</span></span><br><span class="line">  (<span class="name">org</span> +brain</span><br><span class="line">       +dragdrop</span><br><span class="line">       +gnuplot</span><br><span class="line">       +jupyter)      <span class="comment">; organize your plain life in plain text</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>在<code>~/.doom.d/packages.el</code>下用<code>package!</code>命令指定安装ELPA/MELPA上的插件包,<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="ELPA: 全称Emacs Lisp Package Archive, Emacs默认的软件包存储库. MELPA = Milkypostman ELPA">[2]</span></a></sup> 例如</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 安装ELPA或者MELPA上的包</span></span><br><span class="line">(<span class="name">package!</span> markdown-mode)</span><br><span class="line"><span class="comment">;; 从GitHub仓库安装最新版markdown-mode</span></span><br><span class="line">(<span class="name">package!</span> markdown-mode</span><br><span class="line"> <span class="symbol">:recipe</span> (<span class="symbol">:host</span> github <span class="symbol">:repo</span> jrblevin/markdown-mode))</span><br></pre></td></tr></table></figure><p>设置完后运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.emacs.d/bin/doom sync</span><br></pre></td></tr></table></figure><p>以应用两个文件的变化. 如果遇到安装问题, 可在<code>packages.el</code>中注释掉对应代码, 命令行执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doom purge</span><br></pre></td></tr></table></figure><p>卸载程序包, 再反注释掉, 重新安装即可.</p><h3 id="Org-roam"><a href="#Org-roam" class="headerlink" title="Org-roam"></a>Org-roam</h3><p>Org-roam的安装可以采用<code>+</code>方式安装(<a href="https://orgroam.slack.com/archives/CV160S8EL/p1590857012127400" target="_blank" rel="noopener">slack讨论</a>)</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">doom!</span> <span class="symbol">:lang</span></span><br><span class="line">  (<span class="name">org</span> +roam)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>也可以在<code>packags.el</code>中加入</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">package!</span> org-roam)</span><br><span class="line">(<span class="name">package!</span> company-org-roam) <span class="comment">;org-roam相关的代码补全</span></span><br></pre></td></tr></table></figure><p>安装. 随后在<code>config.el</code>中用<code>use-package!</code>函数配置</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package!</span> org-roam</span><br><span class="line">  <span class="symbol">:commands</span> (<span class="name">org-roam-insert</span> org-roam-find-file org-roam)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  (<span class="name">setq</span> org-roam-directory <span class="string">"~/Documents/SelfDevelopment/org-roam/"</span>)</span><br><span class="line">  (<span class="name">setq</span> org-roam-graph-viewer <span class="string">"/usr/bin/open"</span>)</span><br><span class="line">  (<span class="name">map!</span> <span class="symbol">:leader</span></span><br><span class="line">  <span class="symbol">:prefix</span> <span class="string">"r"</span></span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Insert"</span> <span class="string">"i"</span> #'org-roam-insert</span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Find"</span>   <span class="string">"/"</span> #'org-roam-find-file</span><br><span class="line">  <span class="symbol">:desc</span> <span class="string">"Org-Roam-Buffer"</span> <span class="string">"r"</span> #'org-roam)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">org-roam-mode</span> <span class="number">+1</span>))</span><br><span class="line">(<span class="name">add-hook</span> 'after-init-hook 'org-roam-mode)</span><br></pre></td></tr></table></figure><p>随后打开Emacs, <code>M-x org-roam-find-file</code>或<code>SPC r /</code>, 会检查<code>org-roam-directory</code>下的所以org文件. 输出文件名进行编辑或者新建</p><p><figure class="null"><img src="first_file.png" alt=" "><figcaption> </figcaption></figure></p><p>编辑完后<code>C-c C-c</code>保存. 对于config中不了解的函数, 可以输入<code>SPC(空格) h f</code>来查询.</p><p>更进一步的Org-mode, Org-roam配置和使用将会在今后的文章中记录. 在本文接下来部分中仅涉及Emacs编辑和指令的基本使用.</p><h2 id="Emacs使用"><a href="#Emacs使用" class="headerlink" title="Emacs使用"></a>Emacs使用</h2><p><a href="https://www.youtube.com/watch?v=rCMh7srOqvw&amp;list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj" target="_blank" rel="noopener">Zaiste</a>制作了一系列非常好的Youtube视频介绍Doom Emacs和Org-mode的使用, 这里的记录基本上是练习他的Doom视频内容的整理.</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>Dired模式下可以对文件夹与文件进行操作.</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>-</code>/<code>RET</code></td><td>进入上层/子文件夹</td></tr><tr><td><code>+</code></td><td>新建文件夹</td></tr><tr><td><code>d x</code></td><td>标记要删除的文件(夹), 执行删除</td></tr><tr><td><code>o</code></td><td>排序</td></tr><tr><td><code>M</code></td><td>修改文件权限</td></tr><tr><td><code>O</code></td><td>修改文件owner</td></tr><tr><td><code>m</code>/<code>u</code></td><td>选择/取消选择文件</td></tr><tr><td><code>U</code></td><td>取消所有选择</td></tr><tr><td><code>R</code></td><td>重命名/移动文件</td></tr><tr><td><code>C</code></td><td>复制文件</td></tr><tr><td><code>c</code></td><td>压缩选中文件</td></tr></tbody></table><h3 id="常用键位和命令"><a href="#常用键位和命令" class="headerlink" title="常用键位和命令"></a>常用键位和命令</h3><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>SPC .</code></td><td>打开或创建文件 (在文本编辑模式下直接回车, 相当于Vim的<code>:q</code>)</td></tr><tr><td><code>SPC f r</code></td><td>打开最近文件</td></tr><tr><td><code>SPC o i</code></td><td>在iTerm中打开当前文件夹</td></tr><tr><td>修饰键<code>C</code></td><td>Mac上为Ctrl键</td></tr><tr><td>修饰键<code>M</code></td><td>Mac上为Alt键 (在Doom中如果是第一个输入, CMD键也可以)</td></tr><tr><td>修饰键<code>s</code></td><td>Mac上为CMD键</td></tr><tr><td><code>M-x shell</code></td><td>在Emacs中打开shell(全屏)</td></tr><tr><td><code>SPC o T</code></td><td>在Emacs中打开vterm(全屏)</td></tr><tr><td><code>SPC o t</code></td><td>在Emacs中弹出vterm小窗</td></tr></tbody></table><p>如果想将vterm的默认shell设为zsh需要在<code>config.el</code>中加入</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; set zsh to default shell of vterm</span></span><br><span class="line">(<span class="name">use-package!</span> vterm</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> vterm-shell <span class="string">"zsh"</span>))</span><br></pre></td></tr></table></figure><p>此时可以用<code>SPC o T</code>打开vterm, 使用的是zsh.</p><h3 id="缓冲区和窗口操作"><a href="#缓冲区和窗口操作" class="headerlink" title="缓冲区和窗口操作"></a>缓冲区和窗口操作</h3><p>和Vim类似, 打开文件时, Emacs会打开一个缓冲区(buffer), 载入当前文件的所有内容. 所有编辑都在buffer中进行. 但buffer不必一定是文件, 它也可以是shell, 或者Dired文件树等等.</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>SPC b N</code> 或 <code>CMD-n</code></td><td>新建缓冲区</td></tr><tr><td><code>SPC b k</code> 或 <code>CMD-k</code></td><td>杀死当前缓冲区</td></tr><tr><td><code>SPC b b</code> 或 <code>SPC ,</code></td><td>切换工作区缓冲区</td></tr><tr><td><code>SPC b B</code> 或 <code>SPC &lt;</code></td><td>切换全局缓冲区</td></tr><tr><td><code>C-w v</code></td><td>水平复制缓冲区到新窗口</td></tr><tr><td><code>C-w s</code></td><td>垂直复制缓冲区到新窗口</td></tr><tr><td><code>C-w w</code></td><td>转到下一个缓冲区窗口</td></tr><tr><td><code>C-w h/j/k/l</code></td><td>Vi式窗口转移</td></tr><tr><td><code>C-w q</code></td><td>关闭窗口</td></tr><tr><td><code>C-w &gt;/&lt;</code></td><td>向右/左扩展窗口</td></tr><tr><td><code>C-w +/-</code></td><td>向上/下扩展窗口</td></tr><tr><td><code>C-w =</code></td><td>使所有窗口等宽等高</td></tr></tbody></table><h3 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h3><p>这里文本编辑想表达的是类似Vim中文本操作键位和command mode下的命令(<code>:</code>). 好在Doom Emacs将许多Vim与Emacs命令绑定在了一起, 省去了学习Emacs原生编辑操作的麻烦. 但是Domm Emacs额外提供了许多方便的编辑命令</p><table><thead><tr><th>Key</th><th>功能</th></tr></thead><tbody><tr><td><code>C-x k</code></td><td>关闭buffer但不保存, 类似Vim <code>:q!</code>. 如果直接输入<code>:q</code>将会关闭整个Emacs</td></tr><tr><td><code>g s SPC STR</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转</td></tr><tr><td><code>g s SPC STR x</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转并剪切</td></tr><tr><td><code>g s SPC STR i</code></td><td>Avy搜索<code>STR</code>所在位置, 跳转并提供ispell修改意见</td></tr></tbody></table><h3 id="Markdown编辑和预览"><a href="#Markdown编辑和预览" class="headerlink" title="Markdown编辑和预览"></a>Markdown编辑和预览</h3><p>markdown文件的文本渲染和快速编辑可以使用<a href="https://jblevins.org/projects/markdown-mode/" target="_blank" rel="noopener">markdown-mode</a>. <a href="https://blog.bitsandbobs.net/blog/emacs-markdown-live-preview/" target="_blank" rel="noopener">Markus Opitz</a>基于<code>simple-httpd</code>包实现了一个HTTP服务器实时预览的功能. 编辑命令可参考这个<a href="https://cheatography.com/xaon/cheat-sheets/emacs-markdown-mode/" target="_blank" rel="noopener">Cheatsheet</a>.</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><h3 id="GitHub图标显示不正常"><a href="#GitHub图标显示不正常" class="headerlink" title="GitHub图标显示不正常"></a>GitHub图标显示不正常</h3><p>安装完后打开Doom Emacs, 首页上的GitHub图标显示有可能<a href="https://github.com/hlissner/doom-emacs/issues/724" target="_blank" rel="noopener">不正常</a>, 此时需要在Emacs下安装<code>all-the-icons</code>.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M-x all-the-icons-install-fonts</span><br></pre></td></tr></table></figure><p>如果出现403错误, 可以用<a href="https://blog.fazero.me/2015/08/31/%E5%88%A9%E7%94%A8proxychains%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8socks5%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">proxychains-ng</a>和SS解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 emacs</span><br></pre></td></tr></table></figure><h3 id="Package-cl-is-deprecated警告"><a href="#Package-cl-is-deprecated警告" class="headerlink" title="Package cl is deprecated警告"></a><code>Package cl is deprecated</code>警告</h3><p>在打开Doom Emacs后底部会出现这一警告. 原因是在Emacs 24后<code>cl</code>程序包已经被<code>cl-lib</code>取代, 而部分依赖于<code>cl</code>的包(如<a href="https://github.com/jrblevin/deft/issues/77#issue-616735753" target="_blank" rel="noopener">deft</a>)未相应更新. 目前除了等待源码更新外, 没有好的解决办法.</p><h3 id="新建文档时安装PDF-tools出错"><a href="#新建文档时安装PDF-tools出错" class="headerlink" title="新建文档时安装PDF-tools出错"></a>新建文档时安装PDF-tools出错</h3><p>首次用<code>M-X org-roam-find-file</code>创建新文件, 会弹出build epdfinfo的请求, 确定后自动安装pdf-tools. 此时出现了build failed的情况, 主要错误信息是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configure: error: cannot find necessary  poppler-private header (see README.org)</span><br><span class="line">Build failed.  ;o(</span><br></pre></td></tr></table></figure><p>解决办法参考这个<a href="https://github.com/politza/pdf-tools/issues/480#issuecomment-472223334" target="_blank" rel="noopener">issue comment</a>, 从Homebrew安装pdf-tools</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap dunn/homebrew-emacs</span><br><span class="line">brew install --HEAD pdf-tools</span><br></pre></td></tr></table></figure><p>然后在packages.el中加入</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">package!</span> pdf-tools)</span><br></pre></td></tr></table></figure><p>重新打开Emacs新建文件, 不需要重新build epdfinfo了.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Master Emacs in 21 Days: <a href="http://book.emacs-china.org/" target="_blank" rel="noopener">http://book.emacs-china.org/</a></p><p>Emacs Key Bindings: <a href="https://caiorss.github.io/Emacs-Elisp-Programming/Keybindings.html" target="_blank" rel="noopener">https://caiorss.github.io/Emacs-Elisp-Programming/Keybindings.html</a></p><p><a href="http://emacslife.com/read-lisp-tweak-emacs/beginner-3-make-things-more-convenient.html" target="_blank" rel="noopener">How can I customize Emacs to make things more convenient?</a></p><p>Using Emacs Series: <a href="https://cestlaz.github.io/stories/emacs/" target="_blank" rel="noopener">https://cestlaz.github.io/stories/emacs/</a></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Zettelkasten是一个德语词, 对应英语slip box, 类似于图书馆存放索引卡的盒子.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">ELPA: 全称Emacs Lisp Package Archive, Emacs默认的软件包存储库. MELPA = Milkypostman ELPA<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录从零开始的Emacs. 目标是熟练地使用Org-roam编辑个人维基!&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
      <category term="Emacs" scheme="http://shigaro.org/tags/Emacs/"/>
    
      <category term="Org-roam" scheme="http://shigaro.org/tags/Org-roam/"/>
    
  </entry>
  
  <entry>
    <title>Hexo笔记(二)——显示博文修改时间等</title>
    <link href="http://shigaro.org/2020/06/30/hexo-2-update-time/"/>
    <id>http://shigaro.org/2020/06/30/hexo-2-update-time/</id>
    <published>2020-06-30T04:12:12.000Z</published>
    <updated>2020-07-01T04:29:31.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>给Freemind主题增加显示博文修改时间的功能. 用hexo-browsersync实现server模式实时预览.</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在网上浏览博文的时候, 经常可以看到一些Hexo生成的站点文章有最后修改时间的属性, 所以一直以来都想给自己的博文增加这样的功能. 可惜拖着拖着到现在才想着实践. 原本想着只要在front matter上增加类似<code>update</code>属性, 然后修改ejs让它像<code>date</code>一样在边栏显示就可以了. 但是这样想的时候出现了一点问题, 因为直接从front matter提取的<code>update</code>是字符串, 没有<code>format</code>方法, 也不能传给<code>date()</code>函数. 在看了一些文章后才知道需要先将其转换为<code>moment</code>对象. 那么问题就变成了找到<code>date</code>是在哪里变成<code>moment</code>对象的即可. 另外还想实现的需求是: 如果front matter有<code>updated</code>属性, 则以<code>updated</code>为最后修改时间; 如果没有, 则获取文件的最后修改时间.</p><h2 id="搜索date-moment对象化代码"><a href="#搜索date-moment对象化代码" class="headerlink" title="搜索date moment对象化代码"></a>搜索date moment对象化代码</h2><p>采用正则表达式, <code>find</code>和<code>grep</code>搜索js文件, 寻找<code>date</code>属性的<code>moment</code>实例化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -regex <span class="string">".*\.js"</span> | xargs grep -E <span class="string">"moment\(.*date)"</span> --color -RnH</span></span><br><span class="line">./node_modules/hexo/lib/plugins/helper/date.js:9:  if (!isMoment(date)) date = moment(isDate(date) ? date : new Date(date));</span><br><span class="line">./node_modules/hexo/lib/hexo/post.js:40:  data.date = data.date ? moment(data.date) : moment();</span><br></pre></td></tr></table></figure><p>可以看到<code>date</code>实例化在<code>post.js</code>的40行. 接下来在<code>post.js</code>中加入如下代码使data获得moment对象<code>updated</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data.updated) &#123;</span><br><span class="line">      data.updated = moment(data.updated);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但这样还不能满足我们的要求, 即要求<code>updated</code>属性不存在时获取文件最后修改时间, 作为文章最后修改时间. 根据参考资料1, 为获取文件路径, 除了<code>post.js</code>中已经引入的<code>path</code>外, 需要引入<code>child_process</code>库来调用系统的date命令.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> execSync = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br></pre></td></tr></table></figure><p>于是修改上一步中的实例化if语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastMod = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">if</span> (data.updated) &#123;</span><br><span class="line">    data.updated = moment(data.updated);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 对data.source进行判断, 否则在新建post时会报错</span></span><br><span class="line">  <span class="keyword">if</span> (data.source) &#123;</span><br><span class="line">    fp = pathFn.resolve(config.source_dir, data.source);</span><br><span class="line">    lastMod = execSync(<span class="string">`date -r <span class="subst">$&#123;fp&#125;</span> "+%Y-%m-%d %H:%M:%S"`</span>).toString().trim();</span><br><span class="line">    data.updated = moment(lastMod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    data.updated = data.date;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就使得每一个post对象获得了<code>updated</code>属性.</p><h2 id="修改meta-ejs"><a href="#修改meta-ejs" class="headerlink" title="修改meta.ejs"></a>修改meta.ejs</h2><p>得到<code>updated</code>属性后, 只要简单修改<code>layout/_partial/post</code>下的<code>meta.ejs</code>文件即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- date --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (item.date) &#123; %&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"meta-widget"</span>&gt;</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-clock-o"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">&lt;%= item.date.format(config.date_format) %&gt; created</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (item.updated) &#123; %&gt;</span><br><span class="line"> &lt;% <span class="keyword">if</span> (date(item.date) != date(item.updated)) &#123; %&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"meta-widget"</span>&gt;</span><br><span class="line">    &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-pencil"</span>&gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%= item.updated.format(config.date_format) %&gt; last modified</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">   &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>这里额外要求只有当<code>date</code>和<code>updated</code>两者日期不同时, 才显示<code>updated</code>的时间. 效果如下图所示</p><p><figure class="null"><img src="update_time_result.png" alt=" "><figcaption> </figcaption></figure></p><p>完工 (ง •̀_•́)ง</p><h2 id="Server模式实时预览"><a href="#Server模式实时预览" class="headerlink" title="Server模式实时预览"></a>Server模式实时预览</h2><p>每次修改博文都要重新hexo generate再server挺麻烦的. 原来用的<a href="https://github.com/hexojs/hexo-livereload" target="_blank" rel="noopener">hexo-livereload</a>已被归档, 现在可以用<a href="https://github.com/hexojs/hexo-browsersync" target="_blank" rel="noopener">hexo-browsersync</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g browsersync</span><br><span class="line">npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure><p>之后再运行server模式. 当md文件有改动时, localhost页面会自动更新.</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><a href="/2018/02/15/Hexo-1/" title="Hexo笔记(一)——安装, Markdown写作与主题">Hexo笔记(一)——安装, Markdown写作与主题</a><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/xcatliu/hexo-filter-date-from-git/blob/master/index.js" target="_blank" rel="noopener">hexo-filter-date-from-git/index.js</a></li><li><a href="https://stackoverflow.com/a/20807343" target="_blank" rel="noopener">SO - Print a file’s last modified date in Bash</a></li><li><a href="https://blog.csdn.net/dengxu11/article/details/6947078?utm_source=blogxgwz0" target="_blank" rel="noopener">grep 递归指定文件遍历方法</a></li><li><a href="https://blog.singee.me/2018/05/16/hexo/hexo-auto-refresh/" target="_blank" rel="noopener">Hexo利用browsersync进行自动刷新</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给Freemind主题增加显示博文修改时间的功能. 用hexo-browsersync实现server模式实时预览.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="Hexo" scheme="http://shigaro.org/tags/Hexo/"/>
    
      <category term="Freemind" scheme="http://shigaro.org/tags/Freemind/"/>
    
      <category term="JavaScript" scheme="http://shigaro.org/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>解决macOS上脚本中运行VASP时动态库未载入问题</title>
    <link href="http://shigaro.org/2020/05/09/macos-script-runvasp/"/>
    <id>http://shigaro.org/2020/05/09/macos-script-runvasp/</id>
    <published>2020-05-09T07:30:23.000Z</published>
    <updated>2020-06-29T07:30:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>解决macOS上脚本中运行程序遇到dyld: Library not loaded报错.</p></div><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>疫情在家工mo作yu期间, 准备在自己macOS上用VASP做点小的测试. 因为懒得重复输入命令, 于是写了一个最基本的shell脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">mpirun -np 4 vasp_std</span><br></pre></td></tr></table></figure><p>第一步载入的是事先写好的VASP相关环境变量. 执行, 结果报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/libmkl_intel_lp64.dylib</span><br><span class="line">  Referenced from: /Users/stevezhang/software/sci/vasp/vasp.5.4.4-intel-2018.0.1/common/bin/vasp_std</span><br><span class="line">  Reason: image not found</span><br></pre></td></tr></table></figure><p>也即<code>libmkl_intel_lp64.dylib</code>没有加到<code>DYLD_LIBRARY_PATH</code>中. 可比较奇怪的是, 在命令行里echo <code>DYLD_LIBRARY_PATH</code>, 返回的是预期结果.</p><h2 id="探索与解决"><a href="#探索与解决" class="headerlink" title="探索与解决"></a>探索与解决</h2><p>写一个非常简单的脚本，检查脚本执行过程中的环境变量.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">module load intel/2018.1</span><br><span class="line">module load mpich/3.2.1-intel-2018.0.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>运行前线载入<code>intel/2018.1</code>模块. 运行脚本发现:</p><ul><li>在module load前后, <code>LIBRARY_PATH</code>和<code>PATH</code>同echo的预期结果相同.</li><li>在module load前, <code>DYLD_LIBRARY_PATH</code>是空的.</li><li>在load后, 只有未在zshrc里载入的MPICH里定义的库路径被加入到<code>DYLD_LIBRARY_PATH</code>中.</li></ul><p>搜索后找到几个帖子描述类似问题:</p><p><a href="https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here" target="_blank" rel="noopener">https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here</a><br><a href="https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1" target="_blank" rel="noopener">https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1</a></p><p>问题原因是，从El Captian开始, macOS引入了系统完整性保护(system integrity protection, SIP), 在调用系统提供的解释器时，所有<code>DYLD_</code>环境变量会被重设. 在使用module管理环境时, 因为intel模块事先被载入过, 因此脚本里面载入intel模块的行为会被module无视, 因此只有MPICH中的变量加入到<code>DYLD_LIBRARY_PATH</code>中.</p><p>一种解决办法是, 在最开始的shell脚本里面手动设置<code>DYLD_LIBRARY_PATH</code>, 缺点是不容易复用bashrc或zshrc里的内容. 更方便的做法是在shell脚本里load完所有module后reload一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">module reload</span><br><span class="line"></span><br><span class="line">mpirun -np 4 vasp_std <span class="comment"># success</span></span><br></pre></td></tr></table></figure><p>另一种可能的办法是<a href="https://blog.csdn.net/qq285744011/article/details/82219340" target="_blank" rel="noopener">关闭SIP</a>, 不过因为reload完全解决了我的需求, 所以就没有尝试这种稍微麻烦些的办法.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决macOS上脚本中运行程序遇到dyld: Library not loaded报错.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="VASP" scheme="http://shigaro.org/tags/VASP/"/>
    
      <category term="macOS" scheme="http://shigaro.org/tags/macOS/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记(四)——使用MathpixOCR API进行LaTeX公式识别</title>
    <link href="http://shigaro.org/2019/10/28/mathpix-ocr/"/>
    <id>http://shigaro.org/2019/10/28/mathpix-ocr/</id>
    <published>2019-10-28T08:39:23.000Z</published>
    <updated>2020-06-30T01:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>编写MathpixOCR API的Python包装器和简单的Automator workflow, 模拟Mathpix Snip Tool的公式识别体验.</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用LaTeX准备文献报告时一个比较头疼的问题是输入文献中包含复杂符号的长公式. <a href="https://mathpix.com/" target="_blank" rel="noopener">Mathpix Snip Tool</a> (MST)提供了方便的光学字符识别功能, 可以将包含公式的截图转化为LaTeX代码. 今年MST从完全免费的1.0版本升级到了2.0, 自此个人用户每月只能免费识别50次, 这对于苦逼PhD显然是不够用的.</p><p>好在作为MST底层的MathpixOCR服务, API每月可免费调用1000次, 所得结果和MST相同, 只是没有MST方便的截图和GUI功能. 归根结底, 我们想实现的无非是识别剪贴板中的公式图片, 转化图片到LaTeX代码并复制到剪贴板而已. 这可以通过将OCR与OS命令包装在一起来实现. 官方提供了简单的<a href="https://github.com/Mathpix/api-examples/tree/master/python" target="_blank" rel="noopener">例子</a>供我们学习OCR API的使用, 而OS API可以通过Python包和CLI命令调用. 这篇文章是学习包装器编写的记录.</p><p>最终脚本已上传到<a href="https://github.com/minyez/mathpixocr_wrapper" target="_blank" rel="noopener">GitHub仓库</a>, 欢迎下载使用.</p><h2 id="API包装"><a href="#API包装" class="headerlink" title="API包装"></a>API包装</h2><h3 id="获取API密钥"><a href="#获取API密钥" class="headerlink" title="获取API密钥"></a>获取API密钥</h3><p>首先需要在Mathpix上注册用户并填写信用卡信息, 注册后获得<code>app_key</code>和<code>app_id</code>作为API密钥. 脚本采用了两种从外部获取密钥的方式, 一种是环境变量, 另一种是从同路径下JSON读取.</p><h3 id="从系统剪贴板获取图片"><a href="#从系统剪贴板获取图片" class="headerlink" title="从系统剪贴板获取图片"></a>从系统剪贴板获取图片</h3><p>使用pillow包中的<code>ImageGrab.grabclipboard</code>获取剪贴版中的图片, 并产生<code>Image</code>对象. 注意, 此后剪贴板中的临时文件会被删除, 无法再直接通过路径获得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im = ImageGrab.grabclipboard()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(im.filename)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>因此需要先把图片保存下来才能在后续继续使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">im = ImageGrab.grabclipboard()</span><br><span class="line">fn = <span class="string">".temp_eq.png"</span></span><br><span class="line">im.save(fn, <span class="string">"PNG"</span>)</span><br></pre></td></tr></table></figure><h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p>OCR要求图片编码为base64. 编码转换可以参考官方例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_uri</span><span class="params">(fn)</span>:</span></span><br><span class="line">  image_data = open(fn, <span class="string">"rb"</span>).read()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"data:image/jpg;base64,"</span> + base64.b64encode(image_data).decode()</span><br></pre></td></tr></table></figure><p><code>b64encode</code>使用Base64规则将一串类字节字符串进行编码, <code>decode</code>方法返回编码后的普通字符串.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec = base64.b64encode(<span class="string">b"abcdefg"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec</span><br><span class="line"><span class="string">b'YWJjZGVmZw=='</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec.decode()</span><br><span class="line"><span class="string">'YWJjZGVmZw=='</span></span><br></pre></td></tr></table></figure><h3 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h3><p>通过<code>requests</code>包与OCR API进行通信. 通信数据要求为JSON, 它至少需要包含<code>src</code>和<code>format</code>两个键. <code>src</code>值就是base64编码后的图片字符串, <code>format</code>值为一个列表, 成员为所想要转换的格式, 支持的转化格式包括下面几种.</p><table><thead><tr><th style="text-align:left"><code>format</code>值</th><th style="text-align:left">转化格式</th></tr></thead><tbody><tr><td style="text-align:left"><code>text</code></td><td style="text-align:left">普通文本</td></tr><tr><td style="text-align:left"><code>wolfram</code></td><td style="text-align:left">Mathematica</td></tr><tr><td style="text-align:left"><code>latex_simplified</code></td><td style="text-align:left">简化的latex代码, 括号不包含left或right</td></tr><tr><td style="text-align:left"><code>latex_styled</code></td><td style="text-align:left">left/right控制的latex代码</td></tr></tbody></table><p>利用<code>json</code>包将字典转化成JSON字符串, 用<code>requests</code>发送API请求到<code>v3/latex</code>端点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = json.dump(&#123;<span class="string">"src"</span>: img_base64, <span class="string">"format"</span>: [<span class="string">"latex_simplified"</span>,]&#125;)</span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  <span class="string">'app_key'</span>: your_app_key,</span><br><span class="line">  <span class="string">'app_id'</span>: your_app_id,</span><br><span class="line">  &#125;</span><br><span class="line">r = requests.post(<span class="string">'https://api.mathpix.com/v3/latex'</span>,</span><br><span class="line">                  data=data, headers=headers)</span><br></pre></td></tr></table></figure><p>通信返回的<code>r.text</code>是一个JSON字符串. 如果OCR识别成功, 则它包含<code>latex_simplified</code>键, 对应值为识别号的简化LaTeX代码. 如果识别失败, 则包含<code>error</code>键, 给出具体错误信息. 更复杂的API调用参考<a href="https://docs.mathpix.com/" target="_blank" rel="noopener">官方文档</a>.</p><div class="alert alert-info"><i class="fa fa-info  float-left"></i>  <p><code>v3/latex</code>端点目前是旧端点. 官方推荐使用<code>v/3text</code>, 通信所需的JSON关键词有些许不同, 但变化不是很大, 读者可自行参考文档修改. (2020-06-29)</p></div><h3 id="拷贝转化好的LaTeX到系统剪贴板"><a href="#拷贝转化好的LaTeX到系统剪贴板" class="headerlink" title="拷贝转化好的LaTeX到系统剪贴板"></a>拷贝转化好的LaTeX到系统剪贴板</h3><p>参考了<a href="https://gist.github.com/luqmaan/d8bc61e746207bb12f11" target="_blank" rel="noopener">这个GIST</a>, 使用macOS上的<code>pbcopy</code>将字符串拷贝到系统剪贴板. 另一种办法是直接打印到标准输出, 然后用Automator服务中的功能拷贝到剪贴板.</p><h3 id="附加功能"><a href="#附加功能" class="headerlink" title="附加功能"></a>附加功能</h3><p>比如每月API调用统计以及历史记录, 都保存在JSON文件中. 实现说起来比较琐碎, 就不赘述了.</p><h2 id="Automator服务"><a href="#Automator服务" class="headerlink" title="Automator服务"></a>Automator服务</h2><p>把写好的包装器放到<code>~/bin</code>下, 编写简单的工作流<code>Mathpix Snip OCR API</code></p><p><figure class="null"><img src="automator_workflow.png" alt=" "><figcaption> </figcaption></figure></p><p>然后在系统设置-键盘-快捷键设置服务的快捷键</p><p><figure class="null"><img src="shortcut.png" alt=" "><figcaption> </figcaption></figure></p><p>如此一来, <code>cmd+shift+4</code>将公式截屏到剪贴板后<code>cmd+shift+M</code>, 等待片刻即可从剪贴板黏贴转换好的公式. 大功告成!</p><h2 id="黏贴到到Word公式中"><a href="#黏贴到到Word公式中" class="headerlink" title="黏贴到到Word公式中"></a>黏贴到到Word公式中</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>使用pillow包来获取剪贴板图片: <a href="https://zhuanlan.zhihu.com/p/83678942" target="_blank" rel="noopener">Mathpix收费了？快使用API吧，一个月免费识别1000次！</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写MathpixOCR API的Python包装器和简单的Automator workflow, 模拟Mathpix Snip Tool的公式识别体验.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="LaTeX" scheme="http://shigaro.org/tags/LaTeX/"/>
    
      <category term="MathpixOCR" scheme="http://shigaro.org/tags/MathpixOCR/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记(三)——用pyecharts制作统计地图</title>
    <link href="http://shigaro.org/2019/10/20/speaker-map/"/>
    <id>http://shigaro.org/2019/10/20/speaker-map/</id>
    <published>2019-10-20T14:47:28.000Z</published>
    <updated>2019-10-20T14:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>以会议报告人所在机构的分布为例, 介绍如何基于pyecharts制作地理分布图.</p></div><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间去深圳参加一个研究方向有关的会议, 国内做实验和理论研究的老师都来了, 于是心血来潮想有没有可能做一个统计来看看老师们所在机构的地理分布. 虽然报告人并不多, 但应该也能提供一些定性的信息, 也算是学习一种图片制作和数据展示技巧.<br>经过一番搜索, 决定采用Python包<code>pyecharts</code>中的地理图标<code>Geo</code>类来制作. 使用Python版本为3.7.1, pyecharts版本为1.5.1.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先通过pip安装pyecharts</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyecharts</span><br></pre></td></tr></table></figure><p>同时安装中国省市地图包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip echarts-china-provinces-pypkg echarts-china-cities-pypkg</span><br></pre></td></tr></table></figure><p>为方便直接输出图片, 安装<code>snapshot_selenium</code>或者<code>snapshot_phantomjs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip snapshot_selenium snapshot_phantomjs</span><br></pre></td></tr></table></figure><h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><p>简化一下存放在<code>site-packages/example</code>里的<code>geo_example.py</code>, 得到下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Geo, Page</span><br><span class="line"><span class="keyword">from</span> pyecharts.faker <span class="keyword">import</span> Collector</span><br><span class="line"><span class="keyword">from</span> pyecharts.render <span class="keyword">import</span> make_snapshot</span><br><span class="line"><span class="comment">#from snapshot_selenium import snapshot</span></span><br><span class="line"><span class="keyword">from</span> snapshot_phantomjs <span class="keyword">import</span> snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># speaker.json存储了以speaker老师名字为key的字典</span></span><br><span class="line"><span class="comment"># 包含"省份"和"方向"两个key-value.</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"speaker.json"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> h:</span><br><span class="line">    speaker = json.load(h)</span><br><span class="line">provs = [s[<span class="string">"省份"</span>] <span class="keyword">for</span> s <span class="keyword">in</span> speaker.values()]</span><br><span class="line">data = [[p, provs.count(p)] <span class="keyword">for</span> p <span class="keyword">in</span> set(provs)]</span><br><span class="line"></span><br><span class="line">C = Collector</span><br><span class="line"></span><br><span class="line"><span class="meta">@C.funcs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geo_speakermap</span><span class="params">()</span> -&gt; Geo:</span></span><br><span class="line">    c = (</span><br><span class="line">        Geo()</span><br><span class="line">        .add_schema(maptype=<span class="string">"china"</span>)</span><br><span class="line">        .add(<span class="string">""</span>, data)</span><br><span class="line">        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>))</span><br><span class="line">        .set_global_opts(</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(min_=<span class="number">0</span>, max_=<span class="number">15</span>, type_=<span class="string">"size"</span>),</span><br><span class="line">            title_opts=opts.TitleOpts(title=<span class="string">"报告人分布"</span>),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">make_snapshot(snapshot, Page().add(*[fn() <span class="keyword">for</span> fn, _ <span class="keyword">in</span> C.charts]).render(),</span><br><span class="line">              <span class="string">"speakermap.png"</span>, browser=<span class="string">'Safari'</span>)</span><br></pre></td></tr></table></figure><p>得到分布图如下</p><p><figure class="null"><img src="speakermap.png" alt=" "><figcaption> </figcaption></figure></p><p>报告人主要分布在沿海城市的大学和研究所, 除了bug的帝都. 下面就作图涉及的几个点具体说明一下</p><h3 id="Collector类"><a href="#Collector类" class="headerlink" title="Collector类"></a>Collector类</h3><p><code>Collector</code>是pyechart提供的一个convenient function, 源码很短, 提供了一个列表属性和一个静态方法用<code>Collector.funcs</code>装饰后, 函数返回的<code>Geo</code>实例会加入到列表<code>Collector.charts</code>中.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collector</span>:</span></span><br><span class="line">    charts = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcs</span><span class="params">(fn)</span>:</span></span><br><span class="line">        Collector.charts.append((fn, fn.__name__))</span><br></pre></td></tr></table></figure><p><code>Geo</code>类及其方法的调用利用了方法链语法, 不需要换行符来强制换行.</p><h3 id="全局变量控制"><a href="#全局变量控制" class="headerlink" title="全局变量控制"></a>全局变量控制</h3><p>用<code>set_global_opts</code>方法调整echarts图片的全局设置. 这个方法继承自<code>Chart</code>类.<br>参数<code>visualmap_opts</code>控制左下角标尺, 需要以<code>pyecharts.options.VisualMapOpts</code>实例作为输入.<br>这里因为总人数比较少, 所以调整了最大范围为15, 并用图标尺寸而非颜色来表示数值大小(<code>type_</code>), 加强对比.<br>其他全局变量设置可以参考<a href="https://pyecharts.org/#/zh-cn/global_options" target="_blank" rel="noopener">官网</a>.</p><h3 id="图片生成"><a href="#图片生成" class="headerlink" title="图片生成"></a>图片生成</h3><p><code>pyecharts.render.snapshot</code>提供了<code>make_snapshot</code>函数. <code>make_snapshot</code>实际是selenium或phantomjs的<code>snapshot</code>同名函数的包装.</p><p>这里用phantomjs直接渲染更快一些, 且不会跳出Safari.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于pyecharts的<code>Geo</code>类制作了报告人所在机构的地理分布. 文中所描述的图片制作是一些简单尝试, 还有很多应该可以调教的地方, 比如标记的颜色, 标尺和主图的相对位置. 不过统计数据太少, 机构地点还只限制在省级, 所得到的结论比较trivial.</p><p>echarts还提供了包括全球和国内省市地图在内的其他地图以及word cloud等不同类型的图片呈现方式, 并有现成的例子可供参考, 为地理数据统计和展示提供了一种方便的选择.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/45202403" target="_blank" rel="noopener">知乎 - Python绘制中国地图</a>: 引导我使用pyecharts. 但是这个教程及其中链接的官方网站的API不适用于1.5.1版本.</p><p><a href="https://pyecharts.org/#/zh-cn/intro" target="_blank" rel="noopener">pyecharts官网</a></p><p><a href="https://ramiro.org/notebook/geopandas-choropleth/" target="_blank" rel="noopener">Creating a Choropleth Map of the World in Python using GeoPandas</a>: 做全球数据统计看上去很不错</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以会议报告人所在机构的分布为例, 介绍如何基于pyecharts制作地理分布图.&lt;/p&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://shigaro.org/categories/Programming/"/>
    
    
      <category term="Python" scheme="http://shigaro.org/tags/Python/"/>
    
      <category term="pyecharts" scheme="http://shigaro.org/tags/pyecharts/"/>
    
      <category term="map" scheme="http://shigaro.org/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>GPAW笔记(五)——重启GW</title>
    <link href="http://shigaro.org/2019/09/12/gpaw-5-gw-restart/"/>
    <id>http://shigaro.org/2019/09/12/gpaw-5-gw-restart/</id>
    <published>2019-09-12T11:07:28.000Z</published>
    <updated>2019-09-12T11:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>记录如何修改GPAW源码以允许开启ecut外推(<code>ecut_extrapolation=True</code>)的GW计算重启.</p></div><a id="more"></a><p>在超算上进行大体系计算时, 经常会遇到的问题是计算因为超过了单个任务所需时间而被迫停止. 对于较大体系或者较严格参数的GW计算, 遇到这种问题的可能性很高. 一般SCF计算可以通过读写波函数来重启, 但GW计算重启起来稍微麻烦一些, 也有不同的策略, 比如单独输出介电矩阵元.</p><p>在GPAW中, 重启GW计算可以通过指定<code>restartfile</code>参数来实现. 对于一个可能超时的计算, 在计算初始就指定<code>restartfile</code>, 那么在计算停止后以同样命令重新执行脚本, GPAW就会从停止的地方继续计算.</p><p>GPAW的GW重启机制是将已经计算好的来自<code>nQ</code>个q点的自能和自能梯度以及N存到<code>restartfile</code>里, 中断后读取之, 再从<code>nQ+1</code>个q点开始屏蔽库仑作用和自能的计算.</p><p>在1.5.2版本下, 从<code>gpaw.response.g0w0</code>的源码L1330看一下<code>restartfile</code>所存字典的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'last_q'</span>: nQ,</span><br><span class="line">    <span class="string">'sigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'nsigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'ecut_e'</span>: np.zeros(necut),</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>necut</code>是指定的介电矩阵截断的个数, 在<code>ecut_extrapolation=True</code>时等于3, 否则为1. 屏蔽库仑作用计算采用q点外循环和ecut内循环, 因此对于<code>necut</code>大于1的情况, 如果计算恰好在某个中间的ecut处停止, 那么该q点后面的ecut的计算就会被跳过.</p><p>因此若要在<code>necut</code>大于1的情况, 也即做ecut外推的情况下正确重启GW计算, 需要修改源码. 自己的做法是在字典里增加一个<code>last_ecut</code>的关键词, 定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'last_ecut'</span>: nQ * len(self.ecut_e) + iecut</span><br></pre></td></tr></table></figure><p>并在load时读取到<code>last_ecut</code>属性. 实际上<code>last_ecut</code>同时对q点和ecut进行记数. iecut则作为<code>save_restart_file</code>的额外参数传入. 相应修改跳过判定条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iq, q_c <span class="keyword">in</span> enumerate(self.qd.ibzk_kc):</span><br><span class="line">    <span class="keyword">if</span> iq &lt;= self.last_q - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> ie, ecut <span class="keyword">in</span> enumerate(self,ecut_e):</span><br><span class="line">        <span class="keyword">if</span> ie &lt;= self.last_ecut - iq * len(self.ecut_e):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">if</span> self.restartfile <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.save_restart_file(iq,ie)</span><br></pre></td></tr></table></figure><p>这样就能正确重启包含ecut外推的G0W0计算了. 尽管如此, 因为外面还有一层自洽GW迭代步数的循环, 这样的修改对自恰GW可能还是有问题, 不过对我自己已经足够了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录如何修改GPAW源码以允许开启ecut外推(&lt;code&gt;ecut_extrapolation=True&lt;/code&gt;)的GW计算重启.&lt;/p&gt;
    
    </summary>
    
      <category term="Software" scheme="http://shigaro.org/categories/Software/"/>
    
    
      <category term="GPAW" scheme="http://shigaro.org/tags/GPAW/"/>
    
      <category term="GW" scheme="http://shigaro.org/tags/GW/"/>
    
  </entry>
  
</feed>
