<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>解决macOS上脚本中运行VASP时动态库未载入问题</title>
      <link href="/2020/05/09/macos-script-runvasp/"/>
      <url>/2020/05/09/macos-script-runvasp/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p>macOS上脚本中运行程序遇到dyld: Library not loaded报错. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>疫情在家工mo作yu期间, 准备在自己macOS上用VASP做点小的测试. 因为懒得重复输入命令, 于是写了一个最基本的shell脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">mpirun -np 4 vasp_std</span><br></pre></td></tr></table></figure><p>第一步载入的是事先写好的VASP相关环境变量. 执行, 结果报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dyld: Library not loaded: @rpath/libmkl_intel_lp64.dylib</span><br><span class="line">  Referenced from: /Users/stevezhang/software/sci/vasp/vasp.5.4.4-intel-2018.0.1/common/bin/vasp_std</span><br><span class="line">  Reason: image not found</span><br></pre></td></tr></table></figure><p>也即<code>libmkl_intel_lp64.dylib</code>没有加到<code>DYLD_LIBRARY_PATH</code>中. 可比较奇怪的是, 在命令行里echo <code>DYLD_LIBRARY_PATH</code>, 返回的是预期结果.</p><h2 id="探索与解决"><a href="#探索与解决" class="headerlink" title="探索与解决"></a>探索与解决</h2><p>写一个非常简单的脚本，检查脚本执行过程中的环境变量.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">module load intel/2018.1</span><br><span class="line">module load mpich/3.2.1-intel-2018.0.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>运行前线载入<code>intel/2018.1</code>模块. 运行脚本发现:</p><ul><li>在module load前后, <code>LIBRARY_PATH</code>和<code>PATH</code>同echo的预期结果相同.</li><li>在module load前, <code>DYLD_LIBRARY_PATH</code>是空的.</li><li>在load后, 只有未在zshrc里载入的MPICH里定义的库路径被加入到<code>DYLD_LIBRARY_PATH</code>中.</li></ul><p>搜索后找到几个帖子描述类似问题:</p><p><a href="https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here" target="_blank" rel="noopener">https://stackoverflow.com/questions/35568122/why-isnt-dyld-library-path-being-propagated-here</a><br><a href="https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1" target="_blank" rel="noopener">https://apple.stackexchange.com/questions/212945/unable-to-set-dyld-fallback-library-path-in-shell-on-osx-10-11-1</a></p><p>问题原因是，从El Captian开始, macOS引入了系统完整性保护(system integrity protection, SIP), 在调用系统提供的解释器时，所有<code>DYLD_</code>环境变量会被重设. 在使用module管理环境时, 因为intel模块事先被载入过, 因此脚本里面载入intel模块的行为会被module无视, 因此只有MPICH中的变量加入到<code>DYLD_LIBRARY_PATH</code>中.</p><p>一种解决办法是, 在最开始的shell脚本里面手动设置<code>DYLD_LIBRARY_PATH</code>, 缺点是不容易复用bashrc或zshrc里的内容. 更方便的做法是在shell脚本里load完所有module后reload一下，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">module load vasp/5.4.4-common-intel-2018.0.1</span><br><span class="line">module reload</span><br><span class="line"></span><br><span class="line">mpirun -np 4 vasp_std <span class="comment"># success</span></span><br></pre></td></tr></table></figure><p>另一种可能的办法是<a href="https://blog.csdn.net/qq285744011/article/details/82219340" target="_blank" rel="noopener">关闭SIP</a>, 不过因为reload完全解决了我的需求, 所以就没有尝试这种稍微麻烦些的办法.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python笔记(四)——使用MathpixOCR API进行LaTeX公式识别</title>
      <link href="/2019/10/28/mathpix-ocr/"/>
      <url>/2019/10/28/mathpix-ocr/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍编写MathpixOCR API的Python包装器和简单的Automator workflow, 模拟Mathpix Snip Tool的公式识别体验.<br><a id="more"></a></p><p>用LaTeX准备文献报告时一个比较头疼的问题是输入文献中包含复杂符号的长公式. <a href="https://mathpix.com/" target="_blank" rel="noopener">Mathpix Snip Tool</a> (MST)提供了方便的光学字符识别功能, 可以将包含公式的截图转化为LaTeX代码. 今年MST从完全免费的1.0版本升级到了2.0, 自此个人用户每月只能免费识别50次, 这对于苦逼PhD显然是不够用的.</p><p>好在作为MST底层的MathpixOCR服务, API每月可免费调用1000次, 所得结果和MST相同, 只是没有MST方便的截图和GUI功能. 归根结底, 我们想实现的无非是识别剪贴板中的公式图片, 转化图片到LaTeX代码并复制到剪贴板而已. 这可以通过将OCR与OS命令包装在一起来实现. 官方提供了简单的<a href="https://github.com/Mathpix/api-examples/tree/master/python">例子</a>供我们学习OCR API的使用, 而OS API可以通过Python包和CLI命令调用. 这篇文章是学习包装器编写的记录.</p><p>最终脚本已上传到<a href="https://github.com/minyez/mathpixocr_wrapper">GitHub仓库</a>, 欢迎下载使用.</p><h2 id="API包装"><a href="#API包装" class="headerlink" title="API包装"></a>API包装</h2><h3 id="获取API密钥"><a href="#获取API密钥" class="headerlink" title="获取API密钥"></a>获取API密钥</h3><p>首先需要在Mathpix上注册用户并填写信用卡信息, 注册后获得<code>app_key</code>和<code>app_id</code>作为API密钥.<br>脚本采用了两种从外部获取密钥的方式, 一种是环境变量, 另一种是从同路径下JSON读取.</p><h3 id="从系统剪贴板获取图片"><a href="#从系统剪贴板获取图片" class="headerlink" title="从系统剪贴板获取图片"></a>从系统剪贴板获取图片</h3><p>使用pillow包中的<code>ImageGrab.grabclipboard</code>获取剪贴版中的图片, 并产生<code>Image</code>对象.<br>注意, 此后剪贴板中的临时文件会被删除, 无法再直接通过路径获得.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>im = ImageGrab.grabclipboard()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.path.isfile(im.filename)</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>因此需要先把图片保存下来才能在后续继续使用.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">im = ImageGrab.grabclipboard()</span><br><span class="line">fn = <span class="string">".temp_eq.png"</span></span><br><span class="line">im.save(fn, <span class="string">"PNG"</span>)</span><br></pre></td></tr></table></figure><h3 id="base64编码"><a href="#base64编码" class="headerlink" title="base64编码"></a>base64编码</h3><p>OCR需要把图片编码转化为base64编码格式. 官方例子如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_uri</span><span class="params">(fn)</span>:</span></span><br><span class="line">  image_data = open(fn, <span class="string">"rb"</span>).read()</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"data:image/jpg;base64,"</span> + base64.b64encode(image_data).decode()</span><br></pre></td></tr></table></figure><p><code>b64encode</code>使用Base64规则将一串类字节字符串进行编码, <code>decode</code>方法返回编码后的普通字符串.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec = base64.b64encode(<span class="string">b"abcdefg"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec</span><br><span class="line"><span class="string">b'YWJjZGVmZw=='</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ec.decode()</span><br><span class="line"><span class="string">'YWJjZGVmZw=='</span></span><br></pre></td></tr></table></figure><p>前部附加的字符串是API额外要求的. 我还不太明白<code>jpg</code>的作用, 因为当<code>fn</code>是一个png图片时OCR一样可以正确解析.</p><h3 id="调用API"><a href="#调用API" class="headerlink" title="调用API"></a>调用API</h3><p>通过<code>requests</code>包与OCR API进行通信. 通信数据要求为JSON, 它至少需要包含<code>src</code>和<code>format</code>两个键. <code>src</code>值就是base64编码后的图片字符串, <code>format</code>值为一个列表, 成员为所想要转换的格式, 支持的转化格式包括下面几种.</p><table><thead><tr><th style="text-align:left"><code>format</code>值</th><th style="text-align:left">转化格式</th></tr></thead><tbody><tr><td style="text-align:left"><code>text</code></td><td style="text-align:left">普通文本</td></tr><tr><td style="text-align:left"><code>wolfram</code></td><td style="text-align:left">Mathematica</td></tr><tr><td style="text-align:left"><code>latex_simplified</code></td><td style="text-align:left">简化的latex代码, 括号不包含left或right</td></tr><tr><td style="text-align:left"><code>latex_styled</code></td><td style="text-align:left">left/right控制的latex代码</td></tr></tbody></table><p>利用<code>json</code>包处理JSON文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = json.dump(&#123;<span class="string">"src"</span>: img_base64, <span class="string">"format"</span>: [<span class="string">"latex_simplified"</span>,]&#125;)</span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">'Content-type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  <span class="string">'app_key'</span>: your_app_key,</span><br><span class="line">  <span class="string">'app_id'</span>: your_app_id,</span><br><span class="line">  &#125;</span><br><span class="line">r = requests.post(<span class="string">'https://api.mathpix.com/v3/latex'</span>,</span><br><span class="line">                  data=data, headers=headers)</span><br></pre></td></tr></table></figure><p>通信得到的<code>r.text</code>是一个JSON字符串. 如果OCR识别成功, 则它包含<code>latex_simplified</code>键, 对应值为识别号的简化LaTeX代码.<br>如果识别失败, 则包含<code>error</code>键, 给出具体错误信息. 更复杂的API调用参考<a href="https://docs.mathpix.com/" target="_blank" rel="noopener">官方文档</a>.</p><h3 id="拷贝转化好的LaTeX到系统剪贴板"><a href="#拷贝转化好的LaTeX到系统剪贴板" class="headerlink" title="拷贝转化好的LaTeX到系统剪贴板"></a>拷贝转化好的LaTeX到系统剪贴板</h3><p>参考了<a href="https://gist.github.com/luqmaan/d8bc61e746207bb12f11" target="_blank" rel="noopener">这个GIST</a>, 使用macOS上的<code>pbcopy</code>将字符串拷贝到系统剪贴板.<br>另一种办法是直接打印到标准输出, 然后用Automator服务中的功能拷贝到剪贴板.</p><h3 id="附加功能"><a href="#附加功能" class="headerlink" title="附加功能"></a>附加功能</h3><p>比如每月API调用统计以及历史记录, 都保存在JSON文件中. 实现说起来比较琐碎, 就不赘述了.</p><h2 id="Automator服务"><a href="#Automator服务" class="headerlink" title="Automator服务"></a>Automator服务</h2><p>把写好的包装器放到<code>~/bin</code>下, 编写简单的工作流<code>Mathpix Snip OCR API</code></p><p><figure class="null"><img src="automator_workflow.png" alt=" "><figcaption> </figcaption></figure></p><p>然后在系统设置-键盘-快捷键设置服务的快捷键</p><p><figure class="null"><img src="shortcut.png" alt=" "><figcaption> </figcaption></figure></p><p>如此一来, <code>cmd+shift+4</code>将公式截屏到剪贴板后<code>cmd+shift+M</code>, 等待片刻即可从剪贴板黏贴转换好的公式. 大功告成!</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>使用pillow包来获取剪贴板图片: <a href="https://zhuanlan.zhihu.com/p/83678942" target="_blank" rel="noopener">Mathpix收费了？快使用API吧，一个月免费识别1000次！</a></p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> MathpixOCR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python笔记(三)——用pyecharts制作统计地图</title>
      <link href="/2019/10/20/speaker-map/"/>
      <url>/2019/10/20/speaker-map/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文以会议报告人所在机构的分布为例, 介绍了如何基于pyecharts制作地理分布图.<br><a id="more"></a></p><p>前段时间去深圳参加一个研究方向有关的会议, 国内做实验和理论研究的老师都来了, 于是心血来潮想有没有可能做一个统计来看看老师们所在机构的地理分布. 虽然报告人并不多, 但应该也能提供一些定性的信息, 也算是学习一种图片制作和数据展示技巧.<br>经过一番搜索, 决定采用Python包<code>pyecharts</code>中的地理图标<code>Geo</code>类来制作. 使用Python版本为3.7.1, pyecharts版本为1.5.1.</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先通过pip安装pyecharts</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyecharts</span><br></pre></td></tr></table></figure><p>同时安装中国省市地图包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip echarts-china-provinces-pypkg echarts-china-cities-pypkg</span><br></pre></td></tr></table></figure><p>为方便直接输出图片, 安装<code>snapshot_selenium</code>或者<code>snapshot_phantomjs</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip snapshot_selenium snapshot_phantomjs</span><br></pre></td></tr></table></figure><h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><p>简化一下存放在<code>site-packages/example</code>里的<code>geo_example.py</code>, 得到下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Geo, Page</span><br><span class="line"><span class="keyword">from</span> pyecharts.faker <span class="keyword">import</span> Collector</span><br><span class="line"><span class="keyword">from</span> pyecharts.render <span class="keyword">import</span> make_snapshot</span><br><span class="line"><span class="comment">#from snapshot_selenium import snapshot</span></span><br><span class="line"><span class="keyword">from</span> snapshot_phantomjs <span class="keyword">import</span> snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment"># speaker.json存储了以speaker老师名字为key的字典</span></span><br><span class="line"><span class="comment"># 包含"省份"和"方向"两个key-value.</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"speaker.json"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> h:</span><br><span class="line">    speaker = json.load(h)</span><br><span class="line">provs = [s[<span class="string">"省份"</span>] <span class="keyword">for</span> s <span class="keyword">in</span> speaker.values()]</span><br><span class="line">data = [[p, provs.count(p)] <span class="keyword">for</span> p <span class="keyword">in</span> set(provs)]</span><br><span class="line"></span><br><span class="line">C = Collector</span><br><span class="line"></span><br><span class="line"><span class="meta">@C.funcs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">geo_speakermap</span><span class="params">()</span> -&gt; Geo:</span></span><br><span class="line">    c = (</span><br><span class="line">        Geo()</span><br><span class="line">        .add_schema(maptype=<span class="string">"china"</span>)</span><br><span class="line">        .add(<span class="string">""</span>, data)</span><br><span class="line">        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="keyword">False</span>))</span><br><span class="line">        .set_global_opts(</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(min_=<span class="number">0</span>, max_=<span class="number">15</span>, type_=<span class="string">"size"</span>),</span><br><span class="line">            title_opts=opts.TitleOpts(title=<span class="string">"报告人分布"</span>),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">make_snapshot(snapshot, Page().add(*[fn() <span class="keyword">for</span> fn, _ <span class="keyword">in</span> C.charts]).render(),</span><br><span class="line">              <span class="string">"speakermap.png"</span>, browser=<span class="string">'Safari'</span>)</span><br></pre></td></tr></table></figure><p>得到分布图如下</p><p><figure class="null"><img src="speakermap.png" alt=" "><figcaption> </figcaption></figure></p><p>报告人主要分布在沿海城市的大学和研究所, 除了bug的帝都. 下面就作图涉及的几个点具体说明一下</p><h3 id="Collector类"><a href="#Collector类" class="headerlink" title="Collector类"></a>Collector类</h3><p><code>Collector</code>是pyechart提供的一个convenient function, 源码很短, 提供了一个列表属性和一个静态方法用<code>Collector.funcs</code>装饰后, 函数返回的<code>Geo</code>实例会加入到列表<code>Collector.charts</code>中.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collector</span>:</span></span><br><span class="line">    charts = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funcs</span><span class="params">(fn)</span>:</span></span><br><span class="line">        Collector.charts.append((fn, fn.__name__))</span><br></pre></td></tr></table></figure><p><code>Geo</code>类及其方法的调用利用了方法链语法, 不需要换行符来强制换行.</p><h3 id="全局变量控制"><a href="#全局变量控制" class="headerlink" title="全局变量控制"></a>全局变量控制</h3><p>用<code>set_global_opts</code>方法调整echarts图片的全局设置. 这个方法继承自<code>Chart</code>类.<br>参数<code>visualmap_opts</code>控制左下角标尺, 需要以<code>pyecharts.options.VisualMapOpts</code>实例作为输入.<br>这里因为总人数比较少, 所以调整了最大范围为15, 并用图标尺寸而非颜色来表示数值大小(<code>type_</code>), 加强对比.<br>其他全局变量设置可以参考<a href="https://pyecharts.org/#/zh-cn/global_options" target="_blank" rel="noopener">官网</a>.</p><h3 id="图片生成"><a href="#图片生成" class="headerlink" title="图片生成"></a>图片生成</h3><p><code>pyecharts.render.snapshot</code>提供了<code>make_snapshot</code>函数. <code>make_snapshot</code>实际是selenium或phantomjs的<code>snapshot</code>同名函数的包装.</p><p>这里用phantomjs直接渲染更快一些, 且不会跳出Safari.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于pyecharts的<code>Geo</code>类制作了报告人所在机构的地理分布. 文中所描述的图片制作是一些简单尝试, 还有很多应该可以调教的地方, 比如标记的颜色, 标尺和主图的相对位置. 不过统计数据太少, 机构地点还只限制在省级, 所得到的结论比较trivial.</p><p>echarts还提供了包括全球和国内省市地图在内的其他地图以及word cloud等不同类型的图片呈现方式, 并有现成的例子可供参考, 为地理数据统计和展示提供了一种方便的选择.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/45202403" target="_blank" rel="noopener">知乎 - Python绘制中国地图</a>: 引导我使用pyecharts. 但是这个教程及其中链接的官方网站的API不适用于1.5.1版本.</p><p><a href="https://pyecharts.org/#/zh-cn/intro" target="_blank" rel="noopener">pyecharts官网</a></p><p><a href="https://ramiro.org/notebook/geopandas-choropleth/" target="_blank" rel="noopener">Creating a Choropleth Map of the World in Python using GeoPandas</a>: 做全球数据统计看上去很不错</p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pyecharts </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GPAW笔记(五)——重启GW</title>
      <link href="/2019/09/12/gpaw-5-gw-restart/"/>
      <url>/2019/09/12/gpaw-5-gw-restart/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文简单记录了如何修改GPAW源码以允许开启ecut外推(<code>ecut_extrapolation=True</code>)的GW计算重启.<a id="more"></a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在超算上进行大体系计算时, 经常会遇到的问题是计算因为超过了单个任务所需时间而被迫停止.</p><p>一般SCF计算可以通过读写波函数来重启, 但GW计算重启起来稍微麻烦一些, 也有不同的策略, 比如单独输出介电矩阵元.</p><p>在GPAW中, 重启GW计算可以通过指定<code>restartfile</code>参数来实现. 对于一个可能超时的计算, 在计算初始就指定<code>restartfile</code>, 那么在计算停止后以同样命令重新执行脚本, GPAW就会从停止的地方继续计算.</p><p>GPAW的GW重启机制是将已经计算好的来自<code>nQ</code>个q点的自能和自能梯度以及N存到<code>restartfile</code>里, 中断后读取之, 再从<code>nQ+1</code>个q点开始屏蔽库仑作用和自能的计算.</p><p>在1.5.2版本下, 从<code>gpaw.response.g0w0</code>的源码L1330看一下<code>restartfile</code>所存字典的结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'last_q'</span>: nQ,</span><br><span class="line">    <span class="string">'sigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'nsigma_eskn'</span>: np.zeros((necut, nspins, nkpts, nbandsgw)),</span><br><span class="line">    <span class="string">'ecut_e'</span>: np.zeros(necut),</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>necut</code>是指定的介电矩阵截断的个数, 在<code>ecut_extrapolation=True</code>时等于3, 否则为1. 屏蔽库仑作用计算采用q点外循环和ecut内循环, 因此对于<code>necut</code>大于1的情况, 如果计算恰好在某个中间的ecut处停止, 那么该q点后面的ecut的计算就会被跳过.</p><p>因此若要在<code>necut</code>大于1的情况, 也即做ecut外推的情况下正确重启GW计算, 需要修改源码. 自己的做法是在字典里增加一个<code>last_ecut</code>的关键词, 定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'last_ecut'</span>: nQ * len(self.ecut_e) + iecut</span><br></pre></td></tr></table></figure><p>并在load时读取到<code>last_ecut</code>属性. 实际上<code>last_ecut</code>同时对q点和ecut进行记数. iecut则作为<code>save_restart_file</code>的额外参数传入. 相应修改跳过判定条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iq, q_c <span class="keyword">in</span> enumerate(self.qd.ibzk_kc):</span><br><span class="line">    <span class="keyword">if</span> iq &lt;= self.last_q - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">for</span> ie, ecut <span class="keyword">in</span> enumerate(self,ecut_e):</span><br><span class="line">        <span class="keyword">if</span> ie &lt;= self.last_ecut - iq * len(self.ecut_e):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">if</span> self.restartfile <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self.save_restart_file(iq,ie)</span><br></pre></td></tr></table></figure><p>这样就能正确重启包含ecut外推的G0W0计算了. 尽管如此, 因为外面还有一层自洽GW迭代步数的循环, 这样的修改对自恰GW可能还是有问题, 不过对我自己已经足够了.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPAW </tag>
            
            <tag> GW </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WIEN2k笔记(二)——SCAN metaGGA计算</title>
      <link href="/2019/08/09/wien2k-scan/"/>
      <url>/2019/08/09/wien2k-scan/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总结WIEN2k中进行SCAN meta-GGA泛函计算的工作流程, 进行简单的参数收敛测试.<br><a id="more"></a></p><h2 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h2><p>WIEN2k在v16.1版本后支持SCAN (Strongly Constrained and Appropriately Normed) meta-GGA泛函的DFT计算. 该泛函目前在分子和固体结构预测上取得了很大成功, 具体可以参看Sun等在2015年的PRL, 2016年的NC.</p><p>根据手册(p113, WIEN2k_17.1, release 07/03/2017), 在WIEN2k中作SCAN计算的工作流程如下</p><ol><li><p>先用和PBE相同的方式初始化. 这里在非交互模式下, 全部用默认值</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_lapw -b -numk 1000 -ecut -6 -rkmax 7.0</span><br></pre></td></tr></table></figure></li><li><p>运行一步PBE计算.</p></li><li>自洽运行SCAN计算.</li></ol><p>初始化后的流程可以用下面的脚本概括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">cn = <span class="string">"Si"</span> <span class="comment"># case name</span></span><br><span class="line"><span class="comment"># 第一步: 拷贝样例文件的case.inm_vresp</span></span><br><span class="line">cp <span class="variable">$WIENROOT</span>/SRC_templates/case.inm_vresp <span class="variable">$cn</span>.inm_vresp</span><br><span class="line"><span class="comment"># 第二步: 用PBE泛函作单步计算</span></span><br><span class="line">sed -i <span class="string">"s/XC_SCAN /XC_PBE /g"</span> <span class="variable">$cn</span>.in0</span><br><span class="line">run_lapw -i 1</span><br><span class="line"><span class="comment"># 第三步: 用SCAN作自洽场计算</span></span><br><span class="line">sed -i <span class="string">"s/XC_PBE /XC_SCAN /g"</span> <span class="variable">$cn</span>.in0</span><br><span class="line">rm -f <span class="variable">$cn</span>.broyd*</span><br><span class="line">run_lapw -ec 0.00000001 -cc 0.00001</span><br></pre></td></tr></table></figure><h2 id="相关参数测试"><a href="#相关参数测试" class="headerlink" title="相关参数测试"></a>相关参数测试</h2><p>根据手册, 主要对in0中FFT格点<code>IFFT</code>和in2中电子密度展开截断<code>GMAX</code>进行测试. 测试体系为硅, 晶格常数10.405822 Bohr, RMT取2.24.</p><p>测试针对的是总能量, 因为WIEN2k中SCAN能量泛函不是自洽包含的, 解KS方程时用的势是PBE的势, 所以在<strong>WIEN2k中</strong>用PBE和SCAN得到的带隙是相同的. 具体见这一条<a href="https://www.mail-archive.com/wien@zeus.theochem.tuwien.ac.at/msg17640.html" target="_blank" rel="noopener">WIEN2k mailing list</a>.</p><p>PBE总能量的收敛. 可以看到在默认的GMAX=12, IFFT=40的情况下, PBE总能量已经充分收敛到0.1 meV以下.</p><table><thead><tr><th style="text-align:center">GMAX</th><th style="text-align:center">IFFT=40</th><th style="text-align:center">60</th><th style="text-align:center">80</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">-1160.14169256</td><td style="text-align:center">-1160.14169460</td><td style="text-align:center">-1160.14169529</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">-1160.14169232</td><td style="text-align:center">-1160.14169441</td><td style="text-align:center">-1160.14169504</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">-1160.14169228</td><td style="text-align:center">-1160.14169437</td><td style="text-align:center">-1160.14169501</td></tr></tbody></table><p>SCAN总能量的收敛. 比较默认值和最大的参数, 差值大约为4 meV. 可见对这两个参数而言, SCAN收敛速度确实比PBE慢, 尤其是IFFT.</p><table><thead><tr><th style="text-align:center">GMAX</th><th style="text-align:center">IFFT=40</th><th style="text-align:center">60</th><th style="text-align:center">80</th></tr></thead><tbody><tr><td style="text-align:center">12</td><td style="text-align:center">-1160.80053722</td><td style="text-align:center">-1160.80033890</td><td style="text-align:center">-1160.80026834</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">-1160.80050967</td><td style="text-align:center">-1160.80031217</td><td style="text-align:center">-1160.80024159</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">-1160.80053445</td><td style="text-align:center">-1160.80033894</td><td style="text-align:center">-1160.80026946</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Sun, J. et al. Strongly Constrained and Appropriately Normed Semilocal Density Functional. <a href="http://link.aps.org/doi/10.1103/PhysRevLett.115.036402" target="_blank" rel="noopener">Phys. Rev. Lett. 115, 036402 (2015)</a></p><p>Perdew, J. et al. Semilocal density functionals and constraint satisfaction. <a href="https://onlinelibrary.wiley.com/doi/full/10.1002/qua.25100" target="_blank" rel="noopener">Int. J. Quantum Chem. 116, 847-851 (2016)</a></p><p>Sun, J. et al. Accurate first-principles structures and energies of diversely bonded systems from an efficient density functional. <a href="https://www.nature.com/articles/nchem.2535" target="_blank" rel="noopener">Nat. Chem. 8, 831-836 (2016)</a></p><p>Supplementary material: Performance of various density-functional approximations for cohesive properties of 64 bulk solids. <a href="https://th.fhi-berlin.mpg.de/site/uploads/Publications/suppl-mater-NJP108118-R1.pdf" target="_blank" rel="noopener">Link</a></p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIEN2k </tag>
            
            <tag> DFT </tag>
            
            <tag> SCAN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>XmGrace小技巧汇总</title>
      <link href="/2019/07/31/grace-tips/"/>
      <url>/2019/07/31/grace-tips/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文收集了一些笔者常用的(Xm)Grace使用的技巧.<a id="more"></a> 下面的操作均可以在<a href="https://sourceforge.net/projects/qtgrace/" target="_blank" rel="noopener">qtgrace</a>下实现.</p><h2 id="数据集变换"><a href="#数据集变换" class="headerlink" title="数据集变换"></a>数据集变换</h2><p>Grace中支持多种数据处理, 从简单的求前后两点的差, 到复杂的函数变换和非线性拟合.</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>XmGrace包含差分功能, 支持三种不同差分方式: 向前差分(Forward), 向后差分(Backword)或者居中差分(centered).</p><p>$$<br>\begin{aligned}<br>\text{forward} &amp;: y’_{i, f} = \frac{y_{i+1}-y_i}{x_{i+1}-x_i}\\<br>\text{backward} &amp;: y’_{i, b} = \frac{y_i-y_{i-1}}{x_i-x_{i-1}}\\<br>\text{centered} &amp;: y’_{i, c} = \frac{y_{i+1}-y_{i-1}}{x_{i+1}-x_{i-1}}\\<br>\end{aligned}<br>$$</p><p>以函数$y=4(x-0.5)^2$为例, 其导数$y’=8x-4$.</p><ol><li><p>选中差分功能: Data-&gt;Tranformation-&gt;Differences</p><p> <figure class="null"><img src="differences_1.jpg" alt="选中XmGrace的差分功能"><figcaption>选中XmGrace的差分功能</figcaption></figure></p></li><li><p>选中一组数据, 确认差分方案</p><p> <figure class="null"><img src="differences_2.jpg" alt="差分功能界面, 向前差分"><figcaption>差分功能界面, 向前差分</figcaption></figure></p></li><li><p>Accept确认.</p></li><li><p>检查差分结果. 需要注意, 这里向前向后差分结果是相同的, 原因是向后差分的横坐标错了. 因此建议使用向前或居中差分.</p><p> <figure class="null"><img src="differences_3.jpg" alt="差分功能界面, 向前差分"><figcaption>差分功能界面, 向前差分</figcaption></figure></p></li></ol><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p>用<code>Evaluate expression</code>功能, 可以对数据进行自定义的函数变换. 它可以对单组数据的xy进行操作, 也可以在多组数据间操作, 非常方便. 该功能和Differences一样在Transformations标签里, 具体位置见第一张图.</p><p><figure class="null"><img src="eval_expr_1.jpg" alt="表达式求值, 对数据作变换"><figcaption>表达式求值, 对数据作变换</figcaption></figure></p><ol><li>选中想要操作的数据.</li><li>填写函数变换的表达式.</li><li>勾选Sync. selection, 使变换后的数据直接替换原有数据set. 如果不勾选, Destination下的数据栏中也没有选中任何set, 则变换后的数据会存在新的set中.</li><li>确认.</li></ol><p>这里主要说一下第二条. 在写表达式时, <code>y</code>表示纵坐标, <code>x</code>表示横坐标. 一些常用的变换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 向上平移0.5</span><br><span class="line">y = y + 0.5</span><br><span class="line"># 以第10个数据为零点进行平移</span><br><span class="line">y = y - y[9]</span><br><span class="line"># 求G0.S0和G1.S1之间的差</span><br><span class="line">y = G0.S0.y - G1.S1.y</span><br><span class="line"># 求自然对数</span><br><span class="line">y = ln(y)</span><br><span class="line"># 将横坐标转为角度</span><br><span class="line">x = x * 180 / PI</span><br></pre></td></tr></table></figure><p>更多的函数可以参考官网<a href="http://plasma-gate.weizmann.ac.il/Xmgr/doc/trans.html" target="_blank" rel="noopener">Xmgr: transformations</a></p><h2 id="双y轴-Double-y-axis"><a href="#双y轴-Double-y-axis" class="headerlink" title="双y轴(Double y-axis)"></a>双y轴(Double y-axis)</h2><p>参考这一<a href="sachinashanbhag.blogspot.com/2012/06/grace-tutorial-how-to-plot-graph-with.html">链接</a>, 制作包含两个不同y轴的图, 以在同一张图中展示用有相同横坐标, 但纵坐标范围不同的两组数据.</p><p><figure class="null"><img src="double_y_1.jpg" alt=" "><figcaption> </figcaption></figure></p><ol><li>在窗口个中放置两张并排的图. Edit-&gt;Arrange graphs…</li><li>将cols改为2.</li><li><p>确认.</p><p> <figure class="null"><img src="double_y_2.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>将右图盖到左图上. Edit-&gt;Overlay graphs…</p></li><li>选中G1为要覆盖的图.</li><li>选中G0为被覆盖上的图.</li><li>将Smart axis hint设置为”Same X axis scaling”.</li><li><p>确认. 这个时候两张图覆盖在了一起, 都窝在整个窗口的左侧.</p><p> <figure class="null"><img src="double_y_3.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>调节图的范围. Plot-&gt;Graph appearance. 在Viewpoint设置G0的xmax, 例如1.15.</p></li><li>对G1作同样的操作.</li><li><p>确认.</p><p><figure class="null"><img src="double_y_4.jpg" alt=" "><figcaption> </figcaption></figure></p></li><li><p>为了分辨两个y轴, 用不同的颜色来区分. 双击右侧的y轴</p></li><li>确认在目前正在操作G1.</li><li>正常操作, 调节G1 y轴的属性.</li><li>确认.</li></ol><p>有一点需要注意的是, 当调整y轴粗细比1大的时候, 可能会在某个y轴上看到黑线. 这是图的边框, 可以通过将Graph appearance中Frame标签下Frame box的透明度调到最低来消除.</p><h2 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h2><p>在XmGrace里输入坐标轴标记或者图例时, 有时会需要输入一些希腊字母或上下标之类的复杂组合, 或者使用斜体以表示物理量.</p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>单独的上下标比较容易, 分别<code>a\Sb\N</code>是<code>c\sd\N</code>. 要输入具有上下标的符号, 用<code>a\Sb\N\sc\N</code>会使得下标或上标与符号隔得太远. 此时可以用<code>\v{}</code>或者<code>\h{}</code>分别调整垂直和水平的位置. 比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a\Sb\N\s\v&#123;0.2&#125;\h&#123;-0.5&#125;c\N</span><br></pre></td></tr></table></figure><p><figure class="null"><img src="simult_supsub.png" alt=" "><figcaption> </figcaption></figure></p><h3 id="希腊字母与字体"><a href="#希腊字母与字体" class="headerlink" title="希腊字母与字体"></a>希腊字母与字体</h3><p>希腊字符使用和字体调整本质上是相同的, 因为希腊字母实际上使用的是Symbol字体. 使用某种字体对应的语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;font&#125;text in font\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>比如斜体的Times New Roman</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;Times-Italic&#125;italic here\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>希腊字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\f&#123;Symbol&#125;G\f&#123;&#125; = \xG\f&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>\x</code>其实等价于<code>\f{Symbol}</code>.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XmGrace </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Valgrind笔记(二)——编译器依赖与内存泄漏类型再探</title>
      <link href="/2019/07/05/valgrind-2/"/>
      <url>/2019/07/05/valgrind-2/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>利用Valgrind检测自定义类中内存分配和释放情况. 报告结果依赖于编译器.<br><a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近考虑重构GAP代码, 于是学习了有关Fortran面向对象编程的知识, 接触到了设计模式(Design Pattern)的概念. 其中使用自定义类和用委派关系实现继承是自己之前很少在Fortran中用的, 主要还是面向过程的编程思维. 事实上面向对象的思维也是在研究生后学Python过程中慢慢转过去的. 有关设计模式的学习内容以后有机会再整理上来.</p><p>这篇文章算是记录一点点在Fortran中进行面向对象编程的实践, 主要用的是<a href="main.f90">main.f90</a>和<a href="mytypes.f90">mytypes.f90</a>这两段非常短的代码.</p><ul><li>mytypes.f90包含一个模块, 其中定义了<code>myarrays</code>类, 其数据包含两个可分配数组, 分别是一维整型数组和二维浮点数数组, 并定义了相关constructor和destructor例程.</li><li>main.f90是主程序, 仅调用constructor和destructor方法, 因此原则上没有内存泄漏.</li></ul><p>接下来就是用Valgrind作内存检测, 看一看. 编译用的Makefile在<a href="Makefile">这里</a>, 编译得到的可执行程序是<code>test</code>. 测试平台是Fedora 27.</p><h2 id="依赖编译器的Valgrind报告"><a href="#依赖编译器的Valgrind报告" class="headerlink" title="依赖编译器的Valgrind报告"></a>依赖编译器的Valgrind报告</h2><h3 id="gfortran编译"><a href="#gfortran编译" class="headerlink" title="gfortran编译"></a>gfortran编译</h3><p>使用gfortran (GCC 7.3.1)编译得到的<code>test</code>, Valgrind检测没有报错, 但堆调用中的alloc数为23, 比<code>new_my_array</code>例程中<code>allocate</code>语句(2)要多很多.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full --show-leak-kinds=all ./test</span><br><span class="line">==10854== Memcheck, a memory error detector</span><br><span class="line">==10854== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==10854== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==10854== Command: ./test</span><br><span class="line">==10854==</span><br><span class="line">==10854==</span><br><span class="line">==10854== HEAP SUMMARY:</span><br><span class="line">==10854==     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">==10854==   total heap usage: 23 allocs, 23 frees, 13,520 bytes allocated</span><br><span class="line">==10854==</span><br><span class="line">==10854== All heap blocks were freed -- no leaks are possible</span><br><span class="line">==10854==</span><br><span class="line">==10854== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==10854== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><h3 id="Intel-Fortran编译"><a href="#Intel-Fortran编译" class="headerlink" title="Intel Fortran编译"></a>Intel Fortran编译</h3><p>用Intel Fortran (2018 update 1)编译, 堆调用中的alloc数为4, 虽然也大于2但比gfortran里的23要小. 此外, Valgrind报告了32 bytes的”still reachable”泄漏, 这一泄漏和该版本Fedora中glibc的<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1624387" target="_blank" rel="noopener">bug</a>有关. 没有报错.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full --show-leak-kinds=all ./test</span><br><span class="line">==13583== Memcheck, a memory error detector</span><br><span class="line">==13583== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==13583== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==13583== Command: ./test</span><br><span class="line">==13583==</span><br><span class="line">==13583==</span><br><span class="line">==13583== HEAP SUMMARY:</span><br><span class="line">==13583==     in use at exit: 32 bytes in 1 blocks</span><br><span class="line">==13583==   total heap usage: 4 allocs, 3 frees, 152 bytes allocated</span><br><span class="line">==13583==</span><br><span class="line">==13583== 32 bytes in 1 blocks are still reachable in loss record 1 of 1</span><br><span class="line">==13583==    at 0x4C2F01A: calloc (vg_replace_malloc.c:752)</span><br><span class="line">==13583==    by 0x5971714: _dlerror_run (in /usr/lib64/libdl-2.26.so)</span><br><span class="line">==13583==    by 0x5971129: dlsym (in /usr/lib64/libdl-2.26.so)</span><br><span class="line">==13583==    by 0x41165E: real_aio_init (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==    by 0x40849B: for__once_private (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==    by 0x4066B4: for_rtl_init_ (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==    by 0x402948: main (in /home/stevezhang/codes/code-self-teaching/f90/oop/derived_types/test)</span><br><span class="line">==13583==</span><br><span class="line">==13583== LEAK SUMMARY:</span><br><span class="line">==13583==    definitely lost: 0 bytes in 0 blocks</span><br><span class="line">==13583==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==13583==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==13583==    still reachable: 32 bytes in 1 blocks</span><br><span class="line">==13583==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==13583==</span><br><span class="line">==13583== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==13583== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>接下来做一些小的实验. 如果在主程序中特意省略掉destructor, 会得到104 bytes的”possibly lost”, 同时Error Summary中出现两个错误.<br>比较奇怪的是, 原则上当rank为2时, 2个整型和4个浮点数对应的内存损失为24 bytes.</p><p>进一步实验</p><ul><li>将rank从2增加到4, 损失增加到160 bytes. 原则上应该是80 (4整型, 16浮点数).</li><li>增加另一个<code>myarrays</code>对象, 损失增加到208 bytes.</li><li>修改destructor方法<code>destroy_my_array</code>, 跳过二维数组<code>rarr2d</code>的deallocate, 在主程序中调用destructor. 此时内存损失为56 (rank=2)和104 (rank 4) bytes.</li></ul><p>这表明有80 bytes好像被”附着”在每个自定义类的对象上. 更具体的, 每个可分配数组”附着”了40 bytes的内存.</p><h3 id="回看gfortran"><a href="#回看gfortran" class="headerlink" title="回看gfortran"></a>回看gfortran</h3><p>现在回到gfortran编译上, 也是有意地去掉destructor, 看看Valgrind如何响应.</p><p>当rank=2时, Valgrind报告了24 bytes的”still reachable”泄漏, 没有报错. 这个泄漏量和根据数据类型预计的量是一样的, 与此同时Valgrind类认为这一内存泄漏是不构成关键的性能问题.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ valgrind --leak-check=full --show-leak-kinds=all ./test</span><br><span class="line">==16808== Memcheck, a memory error detector</span><br><span class="line">==16808== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==16808== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==16808== Command: ./test</span><br><span class="line">==16808==</span><br><span class="line">==16808==</span><br><span class="line">==16808== HEAP SUMMARY:</span><br><span class="line">==16808==     in use at exit: 24 bytes in 2 blocks</span><br><span class="line">==16808==   total heap usage: 23 allocs, 21 frees, 13,520 bytes allocated</span><br><span class="line">==16808==</span><br><span class="line">==16808== 8 bytes in 1 blocks are still reachable in loss record 1 of 2</span><br><span class="line">==16808==    at 0x4C2CDCB: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==16808==    by 0x400F25: __mytypes_MOD_new_my_array (mytypes.f90:17)</span><br><span class="line">==16808==    by 0x40116C: MAIN__ (main.f90:8)</span><br><span class="line">==16808==    by 0x4011AF: main (main.f90:3)</span><br><span class="line">==16808==</span><br><span class="line">==16808== 16 bytes in 1 blocks are still reachable in loss record 2 of 2</span><br><span class="line">==16808==    at 0x4C2CDCB: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==16808==    by 0x4010C1: __mytypes_MOD_new_my_array (mytypes.f90:20)</span><br><span class="line">==16808==    by 0x40116C: MAIN__ (main.f90:8)</span><br><span class="line">==16808==    by 0x4011AF: main (main.f90:3)</span><br><span class="line">==16808==</span><br><span class="line">==16808== LEAK SUMMARY:</span><br><span class="line">==16808==    definitely lost: 0 bytes in 0 blocks</span><br><span class="line">==16808==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==16808==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==16808==    still reachable: 24 bytes in 2 blocks</span><br><span class="line">==16808==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==16808==</span><br><span class="line">==16808== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==16808== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><h2 id="“内存泄漏”再探"><a href="#“内存泄漏”再探" class="headerlink" title="“内存泄漏”再探"></a>“内存泄漏”再探</h2><p>在检索上面still reachable leak问题的时候, 发现了SO上关于的一个<a href="https://stackoverflow.com/a/3857638" target="_blank" rel="noopener">回答</a></p><blockquote><p>There is more than one way to define “memory leak”. In particular, there are two primary definitions of “memory leak” that are in common usage among programmers.</p><p>The first commonly used definition of “memory leak” is, “Memory was allocated and was not subsequently freed before the program terminated.” However, many programmers (rightly) argue that certain types of memory leaks that fit this definition don’t actually pose any sort of problem, and therefore should not be considered true “memory leaks”.</p><p>An arguably stricter (and more useful) definition of “memory leak” is, “Memory was allocated and cannot be subsequently freed because the program no longer has any pointers to the allocated memory block.” In other words, you cannot free memory that you no longer have any pointers to. Such memory is therefore a “memory leak”. Valgrind uses this stricter definition of the term “memory leak”. This is the type of leak which can potentially cause significant heap depletion, especially for long lived processes.</p><p>The “still reachable” category within Valgrind’s leak report refers to allocations that fit only the first definition of “memory leak”. These blocks were not freed, but they could have been freed (if the programmer had wanted to) because the program still was keeping track of pointers to those memory blocks.</p><p>In general, there is no need to worry about “still reachable” blocks. They don’t pose the sort of problem that true memory leaks can cause. For instance, there is normally no potential for heap exhaustion from “still reachable” blocks. This is because these blocks are usually one-time allocations, references to which are kept throughout the duration of the process’s lifetime. While you could go through and ensure that your program frees all allocated memory, there is usually no practical benefit from doing so since the operating system will reclaim all of the process’s memory after the process terminates, anyway. Contrast this with true memory leaks which, if left unfixed, could cause a process to run out of memory if left running long enough, or will simply cause a process to consume far more memory than is necessary.</p></blockquote><p>翻译如下</p><blockquote><p>定义”内存泄漏”的方式不止一种. 特别的, 在程序员间常用的主要有两种”内存泄漏”的定义.</p><p>第一种常用的定义是, “内存被分配, 随后没有在程序结束前被释放”. 但是, 很多程序员(正确地)主张说符合这一定义的内存泄漏并不会造成问题, 因此并不被认为是真正的内存泄漏.</p><p>“内存泄漏”的一种可能更为严格(也更有用)的定义是, “内存被分配后, 由于程序失去了指向被分配内存块的指针而无法被释放”. 换句话说, 你无法释放没有指针指向的内存. 所以这样的内存属于”内存泄漏”. Valgrind用的是这一更为严格的定义. 这类泄漏可能产生严重的堆损耗, 特别是在长期活动的进程中.</p><p>Valgrind的泄漏报告中”still reachable”分类指的是只满足第一类定义的内存分配. 这些内存块没有被释放, 但他们是可以被释放的(只要程序员愿意), 因为程序仍然保有指向这些内存块的指针.</p><p>一般而言, 不必担心”still reachable”的内存块. 他们不会带来真正的内存泄漏会导致的问题. 比如说, “still reachable”的内存块通常不会导致堆耗尽. 这是因为这些块都是单次分配, 程序在整个生命周期中都保留对他们的指向. 你当然可以梳理整个程序, 保证这些内存块都被释放, 但这实际并没什么好处, 因为操作系统会在进程结束后回收进程的全部内存. 与之相对, 如果真正的内存泄漏没有被修正, 那么就会导致一个进程在运行足够长时间后耗尽所有内存, 或者说消耗比它所必需的多得多的内存.</p></blockquote><p>这是对之前<a href="/2019/03/23/valgrind-1/" title="Valgrind笔记(一)——Memcheck初探">Valgrind笔记(一)——Memcheck初探</a>一文最后的泄漏类型梳理的重要补充. 答主非常细心的区分了两种内存泄漏的类型. 我们重新来看当时的abc程序</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> abc</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">allocatable</span> :: <span class="keyword">data</span>(:)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">allocate</span>(<span class="keyword">data</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>*, rank(<span class="keyword">data</span>), <span class="built_in">size</span>(<span class="keyword">data</span>), loc(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, <span class="number">5</span></span><br><span class="line">        <span class="keyword">data</span>(i-<span class="number">1</span>) = i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>*, <span class="keyword">data</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>*, rank(<span class="keyword">data</span>), <span class="built_in">size</span>(<span class="keyword">data</span>), loc(<span class="keyword">data</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> abc</span><br></pre></td></tr></table></figure><p>并将<code>data</code>越界赋值语句注释. 用gfortran编译会得到20 bytes的definite loss. 如果用ifort, 则会得到60 bytes的possibly lost. 令人摸不着头脑的是, 如果把这一段代码放到main.f90中, 注释掉原来的myarrays的部分, 同样用gfortran编译, 得到的是20 bytes的still reachable leak. ifort仍给出60 bytes的possibly lost.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上非常直接的例子里可以得到的两个结论, 首先是do not oversmart your compiler. 跟人类语言互译一样, 不同编译器可能将一段高级语言翻译成风格不同的机器码, 这可能就是导致Valgrind检测结果不同的原因. 其次, 也是很自然的, 既然编译器存在这样的不确定性, 那么编程人员就应该写好内存分配和释放的语句, 从源头减少这样的不确定性.</p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compilation </tag>
            
            <tag> Fortran </tag>
            
            <tag> Valgrind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GPAW笔记(四)——GW计算</title>
      <link href="/2019/06/28/gpaw-4-gw/"/>
      <url>/2019/06/28/gpaw-4-gw/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文将简单介绍GPAW中的进行准粒子计算的<code>G0W0</code>类, 并使用<code>GWBands</code>类制作单层二硫化钼的能带结构图.<a id="more"></a></p><p>无论是否自洽, GW计算都需要一组单粒子态作为输入, 这组单粒子态中需要包含大量的非占据态. 目前主流是采用Kohn-Sham DFT产生的Kohn-Sham本征态. 这里主要介绍非自洽计算情形, 此时GW结果受到输入影响.</p><p>为了得到包含较多非占据态的本征态一般有两种方法. 第一种是在基态计算中包含大量的非占据态, 这种情况电子步迭代效率低. 第二种是首先在较少非占据态下得到收敛的电子密度(电子密度只与占据态有关), 然后在固定电子密度下对角化Kohn-Sham单电子Hamiltonian. 对于局域和半局域泛函, 当电子密度固定时, 久期行列式就完全确定了, 一步即可得到等于基组数量的非占据态. 对于非局域泛函, 也只需要几步以收敛非局域势算符.</p><p>这里用的例子是单层二硫化钼. 首先用ASE构造二硫化钼模型. 晶格常数相比实验上体相稳定结构略有拉伸.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> mx2</span><br><span class="line">mos2 = mx2(formula=<span class="string">'MoS2'</span>, kind=<span class="string">'2H'</span>, a=<span class="number">3.19</span>, thickness=<span class="number">3.127</span>, size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), vacuum=<span class="number">5.0</span>)</span><br></pre></td></tr></table></figure><h2 id="基态计算与对角化"><a href="#基态计算与对角化" class="headerlink" title="基态计算与对角化"></a>基态计算与对角化</h2><p>关于基态和对角化计算已经在<a href="/2019/06/18/gpaw-2-scf-bs/" title="GPAW笔记(二)——DFT自洽场与能带计算">GPAW笔记(二)——DFT自洽场与能带计算</a>和<a href="/2019/06/19/gpaw-3-diag-gs/" title="GPAW笔记(三)——求解器对全哈密顿量对角化的影响">GPAW笔记(三)——求解器对全哈密顿量对角化的影响</a>中提及. 这里用了一个比较小的平面波截断以减小计算量. 而k值设的比较大. 若k太小, 后面用<code>GWBands</code>作能带插值时VBM和CBM位置会出错.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gpaw <span class="keyword">import</span> GPAW, PW, FermiDirac</span><br><span class="line"></span><br><span class="line">Ecut = <span class="number">300</span></span><br><span class="line">kx = <span class="number">18</span></span><br><span class="line">calc = GPAW(mode=PW(Ecut), xc=<span class="string">'PBE'</span>,</span><br><span class="line">            convergence=&#123;<span class="string">"density"</span>: <span class="number">1e-8</span>&#125;,</span><br><span class="line">            kpts=&#123;<span class="string">'size'</span>: (kx, kx, <span class="number">1</span>), <span class="string">'gamma'</span>: <span class="keyword">True</span>&#125;,</span><br><span class="line">            occupations=FermiDirac(<span class="number">0.001</span>), parallel=&#123;<span class="string">'domain'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">            txt=<span class="string">'gs.txt'</span>)</span><br><span class="line">mos2.set_calculator(calc)</span><br><span class="line"><span class="comment"># 基态SCF</span></span><br><span class="line">mos2.get_potential_energy()</span><br><span class="line">calc.write(<span class="string">'gs.gpw'</span>)</span><br><span class="line"><span class="comment"># 对角化哈密顿量, 将波函数和能量写入文件, 以供GW读取</span></span><br><span class="line">calc.diagonalize_full_hamiltonian()</span><br><span class="line">calc.write(<span class="string">'fulldiag.gpw'</span>, <span class="string">'all'</span>)</span><br></pre></td></tr></table></figure><h2 id="GW计算"><a href="#GW计算" class="headerlink" title="GW计算"></a>GW计算</h2><p>这里用包含4s4p的Mo PAW setup, 因此体系共有14+6+6=26个价电子, 在自旋非极化下有13个占据态, 因此价带顶的指标是12. 现在计算其前5个价带和导带.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gpaw.response.g0w0 <span class="keyword">import</span> G0W0</span><br><span class="line"></span><br><span class="line">diagfile = <span class="string">'fulldiag.gpw'</span></span><br><span class="line">ecut = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">gw = G0W0(calc=diagfile, bands=(<span class="number">8</span>, <span class="number">18</span>), <span class="comment"># VB at index 12</span></span><br><span class="line">          method=<span class="string">"G0W0"</span>, ecut=<span class="number">50</span>, nblocksmax=<span class="keyword">True</span>,</span><br><span class="line">          truncation=<span class="string">'2D'</span>, q0_correction=<span class="keyword">True</span>,</span><br><span class="line">          domega0=<span class="number">0.03</span>, omega2=<span class="number">10</span>,</span><br><span class="line">          filename=<span class="string">'g0w0'</span>, savepckl=<span class="keyword">True</span>)</span><br><span class="line">gw.calculate()</span><br></pre></td></tr></table></figure><p>其中<code>nblocksmax</code>设为True时GPAW将最大化响应函数<code>chi0</code>的分块, 减小每个进程的内存消耗. 8进程测试的内存占用和GW总用时结果如下表, 开启<code>nblocksmax</code>后预测的单进程内存消耗减小, 但是计算消耗时间更长.</p><table><thead><tr><th style="text-align:left"><code>nlocksmax</code></th><th style="text-align:center">Estimate Mem. per proc. (MB)</th><th style="text-align:center">wall time (s)</th></tr></thead><tbody><tr><td style="text-align:left">True</td><td style="text-align:center">30</td><td style="text-align:center">1923</td></tr><tr><td style="text-align:left">False</td><td style="text-align:center">233</td><td style="text-align:center">1429</td></tr></tbody></table><p><code>truncation</code>和<code>q0_correction</code>是针对低维体系的参数, 前者加快对于真空层厚度的收敛, 后者则是加快对面内布里渊区采样格点的收敛. 具体可以参考文献1和3.</p><p>参数<code>domega0</code>和<code>omega2</code>与频率积分有关. <code>domega0</code>决定第一个频率点的位置, <code>omega2</code>决定在何处倍增格点间距. 一般来说带隙越小, <code>domega0</code>就要取得越小以对低频响应采样充分.  显然的, <code>domega0</code>越小, <code>omega2</code>越大, 频率格点数越多, 计算量越大. 目前这个设置可以使K点带隙收敛到2 meV以内.</p><h2 id="作能带图"><a href="#作能带图" class="headerlink" title="作能带图"></a>作能带图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> gpaw.response.gw_bands <span class="keyword">import</span> GWBands</span><br><span class="line"></span><br><span class="line">calcfile = <span class="string">'fulldiag.gpw'</span></span><br><span class="line">gwpckl = <span class="string">'g0w0_results.pckl'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置K点路径</span></span><br><span class="line">K = np.array([<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>])</span><br><span class="line">M = np.array([<span class="number">0.0</span>, <span class="number">0.5</span>, <span class="number">0</span>])</span><br><span class="line">G = np.array([<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>])</span><br><span class="line">kpoints = np.array([G, K/<span class="number">2</span>, K, M, G])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化GWBands对象. bandrange要和G0W0设置一致, 不过这里第二个指标是要包含进去的</span></span><br><span class="line">GW = GWBands(calcfile=calcfile, gwpckl=gwpckl, kpoints=kpoints, bandrange=(<span class="number">8</span>,<span class="number">17</span>))</span><br><span class="line"><span class="comment"># 设置</span></span><br><span class="line">gwbopts=&#123;<span class="string">"nk_Int"</span>: <span class="number">100</span>, <span class="string">"interpolate"</span>: <span class="keyword">True</span>, <span class="string">"vac"</span>: <span class="keyword">False</span>&#125;</span><br><span class="line"><span class="comment"># 提取PBE, GW和GW-SOC能带插值数据</span></span><br><span class="line">pbe = GW.get_gw_bands(SO=<span class="keyword">False</span>, dft=<span class="keyword">True</span>, **gwbopts)</span><br><span class="line">gw = GW.get_gw_bands(SO=<span class="keyword">False</span>, **gwbopts)</span><br><span class="line">gwsoc = GW.get_gw_bands(SO=<span class="keyword">True</span>, **gwbopts)</span><br><span class="line"><span class="comment"># 提取K点路径的一维坐标</span></span><br><span class="line">x_x = gw[<span class="string">'x_k'</span>]</span><br><span class="line">X = gw[<span class="string">'X'</span>]/x_x[<span class="number">-1</span>]</span><br><span class="line">x_x /= x_x[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 对齐VBM</span></span><br><span class="line">ePBE_kn, eGW_kn, eGWsoc_kn = [d[<span class="string">'e_kn'</span>] - d[<span class="string">'vbm'</span>] <span class="keyword">for</span> d <span class="keyword">in</span> [pbe, gw, gwsoc]]</span><br><span class="line"><span class="comment"># 作不同方法得到的能带</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>, figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">styles = [</span><br><span class="line">          &#123;<span class="string">'ls'</span>: <span class="string">'-.'</span>, <span class="string">'marker'</span>: <span class="string">''</span>, <span class="string">'color'</span>: <span class="string">'k'</span>, <span class="string">"lw"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">          &#123;<span class="string">'ls'</span>: <span class="string">'--'</span>, <span class="string">'marker'</span>: <span class="string">''</span>, <span class="string">'color'</span>: <span class="string">'#393b79'</span>, <span class="string">"lw"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">          &#123;<span class="string">'ls'</span>: <span class="string">'-'</span>, <span class="string">'marker'</span>: <span class="string">''</span>, <span class="string">'color'</span>: <span class="string">'#d62728'</span>, <span class="string">"lw"</span>: <span class="number">3</span>&#125;,</span><br><span class="line">         ]</span><br><span class="line"><span class="keyword">for</span> i, bands <span class="keyword">in</span> enumerate([ePBE_kn, eGW_kn, eGWsoc_kn]):</span><br><span class="line">    ax.plot(x_x, bands, **styles[i])</span><br><span class="line"><span class="comment"># 能量零点</span></span><br><span class="line">ax.axhline(<span class="number">0.0</span>, color=<span class="string">'k'</span>, linestyle=<span class="string">':'</span>, lw=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 图例</span></span><br><span class="line">leg_handles = [mpl.lines.Line2D([], [], **style) <span class="keyword">for</span> style <span class="keyword">in</span> styles]</span><br><span class="line">leg_labels = [<span class="string">r'PBE'</span>, <span class="string">r'G$_0$W$_0$'</span>, <span class="string">r'G$_0$W$_0$-SOC'</span>]</span><br><span class="line">ax.legend(leg_handles, leg_labels, fontsize=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlim(<span class="number">0</span>, x_x[<span class="number">-1</span>])</span><br><span class="line">ax.set_ylim([<span class="number">-2</span>, <span class="number">4</span>])</span><br><span class="line">ax.set_ylabel(<span class="string">'Energy (eV)'</span>, fontsize=<span class="number">24</span>)</span><br><span class="line"><span class="comment"># 横坐标特殊k点, 并作分割线</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> X[:<span class="number">-1</span>]:</span><br><span class="line">    plt.axvline(p, color=<span class="string">'#AAAAAA'</span>, ls=<span class="string">'--'</span>, lw=<span class="number">2</span>)</span><br><span class="line">labels_K = [<span class="string">r'$\Gamma$'</span>, <span class="string">r'$T$'</span>, <span class="string">r'$K$'</span>, <span class="string">r'$M$'</span>, <span class="string">r'$\Gamma$'</span>]</span><br><span class="line">plt.xticks(X, labels_K, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">plt.yticks(fontsize=<span class="number">17</span>)</span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.savefig(<span class="string">'MoS2_band_GTKMG.png'</span>, dpi=<span class="number">300</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果如下图. 可以很容易看到, 在不包含SOC情况下, PBE预测单层MoS2具有$\Gamma-K$的间接带隙, 而GW给出的是K上的直接带隙. 包含SOC会导致K点能带裂分, 在GW下进一步增大$\Gamma$点和K点VBM的能差.</p><p><figure class="null"><img src="MoS2_band_GTKMG.png" alt="PBE, GW方法得到的MoS2能带"><figcaption>PBE, GW方法得到的MoS2能带</figcaption></figure></p><p>另外值得注意的一点是CB在$\Gamma-K$上也有一个能量较低的态(在T=0.5K附近). 在DFT下$T_c$与$K_c$能量差肉眼可见, 而在GW尤其是包含SOC下, 这两个态基本是简并的. 考虑到对未占据态的自能修正为正值, 这说明$K_c$的自能修正要大于$T_c$. 定性分析上, $T_c$主要是Mo的$d_{x^2-y^2}$和$d_{xy}$在面内成键, 而$K_c$是Mo的$d_{z^2}$.(文献2) 后者较为定域, 从GW修正DFT离域误差的角度可定性理解.</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>Ismail-Beigi, S. <em>Phys. Rev. B</em> <strong>73</strong>, 233103 (2006)</li><li>Zhang, L.; Zunger, A. <em>Nano Lett.</em> <strong>15</strong>, 949-957 (2015)</li><li>Rasmussen, F. et al. <em>Phys. Rev. B</em> <strong>94</strong>, 155406 (2016)</li><li><a href="https://wiki.fysik.dtu.dk/gpaw/tutorials/gw_tutorial/gw_tutorial.html#quasi-particle-spectrum-of-two-dimensional-materials" target="_blank" rel="noopener">Quasi-particle spectrum of two-dimensional materials - GPAW tutorial</a></li></ol>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPAW </tag>
            
            <tag> GW </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GPAW笔记(三)——求解器对全哈密顿量对角化的影响</title>
      <link href="/2019/06/19/gpaw-3-diag-gs/"/>
      <url>/2019/06/19/gpaw-3-diag-gs/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文比较了GPAW中不同求解器和不同密度收敛条件下对角化哈密顿量得到的本征值. 结果显示, 为了在较大的平面波截断下全对角化得到正确的Kohn-Sham能级, SCF需要使用CG求解器, 并取较严格的密度收敛标准. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>GW, RPA和BSE等多体微扰计算需要大量的未占据态, 因此在进行这些计算前通常需要对当前基组下构造的哈密顿量进行全对角化以得到所有本征对. 在GPAW中, 这一步为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPAW.diagonalize_full_hamiltonian(nbands=<span class="keyword">None</span>, ecut=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p><code>nbands</code>和<code>ecut</code>都设为None时对角化得到的能带数量由平面波截断决定. GPAW这一方法继承自<code>gpaw.paw.PAW</code>, 实际执行对角化命令的是其中的<code>PWWaveFunctions</code>对象.</p><p>问题出现在用600 eV截断的平面波基组计算单层MoS2的GW时. 在默认能带数的PBE基态计算下, GPAW给出MoS2能谱对应于半导体, 费米能级约为-1 eV, 但对角化后的能谱对应的却是一个金属, 费米能级在-200 eV左右. 我想这种情况可能跟对角化的算法和基态收敛情况有关, 于是进行了下面的简单测试.</p><p>测试的GPAW版本是1.5.2, Python为采用Anaconda3/2019.3发行版. C扩展用Intel 2019编译, 数学库为MKL. 使用<code>mx2</code>函数构造MoS2模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> mx2</span><br><span class="line"><span class="keyword">from</span> gpaw <span class="keyword">import</span> GPAW, PW, FermiDirac</span><br><span class="line"></span><br><span class="line">mos2 = mx2(formula=<span class="string">'MoS2'</span>, kind=<span class="string">'2H'</span>, a=<span class="number">3.184</span>, thickness=<span class="number">3.127</span>,</span><br><span class="line">           size=(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), vacuum=<span class="number">10</span>)</span><br><span class="line">mos2.pbc = (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="比较不同求解器"><a href="#比较不同求解器" class="headerlink" title="比较不同求解器"></a>比较不同求解器</h2><p>GPAW提供了五种求解器, CG, Davidson, RMM-DIIS, DirectLCAO, DirectPW. 这里主要讨论前三种. 简单测试DirectPW发现, 它计算的MoS2的$\Gamma$点带隙为1.7 eV, 要小于其他求解器和VASP的计算值2.7 eV. 初始化时求解器参数均使用GPAW的默认设置.</p><p>测试命令如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ecut_kx_pairs = [(<span class="number">300</span>, <span class="number">6</span>), (<span class="number">300</span>, <span class="number">9</span>), (<span class="number">400</span>, <span class="number">12</span>), (<span class="number">400</span>, <span class="number">18</span>), (<span class="number">600</span>, <span class="number">6</span>), (<span class="number">600</span>, <span class="number">18</span>)]</span><br><span class="line">egs = [<span class="string">"cg"</span>, <span class="string">"dav"</span>, <span class="string">"rmm-diis"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Ecut, kx <span class="keyword">in</span> Ecut_kx_pairs:</span><br><span class="line">    <span class="keyword">for</span> eg <span class="keyword">in</span> egs:</span><br><span class="line">        suffix = <span class="string">f"Ecut_<span class="subst">&#123;Ecut&#125;</span>_kx_<span class="subst">&#123;kx&#125;</span>_<span class="subst">&#123;es&#125;</span>"</span></span><br><span class="line">        calc = GPAW(mode=PW(Ecut), xc=<span class="string">"PBE"</span>, eigensolver=es</span><br><span class="line">                    kpts=&#123;<span class="string">'size'</span>: (kx, kx, <span class="number">1</span>), <span class="string">'gamma'</span>: <span class="keyword">True</span>&#125;,</span><br><span class="line">                    occupations=FermiDirac(<span class="number">0.01</span>), parallel=&#123;<span class="string">'domain'</span>: <span class="number">1</span>&#125;,</span><br><span class="line">                    txt=<span class="string">f'MoS2_gs_<span class="subst">&#123;suffix&#125;</span>.txt'</span>)</span><br><span class="line">        mos2.set_calculator(calc)</span><br><span class="line">        mos2.get_potential_energy()</span><br><span class="line">        calc.write(<span class="string">f'MoS2_gs_<span class="subst">&#123;suffix&#125;</span>.gpw'</span>)</span><br><span class="line">        calc.diagonalize_full_hamiltonian()</span><br><span class="line">        calc.write(<span class="string">f'MoS2_fulldiag_<span class="subst">&#123;suffix&#125;</span>.gpw'</span>)</span><br></pre></td></tr></table></figure><p>CG使用4核并行, Davidson和RMM-DIIS使用16核并行. 测试结果如下表, 后三列中的值是分别用对角化和基态迭代计算得到的前20个能级的本征能量差, 定义为</p><p>$$<br>\Delta_{20} \equiv \sum_k\sum^{n&lt;20}_{n=0}{|\epsilon^{diag}_{nk}-\epsilon^{gs}_{nk}|}.<br>$$</p><p>第三列是对角化得到的能带总数. 当取平面波截断到600 eV时, 使用Davidson和RMM-DIIS时的本征能量差非常大. 10次方误差来源是指标为0的能带的能量.</p><table><thead><tr><th style="text-align:left">Ecut</th><th style="text-align:left">kx</th><th style="text-align:left">$N_{pw}$</th><th style="text-align:center">CG</th><th style="text-align:center">Dav</th><th style="text-align:center">RMM-DIIS</th></tr></thead><tbody><tr><td style="text-align:left">300</td><td style="text-align:left">6</td><td style="text-align:left">2368</td><td style="text-align:center">8.2E-01</td><td style="text-align:center">2.6E+00</td><td style="text-align:center">1.6E+01</td></tr><tr><td style="text-align:left">300</td><td style="text-align:left">9</td><td style="text-align:left">2368</td><td style="text-align:center">8.2E-01</td><td style="text-align:center">1.0E+00</td><td style="text-align:center">1.9E+01</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">12</td><td style="text-align:left">3655</td><td style="text-align:center">2.7E-01</td><td style="text-align:center">1.6E+00</td><td style="text-align:center">2.5E+01</td></tr><tr><td style="text-align:left">400</td><td style="text-align:left">18</td><td style="text-align:left">3655</td><td style="text-align:center">4.5E-02</td><td style="text-align:center">2.0E+00</td><td style="text-align:center">5.2E+01</td></tr><tr><td style="text-align:left">600</td><td style="text-align:left">6</td><td style="text-align:left">6666</td><td style="text-align:center">4.7E+00</td><td style="text-align:center">5.6E+09</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">600</td><td style="text-align:left">18</td><td style="text-align:left">6666</td><td style="text-align:center">3.5E+00</td><td style="text-align:center">6.2E+10</td><td style="text-align:center">6.2E+10</td></tr></tbody></table><p>下图是设置三种不同的求解器时, 在600 eV截断下全对角化得到的所有k点上的本征值谱, 横坐标是能带指标. 当GPAW采用Davidson和RMM-DIIS时, 全对角化后部分k点上的能量系统偏低200 eV. 使用CG时怎没有这样的问题.</p><p><figure class="null"><img src="diag_eigensolver.png" alt="600 eV平面波截断时对角化所得本征值"><figcaption>600 eV平面波截断时对角化所得本征值</figcaption></figure></p><p>这里基本可以得到结论, 当需要在较大基组下对角化哈密顿量时, 基态计算采用CG求解器是比较保险的做法. 这里有一个了令人疑惑的地方是, 源码中<code>PWWaveFunctions</code>对象的对角化方法利用的是C扩展中的Scalapack功能, 与求解器应该没有直接的联系, 但结果看来求解器确实会影响对角化结果.</p><h2 id="CG下比较不同密度收敛限"><a href="#CG下比较不同密度收敛限" class="headerlink" title="CG下比较不同密度收敛限"></a>CG下比较不同密度收敛限</h2><p>下面测试密度收敛限对对角化所得的本征值的影响. 这里Ecut仍然取较大的600 eV, 求解器使用CG. 通过改变GPAW初始化时的<code>convergence</code>参数, 调整密度收敛限, 如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calc = GPAW(mode=PW(Ecut), xc=<span class="string">"PBE"</span>, eigensolver=es,</span><br><span class="line">            convergence=&#123;<span class="string">'density'</span>: <span class="number">1E-6</span>&#125;)</span><br></pre></td></tr></table></figure><p>测试结果如下表. 可以看出, 采用1E-08作为SCF收敛限时, 本征值收敛到非常小的阈值内, 同时SCF和对角化得到的低能能态在能量上完全一致. 另外, 如果不用CG而仍然用Davidson或者RMM-DIIS, 增大密度收敛限$\Delta_{20}$相比上一节没有改善.</p><table><thead><tr><th style="text-align:left">kx</th><th style="text-align:left">Convergence (Log10)</th><th style="text-align:center">$\sum_{nk}{\epsilon_{nk}}$ (w.r.t default)</th><th style="text-align:center">$\Delta_{20}$</th></tr></thead><tbody><tr><td style="text-align:left">6</td><td style="text-align:left">-4.61 (default)</td><td style="text-align:center">0</td><td style="text-align:center">4.7E+00</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">-6</td><td style="text-align:center">4.9383</td><td style="text-align:center">2.7E-04</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">-8</td><td style="text-align:center">5.0000</td><td style="text-align:center">4.0E-09</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">-4.61 (default)</td><td style="text-align:center">0</td><td style="text-align:center">3.5E+00</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">-6</td><td style="text-align:center">9.4296</td><td style="text-align:center">1.5E-06</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left">-8</td><td style="text-align:center">10.018</td><td style="text-align:center">1.5E-08</td></tr></tbody></table><!-- 它们在VASP里也有IALGO和ALGO的相似对应, 分别是58 (Conjugate, All), 38 (Normal)和48 (Very_fast). -->]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPAW </tag>
            
            <tag> DFT </tag>
            
            <tag> Band structure </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GPAW笔记(二)——DFT自洽场与能带计算</title>
      <link href="/2019/06/18/gpaw-2-scf-bs/"/>
      <url>/2019/06/18/gpaw-2-scf-bs/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>以金刚石结构Si为例, 演示了用GPAW计算材料电子能带结构的过程, 对结果进行了简单分析.<a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一年前我在<a href="/2018/07/20/gpaw-1/" title="GPAW笔记(一)——安装及测试">GPAW笔记(一)——安装及测试</a>一文中介绍了GPAW的安装和简单测试. 当时主要是为了比较GPAW, abinit和VASP的<em>GW</em>效率, 于是稍微研究了一下GPAW中参数含义, 运行了一些官方网站上的脚本. 在相近的参数下作了三个程序的<em>GW</em>计算交差后, 就没有再管, 当时也没有留下清楚的学习笔记.</p><p>由于最近实际计算的需要, 我又重新学习GPAW, 着重于DFT能带计算, <em>GW</em>和BSE. 这一篇笔记主要记录了基础DFT计算部分的学习, 包括SCF和能带, 简单分析标准输出. 这里使用的结构是金刚石型的硅, 晶格常数$a=5.43$ (A).</p><h2 id="SCF计算"><a href="#SCF计算" class="headerlink" title="SCF计算"></a>SCF计算</h2><p>从官网例子中改编得的一个SCF计算脚本如下.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> bulk</span><br><span class="line"><span class="keyword">from</span> gpaw <span class="keyword">import</span> GPAW, PW, FermiDirac</span><br><span class="line"></span><br><span class="line">si = bulk(<span class="string">'Si'</span>, <span class="string">'diamond'</span>, a=<span class="number">5.43</span>)</span><br><span class="line">calc = GPAW(mode=PW(<span class="number">200</span>), xc=<span class="string">'PBE'</span>, kpts=&#123;<span class="string">'size'</span>: (<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>), <span class="string">'gamma'</span>: <span class="keyword">True</span>&#125;,</span><br><span class="line">            random=<span class="keyword">True</span>, occupations=FermiDirac(<span class="number">0.01</span>), txt=<span class="string">'Si_gs.txt'</span>)</span><br><span class="line">si.calc = calc</span><br><span class="line">si.get_potential_energy()</span><br><span class="line">calc.write(<span class="string">'Si_gs.gpw'</span>)</span><br></pre></td></tr></table></figure><p>对每行的说明:</p><ul><li>行4: 用<code>bulk</code>方法构造Si模型</li><li>行5-6: 初始化GPAW. 使用平面波基组(截断为200 eV). 泛函为PBE. 布里渊区采样为$\Gamma$中心$8\times8\times8$的均匀格点. 初始波函数随机生成. 占据数计算采用Fermi-Dirac分布, . <code>txt</code>选项指定输出文件.</li><li>行7: 将Si模型的calculator指定为刚刚初始化好的GPAW.</li><li>行8: 开始SCF过程. 具体来说, <code>Atoms.get_potential_energy</code>方法用于获取<code>Atoms._calc</code>的energy属性, 操作上是从<code>Calculator.results</code>字典中提取energy键值. 对于未收敛的GPAW calculator, energy键不存在, 此时会执行<code>GPAW.calculate</code>进行SCF循环, 直到收敛, 添加energy键并返回之.</li><li>行9: 将计算过程的所有信息写入Si_gs.gpw文件中.</li></ul><h2 id="标准输出分析"><a href="#标准输出分析" class="headerlink" title="标准输出分析"></a>标准输出分析</h2><p>标准输出保存在Si_gs.txt中. 主要看三部分. 在200行附近给出SCF迭代的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                     log10-error:    total        iterations:</span><br><span class="line">           time      wfs    density  energy       fermi  poisson</span><br><span class="line">iter:   1  14:49:29  +1.03   +inf   -10.866303    7</span><br><span class="line">iter:   2  14:49:30  -1.97  -0.80   -10.866989    2</span><br><span class="line">iter:   3  14:49:30  -1.01  -0.81   -11.320728    22</span><br><span class="line">iter:   4  14:49:31  -1.94  -0.56   -10.847586    3</span><br><span class="line">iter:   5  14:49:31  -2.71  -1.11   -10.806417    8</span><br><span class="line">iter:   6  14:49:31  -2.69  -1.35   -10.780669    9</span><br><span class="line">iter:   7  14:49:32  -3.97  -2.59   -10.780801    0</span><br><span class="line">iter:   8  14:49:32  -5.11  -2.71   -10.780798    0</span><br><span class="line">iter:   9  14:49:33  -5.83  -2.71   -10.780763    0</span><br><span class="line">iter:  10  14:49:33  -6.76  -3.19   -10.780765    0</span><br><span class="line">iter:  11  14:49:34  -8.02  -3.59   -10.780765    0</span><br><span class="line">iter:  12  14:49:34  -6.82  -3.60   -10.780765    0</span><br><span class="line">iter:  13  14:49:34  -8.06  -3.60   -10.780764    0</span><br><span class="line">iter:  14  14:49:35 -10.08  -3.78   -10.780764    0</span><br><span class="line">iter:  15  14:49:35  -8.45  -3.78   -10.780764    0</span><br><span class="line">iter:  16  14:49:36  -8.00  -3.68   -10.780764    0</span><br><span class="line">iter:  17  14:49:36  -8.17  -3.80   -10.780764    0</span><br><span class="line">iter:  18  14:49:37  -9.30  -3.92   -10.780764    0</span><br><span class="line">iter:  19  14:49:37  -8.99  -3.95   -10.780764    0</span><br><span class="line">iter:  20  14:49:37  -9.83  -4.06   -10.780764    0</span><br><span class="line"></span><br><span class="line">Converged after 20 iterations.</span><br></pre></td></tr></table></figure><p>往下一点是相对PAW原子的总能量成分分析. 从GPAW分析来看, Si在形成晶体后, 电子动能增加, 势能与交换关联能降低. 后面两者容易理解, 但原子形成固体后动能增加这一点从化学成键相悖. 只能说在赝势PAW下, 直接的能量组成并没有物理意义. VASP的OUTCAR中的能量组成分析没有给出动能的部分.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Energy contributions relative to reference atoms: (reference = -15772.688500)</span><br><span class="line"></span><br><span class="line">Kinetic:        +15.782785</span><br><span class="line">Potential:      -13.855376</span><br><span class="line">External:        +0.000000</span><br><span class="line">XC:             -12.678254</span><br><span class="line">Entropy (-ST):   -0.000000</span><br><span class="line">Local:           -0.029919</span><br><span class="line">--------------------------</span><br><span class="line">Free energy:    -10.780764</span><br><span class="line">Extrapolated:   -10.780764</span><br></pre></td></tr></table></figure><p>再往下是关于能带结构的简单信息. 包括费米能级和前两个k点上的价带导带本征值和占据数. 需要注意的是这里的occupancy是该自旋轨道上的电子数乘以k点分数权重的值. 如果是自旋极化计算, 这部分会给出两个自旋通道的占据数, 占据数会变成非极化的一半. $\Gamma$点带隙为2.56 eV.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Fermi level: 5.73099</span><br><span class="line"></span><br><span class="line">Showing only first 2 kpts</span><br><span class="line"> Kpt  Band  Eigenvalues  Occupancy</span><br><span class="line">  0     2      5.31933    0.00391</span><br><span class="line">  0     3      5.31934    0.00391</span><br><span class="line">  0     4      7.87829    0.00000</span><br><span class="line">  0     5      7.87829    0.00000</span><br><span class="line"></span><br><span class="line">  1     2      4.51004    0.02344</span><br><span class="line">  1     3      4.51006    0.02344</span><br><span class="line">  1     4      7.32815    0.00000</span><br><span class="line">  1     5      9.02227    0.00000</span><br></pre></td></tr></table></figure><h2 id="能带计算"><a href="#能带计算" class="headerlink" title="能带计算"></a>能带计算</h2><p>PBE能带计算需要使用SCF得到的电子密度. 官方网站给出的一个能带计算例子如下.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calc = GPAW(<span class="string">'Si_gs.gpw'</span>, nbands=<span class="number">16</span>, fixdensity=<span class="keyword">True</span>, symmetry=<span class="string">'off'</span>,</span><br><span class="line">            kpts=&#123;<span class="string">'path'</span>: <span class="string">'GXWKL'</span>, <span class="string">'npoints'</span>: <span class="number">60</span>&#125;, convergence=&#123;<span class="string">'bands'</span>: <span class="number">8</span>&#125;)</span><br><span class="line">calc.get_potential_energy()</span><br><span class="line">calc.write(<span class="string">'Si_bs.gpw'</span>)</span><br></pre></td></tr></table></figure><p>这里主要需要理解<code>GPAW</code>一行</p><ul><li>第一个参数<code>Si_gs.gpw</code>为读入文件.</li><li><code>nbands</code>为SCF迭代所包含的能带数.</li><li><code>fixdensity=True</code>, 顾名思义, 固定电子密度.</li><li><code>kpts</code>为一个字典, 包含<code>path</code>和<code>npoints</code>两个键. <code>path</code>包含BZ特殊点记号. 这里的路径为G-X-W-K-L, 根据总k点数<code>npoints</code>自动设置所需要计算的k点, 不会重复计算特殊k点. 特殊点之间的k点数不是均匀的.</li><li><code>convergence</code>为一个字典, 包含键<code>band</code>, 值为8. 表示使用最低的8个能级的波函数的Kohn-Sham方程余矢量模方作为收敛判据. 可以使用’all’和<code>-8</code>之类的负值, 后者表示收敛除最后8个外的所有能级. 具体参考<a href="https://wiki.fysik.dtu.dk/gpaw/documentation/manual.html#accuracy-of-the-self-consistency-cycle" target="_blank" rel="noopener">Accuracy of the self-consistency cycle</a>条目.</li></ul><p><code>get_potential_energy</code>开始SCF循环, 结束后将calculator写入Si_bs.gpw.</p><p>GPAW提供了能带分析的帮助方法<code>band_structure</code>. 该方法继承自ASE的<code>Calculator</code>类. 使用方式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">calc = GPAW(<span class="string">'Si_bs.gpw'</span>)    <span class="comment"># 读取Si能带计算结果</span></span><br><span class="line">bs = calc.band_structure()  <span class="comment"># 调用band_structure方法</span></span><br><span class="line">bs.plot(show=<span class="keyword">True</span>, emax=<span class="number">10.0</span>, filename=<span class="string">"Si_bs.png"</span>) <span class="comment"># 作图</span></span><br></pre></td></tr></table></figure><p><code>band_structure</code>方法返回一个<code>ase.dft.band_structure.BandStructure</code>类. 得到能带图如下, 和<a href="https://wiki.fysik.dtu.dk/gpaw/tutorials/bandstructures/bandstructures.html#bandstructures" target="_blank" rel="noopener">官网例子</a>是相同的.</p><p><figure class="null"><img src="Si_bs.png" alt=" "><figcaption> </figcaption></figure></p><h2 id="与电子结构相关的GPAW方法"><a href="#与电子结构相关的GPAW方法" class="headerlink" title="与电子结构相关的GPAW方法"></a>与电子结构相关的GPAW方法</h2><p><code>BandStructure</code>作图非常方便, 但如果是自己作图或者需要能级数据做进一步处理, 就需要从<code>GPAW</code>对象直接获取k点和Kohn-Sham本征值. 一些可能用到的方法如下</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">继承</th><th style="text-align:left">作用</th><th style="text-align:center">常用参数</th><th style="text-align:center">返回</th></tr></thead><tbody><tr><td style="text-align:left"><code>get_fermi_level</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取Fermi能级</td><td style="text-align:center"></td><td style="text-align:center"><code>float</code></td></tr><tr><td style="text-align:left"><code>get_number_of_spins</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取自旋通道数量</td><td style="text-align:center"></td><td style="text-align:center"><code>int</code></td></tr><tr><td style="text-align:left"><code>get_number_of_electrons</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取价电子总数</td><td style="text-align:center"></td><td style="text-align:center"><code>float</code></td></tr><tr><td style="text-align:left"><code>get_eigenvalues</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取本征值</td><td style="text-align:center"><code>(ik=0, ispin=0)</code></td><td style="text-align:center">1D array</td></tr><tr><td style="text-align:left"><code>get_ibz_k_points</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取不可约k点</td><td style="text-align:center"></td><td style="text-align:center">2D array</td></tr><tr><td style="text-align:left"><code>get_bz_k_points</code></td><td style="text-align:left"><code>gpaw.paw.PAW</code></td><td style="text-align:left">获取所有k点</td><td style="text-align:center"></td><td style="text-align:center">2D array</td></tr></tbody></table><p>例如, 获取所有能级到<code>eigens</code>数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eigens = np.array([[</span><br><span class="line">                    calc.get_eigenvalues(ik, isp) <span class="keyword">for</span> ik,_ <span class="keyword">in</span> enumerate(calc.get_ibz_k_points())</span><br><span class="line">                   ] <span class="keyword">for</span> isp <span class="keyword">in</span> range(calc.get_number_of_spins())])</span><br></pre></td></tr></table></figure><p>获取各k点的直接带隙</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vb = int(calc.get_number_of_electrons()/<span class="number">2.0</span>) - <span class="number">1</span></span><br><span class="line">direct_gaps = eigens[<span class="number">0</span>, :, vb+<span class="number">1</span>] - eigens[<span class="number">0</span>, :, vb]</span><br></pre></td></tr></table></figure><p>手动制作能带图的方法可以参考<a href="https://www.mantidproject.org/Band_Structures_With_GPAW" target="_blank" rel="noopener">Band Structures With GPAW - Mantid Project</a>.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPAW </tag>
            
            <tag> Tutorial </tag>
            
            <tag> DFT </tag>
            
            <tag> Band structure </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>outwin算法解读</title>
      <link href="/2019/05/24/outwin-read/"/>
      <url>/2019/05/24/outwin-read/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>阅读WIEN2k v16.1版本中例程<code>outwin</code>的源码, 以理解其所用到的算法. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>outwin.f在WIEN2k各程序中出现, 它包含例程<code>outwin</code>. 之前大略知道它是用来计算原子球内的径向波函数的, 但对于其算法一直很模糊, 一方面由于它涉及相对论方程, 另一方面它除了输入参数的德语注释外一句注释也没有. 最近在研究局域基组生成的问题, 而这个例程出现频率非常高, 因此准备多啃一下这块代码.</p><p>不同SRC文件下的outwin.f版本也不尽同. SRC_nmr, SRC_lapw7等仍然使用Adams-Moulton四阶算法, SRC_lapw2对于第四个以外的格点允许用五阶算法. SRC_lapw7中的注释更多一些, 但仍然用的是四阶算法. 这里尝试对SRC_lapw7中的outwin.f源码进行解读.</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在Rydberg单位下, 具有量子数$\kappa$的大分量波函数$u(r)=G(r)/r$满足<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="参考这一篇[报告](https://users.wfu.edu/natalie/papers/pwpaw/notes/atompaw/scalarrelativistic.pdf)">[1]</span></a></sup></p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    \frac{d}{d r} G(r) &amp;= \frac{G(r)}{r}+M(r) F(r) \\<br>    \frac{d}{d r} F(r) &amp;= -\frac{F(r)}{r}+\left(\frac{\kappa(\kappa+1)}{r^{2}} \frac{1}{M(r)}-(E-V(r))\right) G(r)<br>\end{aligned}<br>\end{equation}\label{eq:r-GF}<br>$$</p><p>其中</p><p>$$<br>\begin{equation}<br>M(r) \equiv 1+\left(\frac{\alpha}{2}\right)^{2}(E-V(r)) = 1+\frac{E-V(r)}{c^2}<br>\end{equation}\label{eq:m}<br>$$</p><p>$\alpha$为精细结构常数, 在Rydberg单位下$\alpha=2/c$, $c$为光速. 为在步长$h$的对数格点上进行数值计算, 作变量替换$r=r_0 e^x$, $\mathrm{d}r=r\mathrm{d}x$, 得到关于$x$的方程组</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    G’ &amp;= G + M r F \\<br>    F’ &amp;= - F + \left(\frac{\kappa(\kappa+1)}{rM}-r(E-V)\right) G<br>\end{aligned}<br>\end{equation}\label{eq:x-GF}<br>$$</p><p>方便起见, 上式中略去了<em>G,F,M</em>的变量$r\equiv r(x)$, 撇号表示关于<em>x</em>求导.</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h3 id="行66-81"><a href="#行66-81" class="headerlink" title="行66-81"></a>行66-81</h3><h3 id="行83-91"><a href="#行83-91" class="headerlink" title="行83-91"></a>行83-91</h3><p>从81行开始是对第四个及以后的格点的循环. <code>X</code>为<em>-h</em>, <code>DRDI</code>为<em>rh</em>. 其他一些的中间量与式$\eqref{eq:x-GF}$中量的关系是</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>\mathrm{PHI} &amp;= rh\frac{E-V}{c}\\<br>\mathrm{U} &amp;= rhc + \mathrm{PHI} = rhc\left[1+\frac{E-V}{c^2}\right] = rhcM \\<br>\mathrm{Y} &amp;= -\kappa(\kappa+1)h^2/\mathrm{U} + \mathrm{PHI} = - \frac{h}{c}\left[\frac{\kappa(\kappa+1)}{rM} - r(E-V)\right]<br>\end{aligned}<br>\end{equation}<br>$$</p><p>从而可以将式$\eqref{eq:x-GF}$写成</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    G’ &amp;= G + \frac{\mathrm{U}}{hc}F \\<br>    F’ &amp;= - F - \frac{c}{h}\mathrm{Y} G<br>\end{aligned}<br>\end{equation}\label{eq:UYGF}<br>$$</p><p>令$A=G, B=F/c$, $A’=G’, B’=F’/c$, 得到</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    A’ &amp;= A + \frac{\mathrm{U}}{h}B \\<br>    B’ &amp;= - B - \frac{\mathrm{Y}}{h} A<br>\end{aligned}<br>\end{equation}\label{eq:UYAB}<br>$$</p><h3 id="行92-96"><a href="#行92-96" class="headerlink" title="行92-96"></a>行92-96</h3><p>由行列式解线性方程的知识可知, 这部分求解的是这样一个矩阵方程</p><p>$$\begin{equation}<br>\begin{bmatrix}<br>\frac{8}{3} + X &amp; -U \\<br>Y &amp; \frac{8}{3} - X \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>A_c \\<br>B_c \\<br>\end{bmatrix}=<br>\begin{bmatrix}<br>B1 \\<br>B2 \\<br>\end{bmatrix}<br>\end{equation}\label{eq:mat-92-96}$$</p><p>这里下标c表示在代码(code)中的定义. <code>B1</code>和<code>B2</code>在93和94行计算, 基于<a href="https://en.wikipedia.org/wiki/Linear_multistep_method#Adams%E2%80%93Moulton_methods" target="_blank" rel="noopener">Adams-Moulton算法</a>, 因为8/3来自于四阶算法</p><p>$$<br>y_{n+3}=y_{n+2}+h\left(\frac{9}{24} f\left(t_{n+3}, y_{n+3}\right)+\frac{19}{24} f\left(t_{n+2}, y_{n+2}\right)-\frac{5}{24} f\left(t_{n+1}, y_{n+1}\right)+\frac{1}{24} f\left(t_{n}, y_{n}\right)\right)<br>$$</p><p>其中$f(t_n, y_n)=y’_n$为第n格点上y的导数. 利用上式可以将$A’_{n+3}$表示为</p><p>$$<br>hA’_{n+3} = \frac{8}{3}A_{n+3} - \frac{8}{3}A_{n+2} - \frac{19}{9}hA’_{n+2} + \frac{5h}{9}A’_{n+1} - \frac{h}{9}A’_n<br>$$</p><p>将式$\eqref{eq:UYAB}$两边乘以$h$后, 在格点$n+3$处的表达式为</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>    \left[\frac{8}{3} - h\right]A_{n+3} - U_{n+3} B_{n+3} &amp;= \frac{8}{3}A_{n+2} + \frac{19}{9}hA’_{n+2} - \frac{5}{9}hA’_{n+1} + \frac{1}{9}hA’_n \\<br>    \left[\frac{8}{3} + h\right]B_{n+3} + Y_{n+3} A_{n+3} &amp;= \frac{8}{3}B_{n+2} + \frac{19}{9}hB’_{n+2} - \frac{5}{9}hB’_{n+1} + \frac{1}{9}hB’_n<br>\end{aligned}<br>\end{equation}\label{eq:n-3-UYAB}<br>$$</p><p>如果把上式看成未知数$A_{n+3}$和$B_{n+3}$的二元一次方程, 其系数矩阵和$\eqref{eq:mat-92-96}$是相同的. 检查<code>DGn</code>和<code>DFn</code>的含义(见下面一节)以及系数<code>Rn</code>, 可以发现式子$\eqref{eq:n-3-UYAB}$右侧与<code>B1</code>和<code>B2</code>也是一致的. 因此我们定义的$A$和$B$与outwin.f中的含义是一致的.</p><h3 id="行98-103"><a href="#行98-103" class="headerlink" title="行98-103"></a>行98-103</h3><p>更新最外的三个点的导数值, 以用于计算下一个格点上的<code>B1</code>和<code>B2</code>. 其中<code>Dx1</code>和<code>Dx2</code>分别用<code>Dx2</code>和<code>Dx3</code>替代, 即97, 98, 101和102行, 在格点迭代的语境下很好理解. <code>DG3</code>的更新表达式</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DG3 = U*B(K) - X*A(K)</span><br></pre></td></tr></table></figure><p>由式$\eqref{eq:UYAB}$和<code>X</code>等于<em>-h</em>, 可得</p><p>$$<br>DG3 = U_K B_K + h A_K = h(A_K + \frac{U_K}{h}B_K) = hA’_K<br>$$</p><p>因此<code>DG3</code>是$h$乘以A在格点K上的导数. 同理, <code>DF3</code>的更新表达式</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DF3 = X*B(K) - Y*A(K)</span><br></pre></td></tr></table></figure><p>意味着$DF3 = -h B_K - Y_K A_K = h B’_K$. 因此<code>DF3</code>是$h$乘以B在格点K上的导数.</p><h3 id="行107-109"><a href="#行107-109" class="headerlink" title="行107-109"></a>行107-109</h3><p>这一个循环对<em>B</em>进行了scaling, $B \to cB/2= F/2=\alpha F$. 报告<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="参考这一篇[报告](https://users.wfu.edu/natalie/papers/pwpaw/notes/atompaw/scalarrelativistic.pdf)">[1]</span></a></sup>指出<em>F</em>与小分量有关, 但具体关系暂未推导.</p><h3 id="行111-113"><a href="#行111-113" class="headerlink" title="行111-113"></a>行111-113</h3><p>由于$A=G=ru$, 因此<code>VAL</code>就是最后一个格点上的波函数值. 而<code>SLO</code>的数学表示</p><p>$$<br>(h\frac{\mathrm{d}A}{hr\mathrm{d}x}-u)/r<br>=\frac{\mathrm{d}(ru)}{r \mathrm{d}r} - \frac{u}{r}<br>=\frac{r\mathrm{d}u}{r \mathrm{d}r} = \frac{\mathrm{d}u}{\mathrm{d}r}<br>$$</p><p>为波函数在边界上的导数.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>outwin.f中的<code>outwin</code>例程利用Adams-Moulton算法求解标量相对论方程$\eqref{eq:r-GF}$, 在对数格点上得到量子数$\kappa$下的大分量波函数, 以函数乘矢径长的形式存储在$A$中.</p><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">参考这一篇<a href="https://users.wfu.edu/natalie/papers/pwpaw/notes/atompaw/scalarrelativistic.pdf" target="_blank" rel="noopener">报告</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WIEN2k </tag>
            
            <tag> Numerical method </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用gprof2dot+dot制作Fortran程序的调用图</title>
      <link href="/2019/05/15/profile-with-gprof-dot/"/>
      <url>/2019/05/15/profile-with-gprof-dot/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文简要介绍如何基于gprof或Valgrind的性能分析数据, 使用gprof2dot和Graphviz制作Fortran程序的调用图, 以便对Fortran程序进行调试和优化. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>程序逻辑或者工作流是程序设计中很重要的部分, 与程序的算法实现及效率紧密相关. 通过分析程序运行中函数的调用顺序和次数等, 可以发现程序中可能存在的设计缺陷和性能瓶颈. 调用图(<a href="https://en.wikipedia.org/wiki/Call_graph" target="_blank" rel="noopener">call graph</a>)是一种展示程序工作流的手段, 包括静态和运行时两种, 前者侧重调用逻辑, 后者侧重实际工作环境中的时间效率.</p><p>之前写代码时一直不是很重视设计这个阶段, 最多用心灵导图稍微画一画需求, 也不是非常严格. 这导致过一段时间回看代码, 会对某些地方为什么要那么写产生疑问, 要想很久才能回忆起来, 很费时间. 这对于个人小型项目问题还好, 对中型或大型项目就会造成很大的困难. 在一顿无望的结果测试后, 最近我重新回到组里GAP3的开发里. 尽管理解工作流程, 但对于GAP3的<em>GW</em>计算如何调用它的各种例程, 仍然没有非常清晰的图象. 于是我希望能用调用图来把程序运行逻辑可视化, 帮助自己理清思路. 网上一顿搜索后, 发现可以用gprof和Valgrind来做性能分析, 用gprof2dot和<code>dot</code>来处理分析数据并作图.</p><p>这篇文章就是自学的一些总结. 以下所有操作都是在Linux (Fedora 27)下完成, 用到的主要工具是</p><ul><li>Fortran编译器与链接器: 这里使用Intel 2018 Update 1的<code>ifort</code></li><li><a href="https://sourceware.org/binutils/docs/gprof/" target="_blank" rel="noopener">gprof</a>: 用于分析编译器产生的性能分析文件</li><li>Valgrind: 在<a href="/2019/03/23/valgrind-1/" title="Valgrind笔记(一)——Memcheck初探">Valgrind笔记(一)——Memcheck初探</a>一文中提到了使用Valgrind的memcheck工具检测内存使用状况, 实际上它还提供了<code>callgrind</code>工具来进行函数调用的运行时分析.</li><li><a href="https://github.com/jrfonseca/gprof2dot">gprof2dot</a>: 将<code>gprof</code>或<code>callgrind</code>分析获得的信息转化成一个以<a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language" target="_blank" rel="noopener">DOT语言</a>)描述的有向图(directed graph)对象. 可以通过<code>pip</code>安装.</li><li><code>dot</code>: 利用Graphviz将DOT有向图对象渲染成图片, 属于Graphviz发行版的一部分.</li></ul><h2 id="一个接口调用的例子"><a href="#一个接口调用的例子" class="headerlink" title="一个接口调用的例子"></a>一个接口调用的例子</h2><p>先从一个简单的例子出发, 把调用图制作的逻辑弄清楚. 下面是一段简单的做整数与浮点数加法的Fortran代码</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! filename: hw.f90</span></span><br><span class="line"><span class="keyword">module</span> tools</span><br><span class="line">    <span class="keyword">interface</span> add</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> add_int</span><br><span class="line">        <span class="keyword">module</span> <span class="keyword">procedure</span> add_double</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">interface</span> add</span><br><span class="line"></span><br><span class="line">    <span class="keyword">contains</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> add_int(i, j)</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: i</span><br><span class="line">            <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: j</span><br><span class="line">            <span class="keyword">integer</span> :: add_int</span><br><span class="line"></span><br><span class="line">            add_int = i +j</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> add_int</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span></span> add_double(i, j)</span><br><span class="line">            <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: i</span><br><span class="line">            <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">in</span>) :: j</span><br><span class="line">            <span class="keyword">real</span>(<span class="number">8</span>) :: add_double</span><br><span class="line"></span><br><span class="line">            add_double = i +j</span><br><span class="line">        <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span> add_double</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">program</span></span> hw</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> tools</span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">real</span>(<span class="number">8</span>) :: x</span><br><span class="line">    <span class="keyword">character</span>(len=<span class="number">20</span>) :: str = <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">"(A20)"</span>) str</span><br><span class="line">    i = add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    x = add(<span class="number">1.1d0</span>, <span class="number">2.1d0</span>)</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">"(I2)"</span>) i</span><br><span class="line">    <span class="built_in">write</span>(*, <span class="string">"(F6.3)"</span>) x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">stop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> hw</span><br></pre></td></tr></table></figure><p>在这里, 主程序中调用的<code>add</code>函数实际上是一个接口, 当接受两个整数时重载为<code>add_int</code>, 接受两个双精度浮点数是重载为<code>add_double</code>. 下面分别用gprof和valgrind为后端, 进行性能分析和调用图的制作.</p><h3 id="使用gprof"><a href="#使用gprof" class="headerlink" title="使用gprof"></a>使用gprof</h3><p>首先, 要使用<code>gprof</code>, 需要在程序编译时添加<code>-p</code>或<code>-pg</code>选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifort -p -g -c hw.f90 -o hw.o</span><br><span class="line">ifort -o test.out hw.o -p</span><br></pre></td></tr></table></figure><p>这里尽量采用先编译到目标文件, 再链接到可执行文件的方式. 然后运行test.out</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.out</span><br></pre></td></tr></table></figure><p>产生gmon.out文件. 用<code>gprof</code>读取这一文件并将标准输出重定向</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gprof test.out &gt; gprof_test.txt</span><br></pre></td></tr></table></figure><p>gprof_test.txt中包含了运行<code>test.out</code>过程中各函数的调用次数, 程序在每个函数及其子函数中的停留时间等.</p><p>接下来, 使用<code>gprof2dot</code>处理gprof_test.out</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat gprof_test.out | gprof2dot -f prof -o digraph.dot</span><br></pre></td></tr></table></figure><p>digraph.out用一个<code>digraph</code>数据类型描述了一个有向图. 用<code>dot</code>处理该文件并产生</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat digraph.dot | dot -Tpng -o hw_gprof.png</span><br></pre></td></tr></table></figure><p>得到下图. 可以看到<code>MAIN</code>中各调用了一次<code>add_int</code>和<code>add_double</code>. 每个方块中第一个百分数是在该函数及其子函数的运行时间占程序总时间的比例, 第二个数是仅在该函数内的时间的比例. 这里全都是100%, 是因为计算时间太短了, gprof_test.out里的时间都是0.00.</p><p><figure class="null"><img src="hw_gprof.png" alt="单次加法调用时, gprof产生的hw.f90调用图"><figcaption>单次加法调用时, gprof产生的hw.f90调用图</figcaption></figure></p><p>试着将加法次数增大到九千万次, 就可以看到明显的不同. 双精度耗时比整型的还是要多一些.</p><p><figure class="null"><img src="hw_9kw_gprof.png" alt="加法各九千万次时的gprof调用图"><figcaption>加法各九千万次时的gprof调用图</figcaption></figure></p><h3 id="使用callgrind"><a href="#使用callgrind" class="headerlink" title="使用callgrind"></a>使用callgrind</h3><p>若用Valgrind来做生成性能分析, 只需使用<code>valgrind</code>调用欲测试函数, 同时指明callgrind工具, 而不需要对编译做特别的改动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=callgrind ./test.out</span><br></pre></td></tr></table></figure><p>运行结束后会产生名为callgrind.out.xxx的文件, 其中xxx是运行程序进程的PID. 使用gprof2dot分析之</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat callgrind.out.xxx | gprof2dot -f callgrind -o digraph.dot</span><br></pre></td></tr></table></figure><p>生成png的命令与前面gprof的相同. 当只调用一次加法时调用图如下, 出现很多复杂的库函数调用, 猜测应该跟valgrind本身有关, 反而看不到<code>add_int</code>和<code>add_double</code>. 这时并不表示这两个函数未被调用, 而是因为占用时间太少, 被gprof2dot剪裁掉了.</p><p><figure class="null"><img src="hw_callgrind.png" alt="单次加法调用时, callgrind产生的hw.f90调用图"><figcaption>单次加法调用时, callgrind产生的hw.f90调用图</figcaption></figure></p><p>提高到九千万次调用后的分析结果看上去正常一些. 同样的, 这也不是说那些库函数未被调用, 而是在这种情况下主要耗时都在加法上, 库函数调用耗时少而被gprof2dot去掉了. 这些都是视觉表现上的考虑.</p><p><figure class="null"><img src="hw_9kw_callgrind.png" alt="加法各九千万次时的callgrind调用图"><figcaption>加法各九千万次时的callgrind调用图</figcaption></figure></p><p>比较两种工具所得的调用图, 发现Valgrind能给出包含被调用函数所在库的名称. 在九千万次加法的例子里, 使用Valgrind做性能分析所花的时间比gprof要多得多, 因此还是决定用gprof来做GAP3的分析. 上面用的所有程序和Makefile打包在<a href="fortran-profile.tar.gz">这里</a>了.</p><h2 id="GAP3的调用图"><a href="#GAP3的调用图" class="headerlink" title="GAP3的调用图"></a>GAP3的调用图</h2><p>在<code>-O3</code>下编译串行程序, 用<code>gprof</code>做运行时分析, 在真空层为9 Bohr的单层六方BN中测试. 库仑截断的开关打开, 以检查工作流是否跟自己预想的相同. 最后得到调用图如下所示.</p><p><figure class="null"><img src="cg_gap3_O3.png" alt="O3下GAP3中GW功能的调用图"><figcaption>O3下GAP3中GW功能的调用图</figcaption></figure></p><p>可以得到的比较直接的结论是</p><ol><li>花费时间最多的上层例程是: 介电矩阵计算<code>calceps</code>(63.70%), 交换自能即Fock算符<code>calcselfx</code>(26.05%), 关联自能<code>calcselfc</code>(2.63%)</li><li>花费时间最多的底层例程是<code>calcminm</code>(90.28%), 用于计算KS波函数积与MPB的重叠矩阵元$M^i_{nm}({\bf k, q})$. 原则上计算量是$\mathcal{O}(N_{\chi} N N_e N_v N^2_k)$, 其中$N_{\chi}$是MPB数量, $N$是APW+LO基组数, 价态数量$N_v$, 电子总数$N_e$, BZ中k布点数$N_k$</li></ol><p>另外发现的一个问题是, 在开启库仑截断后, 所有的库仑势计算都应该用<code>coul_barc_cutoff</code>例程, 但依然有9次<code>coul_barc</code>调用, 因此库仑势计算比关联自能更多一点. <code>coul_setvm0</code>和<code>calcmwm</code>也需要用带cutoff后缀的. 因此这样的调用图也能帮助解决一些流程控制上的bug.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中, 笔者分别用gprof和callgrind对一个简单的Fortran程序制作了调用图, 并通过调用图分析了GAP3程序中的性能瓶颈, 发现了库仑截断开启时的流程控制问题.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zengkefu/p/5642991.html" target="_blank" rel="noopener">valgrind的callgrind工具进行多线程性能分析</a></p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fortran </tag>
            
            <tag> Valgrind </tag>
            
            <tag> gprof </tag>
            
            <tag> Call graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于重启这个博客的思考</title>
      <link href="/2019/05/08/restart-hexo-blog/"/>
      <url>/2019/05/08/restart-hexo-blog/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><p>碎碎念而已.<br><a id="more"></a></p><p>在经历了草稿里的一些乌龙后, Hexo又能正常工作了. 我也在过了很久一段时间后回到这里, 重新打理这片虚拟的土地, 重新开始上传技术文字. 目前大部分是存在熊掌记和Agenda里后整理出来的bugfix和初步学习笔记.</p><p>我还在考虑把其他地方的文字都移到这里来, 因为我感到这是一片属于我的独一无二的土地. 我于此耕耘, 把它定义成我想要的样貌. 在这里, 我的声音能够回响; 它不必响彻, 在我脑海里就足够了. 如果它能够进到一位陌生人的耳中, 他恰又能够给我一些呼应, 那就真是难得的美好.</p><p>更重要的是, 我渐渐想要去发出我自己的声音了. 无论在现实里还是在虚拟世界里, 自己其实一直都是个害怕发声的人: 我感到时刻被周围人的目光所裹挟, 担心无论说什么都会使人失望; 讨好他人, 很少说出自己的真实想法; 在公共场所/宿舍, 我用绝对安静, 去鄙视那些喧哗的人. 我好像保持着一个很好的形象, 但我失去了表达自己的机会; 事实上这个形象也未必就很好.</p><p>渐渐地, 我发现自己无法准确表达一些应当很容易传达的东西. 我意识到一直不去表达是不行的. 但我不希望太大张旗鼓, 尽管有时无可避免地想获得一点点真心的关注. 于是我想到这里, 这是我一手创造的空间, 这里有来来往往的冷漠又友好的陌生人, 有点像在一座完全陌生的小镇里, 拿着自己心爱的乐器独自演奏.</p><p>我会继续写下去.</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blogging </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WIEN2k笔记(一)——LAPWSO计算</title>
      <link href="/2019/05/07/wien2k-lapwso-1/"/>
      <url>/2019/05/07/wien2k-lapwso-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>介绍了WIEN2k中自旋非极化下通过LAPWSO考虑自旋轨道耦合(SOC)效应的第一性原理计算的流程. 以Si和Au为例子, 简单分析了SOC对能带结构的影响.</p><a id="more"></a><h2 id="WIEN2k中实现的SOC"><a href="#WIEN2k中实现的SOC" class="headerlink" title="WIEN2k中实现的SOC"></a>WIEN2k中实现的SOC</h2><p>WIEN2k中价层轨道的SOC贡献是通过LAPWSO程序考虑的. 它基于一种所谓的二次变分<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="[Second variation](http://www.encyclopediaofmath.org/index.php?title=Second_variation&oldid=31231). Encyclopedia of Mathematics.">[1]</span></a></sup>的方法, 通过读取LAPW1计算的本征态的波函数与能量, 计算微扰$\hat{H}_{\rm SO}$的矩阵元并对角化, 得到包含SOC的波函数与能量. LAPWSO可以包含在SCF循环里, 也可以非自洽地运行.</p><h2 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h2><h3 id="diamond-Si"><a href="#diamond-Si" class="headerlink" title="diamond Si"></a>diamond Si</h3><p>以diamond Si (10.405822 au)为例, RMT取1.8. 初始化命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init_lapw -b -numk 64</span><br></pre></td></tr></table></figure><p>体系共8个价电子. 先看不加SOC的结果. 执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_lapw -ec 0.0000001</span><br></pre></td></tr></table></figure><p>仔细检查energy文件. 在第1个和第7个k点, 由能带4和5分别为价带和导带, 得到带隙为0.780 eV, 涉及k矢跃迁为000($\Gamma$)-100(X).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> 0.000000000000E+00 0.000000000000E+00 0.000000000000E+00         1   291    15  1.0</span><br><span class="line">           1 -0.476709975533258</span><br><span class="line">           2  0.382390732021062</span><br><span class="line">           3  0.382390732021068</span><br><span class="line">           4  0.382390732021068</span><br><span class="line">           5  0.567940696174970</span><br><span class="line">           6  0.567940696174970</span><br><span class="line">           7  0.567940696174976</span><br><span class="line">           8  0.594331247119800</span><br><span class="line">...</span><br><span class="line"> 1.000000000000E+00 0.000000000000E+00 0.000000000000E+00         7   294    20  3.0</span><br><span class="line">           1 -0.183034494762965</span><br><span class="line">           2 -0.183034494762950</span><br><span class="line">           3  0.180029340741516</span><br><span class="line">           4  0.180029340741516</span><br><span class="line">           5  0.439692381439167</span><br><span class="line">           6  0.439692381439175</span><br><span class="line">           7   1.09817099212224</span><br><span class="line">           8   1.09817099212225</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>关于能带的组成, 考虑$\Gamma$点上能带组分, 由TB分析可知, 上面8个能级从低到高依次是Si的$\sigma_{3s}$, $\{\sigma/\pi\}_{3p}$, $\{\sigma/\pi\}_{3p}^\ast$和$\sigma_{3s}^\ast$. 在一条k点路径上的组分变化可以从下面这张VASP计算的投影能带图看出<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="因为用[mykit](https://github.com/minyez/mykit)制作的图, 目前只支持到VASP :(">[2]</span></a></sup>.</p><p><figure class="null"><img src="Si_X-L-G-X.png" alt="Si投影能带图. 红色为s成分, 蓝色为p成分"><figcaption>Si投影能带图. 红色为s成分, 蓝色为p成分</figcaption></figure></p><p>上面这些都是对于无SOC的计算结果的分析. 下面利用LAPWSO微扰地考虑SOC. 首先用<code>save_lapw</code>保存上面的计算结果, 然后运行<code>initso</code>命令以初始化<code>lapwso</code>所需的主要输入文件<code>Si.inso</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save_lapw -d scf-no-soc</span><br><span class="line">initso</span><br></pre></td></tr></table></figure><p><code>initso</code>是交互式命令, 会询问下面几个设置</p><ol><li>指定Direction of moment</li><li>指定某些原子不考虑SOC</li><li>修改考虑SOC的能带的最高能量(EMAX)</li><li>是否在<code>case.in1</code>中添加RLO</li><li>选择自旋极化方式. 因为在自旋极化情况下考虑SOC时, 体系的对称性有可能小于无SOC的情形. 如果选择<code>y</code>, <code>symmetso</code>程序将被执行, 确定考虑SOC后体系的对称性并修改<code>struct</code>文件.</li></ol><p>暂时不深究几个问题的含义, 一路回车通关. 结束后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_lapw -ec 0.0000001 -so</span><br></pre></td></tr></table></figure><p>开始运行包含LAPWSO在内的SCF循环.</p><p>包含SOC的哈密顿量对角化后得到的本征值保存在<code>case.energyso</code>中. 与非极化计算的<code>case.energy</code>文件不同的是, SOC下不再有简单的自旋简并, 因此原则上各k点的能带数量是无SOC时的两倍. 还是看第1和第7个k点的能量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> 0.000000000000E+00 0.000000000000E+00 0.000000000000E+00         1   291    30  1.0</span><br><span class="line">...</span><br><span class="line">           1 -0.476709708261459</span><br><span class="line">           2 -0.476709708261458</span><br><span class="line">           3  0.380103284844223</span><br><span class="line">           4  0.380103284844224</span><br><span class="line">           5  0.383531827460128</span><br><span class="line">           6  0.383531827460128</span><br><span class="line">           7  0.383531827479756</span><br><span class="line">           8  0.383531827479756</span><br><span class="line">           9  0.566261029915788</span><br><span class="line">          10  0.566261029915788</span><br><span class="line">          11  0.568777497161570</span><br><span class="line">          12  0.568777497161571</span><br><span class="line">          13  0.568777497196808</span><br><span class="line">          14  0.568777497196810</span><br><span class="line">          15  0.594331439770928</span><br><span class="line">          16  0.594331439770930</span><br><span class="line">...</span><br><span class="line"> 0.100000000000E+01 0.000000000000E+00 0.000000000000E+00         7   294    28  3.0</span><br><span class="line">           1 -0.183035347355239</span><br><span class="line">           2 -0.183035347355239</span><br><span class="line">           3 -0.183035347355239</span><br><span class="line">           4 -0.183035347355237</span><br><span class="line">           5  0.180025326616621</span><br><span class="line">           6  0.180025326616621</span><br><span class="line">           7  0.180025326616631</span><br><span class="line">           8  0.180025326616633</span><br><span class="line">           9  0.439692350006189</span><br><span class="line">          10  0.439692350006189</span><br><span class="line">          11  0.439692350006200</span><br><span class="line">          12  0.439692350006200</span><br><span class="line">          13   1.09815900469418</span><br><span class="line">          14   1.09815900469418</span><br><span class="line">          15   1.09815900469536</span><br><span class="line">          16   1.09815900469536</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时的价带和导带变成了8和9, 带隙为0.764 eV. 此外, $\Gamma$点上原来三重简并的3p成键与反键轨道均裂分为两组简并轨道, 能量较高的为四重简并, 较低的为二重简并. 考虑SOC后的带隙相比未考虑的情形只减小了0.016 eV, 反映出在Si等轻元素中相对论效应较弱的事实.</p><h3 id="FCC-Au"><a href="#FCC-Au" class="headerlink" title="FCC Au"></a>FCC Au</h3><p>以FCC Au (7.67 au)为例, 参考Novak老师的关于spin-orbit coupling笔记中的计算<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Prof. P. Novak, [Notes about spin-orbit](http://susi.theochem.tuwien.ac.at/reg_user/textbooks/novak_lecture_on_spinorbit.pdf), p12. 内容基于WIEN97.">[3]</span></a></sup>. RMT值取2.6, GMAX取16. 初始化命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init_lapw -b -numk 5000 -rkmax 9</span><br><span class="line">sed -i <span class="string">'s/ 12.00/ 16.00/g'</span> Au.in2 <span class="comment"># change GMAX</span></span><br></pre></td></tr></table></figure><p>共17个价电子. 按和Si中相同的步骤, 分别进行无SOC和在LAPWSO下考虑SOC的计算. 直接对比$\Gamma$点上的能量. 先看无SOC的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0.000000000000E+00 0.000000000000E+00 0.000000000000E+00         1    77    13  1.0</span><br><span class="line">          1  -3.48417834812053</span><br><span class="line">          2  -3.48417834812053</span><br><span class="line">          3  -3.48417834812053</span><br><span class="line">          4 -4.633683657763327E-002</span><br><span class="line">          5  0.341371911764138</span><br><span class="line">          6  0.341371911764145</span><br><span class="line">          7  0.341371911764145</span><br><span class="line">          8  0.456634603361144</span><br><span class="line">          9  0.456634603361151</span><br><span class="line">         10   1.75774908584153</span><br><span class="line">         11   2.06272605171851</span><br><span class="line">         12   2.06272605171851</span><br><span class="line">         13   2.06272605171851</span><br></pre></td></tr></table></figure><p>VASP的投影能带如下图所示. 从成分上看, 占据态分别是$5p$(1-3), $6s$(4), $t_{2g}$(5-7), $e_g$(8-9).</p><p><figure class="null"><img src="Au_X-L-G-X.png" alt="Au投影能带图. 红蓝黄绿色分别为spdf成分."><figcaption>Au投影能带图. 红蓝黄绿色分别为spdf成分.</figcaption></figure></p><p>再看考虑SOC后的结果<code>energyso</code>. 由于轨道增加一倍, 下面的18个轨道都是占据态<sup id="fnref:4"><a href="#fn:4" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="可以通过增大`inso`中的`EMAX`来获取更多的SOC态的本征值">[4]</span></a></sup>. 很明显的, 原来的$t_{2g}$和$e_g$进一步裂分成了三组轨道, 能量从低到高的简并度分别为4, 2和4, 它们在群表示上的记号分别为$\Gamma_8, \Gamma_7$和$\Gamma’_8$.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0.000000000000E+00 0.000000000000E+00 0.000000000000E+00         1    77    18  1.0</span><br><span class="line">          1  -4.20742280553107</span><br><span class="line">          2  -4.20742280553106</span><br><span class="line">          3  -3.14951843978248</span><br><span class="line">          4  -3.14951843978248</span><br><span class="line">          5  -3.14951842668932</span><br><span class="line">          6  -3.14951842668932</span><br><span class="line">          7 -4.585036452752571E-002</span><br><span class="line">          8 -4.585036452752490E-002</span><br><span class="line">          9  0.294994273106371</span><br><span class="line">         10  0.294994273106371</span><br><span class="line">         11  0.294994274995205</span><br><span class="line">         12  0.294994274995205</span><br><span class="line">         13  0.381494069224123</span><br><span class="line">         14  0.381494069224123</span><br><span class="line">         15  0.473340026931149</span><br><span class="line">         16  0.473340026931150</span><br><span class="line">         17  0.473340027624113</span><br><span class="line">         18  0.473340027624115</span><br></pre></td></tr></table></figure><p>考虑和不考虑SOC的$E_F$分别为0.705和0.699 Ry. 同Novak老师的能带位置结果(下表括号内数字)进行比较, 发现结果惊人一致(Novak老师的结果可还是用WIEN97算的啊).</p><table><thead><tr><th style="text-align:center">$E-E_F$ (mRy)</th><th style="text-align:center">No SOC</th><th style="text-align:center">SOC by LAPWSO</th></tr></thead><tbody><tr><td style="text-align:center">$\Gamma_8$</td><td style="text-align:center">-358  (-357)</td><td style="text-align:center">-410 (-410)</td></tr><tr><td style="text-align:center">$\Gamma_7$</td><td style="text-align:center">-358  (-357)</td><td style="text-align:center">-324 (-323)</td></tr><tr><td style="text-align:center">$\Gamma’_8$</td><td style="text-align:center">-242  (-241)</td><td style="text-align:center">-232 (-230)</td></tr></tbody></table><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li style="list-style: none"><input type="checkbox"> 二次变分的原理.</li><li style="list-style: none"><input type="checkbox"> 对<code>initso</code>设置内容的阐明, direction of moment和RLO.</li><li style="list-style: none"><input type="checkbox"> 自旋极化计算.<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="http://www.encyclopediaofmath.org/index.php?title=Second_variation&amp;oldid=31231" target="_blank" rel="noopener">Second variation</a>. Encyclopedia of Mathematics.<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">因为用<a href="https://github.com/minyez/mykit">mykit</a>制作的图, 目前只支持到VASP :(<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Prof. P. Novak, <a href="http://susi.theochem.tuwien.ac.at/reg_user/textbooks/novak_lecture_on_spinorbit.pdf" target="_blank" rel="noopener">Notes about spin-orbit</a>, p12. 内容基于WIEN97.<a href="#fnref:3" rev="footnote"> ↩</a></span></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">4.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">可以通过增大<code>inso</code>中的<code>EMAX</code>来获取更多的SOC态的本征值<a href="#fnref:4" rev="footnote"> ↩</a></span></li></ol></div></div></li></ul>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> WIEN2k </tag>
            
            <tag> SOC </tag>
            
            <tag> DFT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python笔记(二)——常用re函数与语句总结</title>
      <link href="/2019/05/06/re-summary/"/>
      <url>/2019/05/06/re-summary/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>整理了调用Python <code>re</code>包时的常用操作和命令. <a id="more"></a></p><p>这里主要按照使用情景, 对操作和命令进行分类, 这样也顺带梳理不同情境下可能用到的正则表达式. 目前更新到模式组方法的比较.</p><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><p>下表列出了常用的re函数, 其中变量类型仅为自己常用的情况, 具体见<a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">re文档</a>(Python 3).</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">参数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left"><code>re.compile</code></td><td style="text-align:left"><code>pat</code>(s)</td><td style="text-align:left">返回一个与正则表达式<code>pat</code>对应的regular expression对象.</td></tr><tr><td style="text-align:left"><code>re.match</code></td><td style="text-align:left"><code>pat</code>(s), <code>string</code>(s)</td><td style="text-align:left">对<code>string</code>从头匹配<code>pat</code>, 返回Match对象</td></tr><tr><td style="text-align:left"><code>re.fullmatch</code></td><td style="text-align:left">同<code>re.match</code></td><td style="text-align:left">对整个<code>string</code>匹配<code>pat</code>, 返回Match对象</td></tr><tr><td style="text-align:left"><code>re.search</code></td><td style="text-align:left">同<code>re.match</code></td><td style="text-align:left">在<code>string</code>中搜索匹配模式<code>pat</code>的子字符串, 返回Match对象</td></tr><tr><td style="text-align:left"><code>re.sub</code></td><td style="text-align:left"><code>pat</code>(s), <code>repl</code>(s), <code>s</code>(s)</td><td style="text-align:left">将<code>s</code>中匹配<code>pat</code>的字符串<strong>全部</strong>替换为<code>repl</code></td></tr></tbody></table><p>一些注意点</p><ul><li>我们可能习惯在命令行下使用通配符<code>*</code>, 但是在正则表达式下<code>*</code>的作用是匹配任意次.</li><li><code>re.match(&quot;^&quot;+pat+&quot;$&quot;, s)</code>匹配整条字符串, 因此与<code>re.fullmatch(pat, s)</code>等价</li></ul><h2 id="一次匹配字符串"><a href="#一次匹配字符串" class="headerlink" title="一次匹配字符串"></a>一次匹配字符串</h2><p>用<code>re.match</code>和<code>re.fullmatch</code>进行匹配</p><h3 id="匹配名为V-x-y的文件夹"><a href="#匹配名为V-x-y的文件夹" class="headerlink" title="匹配名为V_x.y的文件夹"></a>匹配名为<code>V_x.y</code>的文件夹</h3><p>其中<code>x</code>为数字0或1 <code>y</code>为长度大于等于1的数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dname = <span class="string">"V_0.98"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.fullmatch(<span class="string">r"V_[01]\.[0-9]+"</span>, dname)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">6</span>), match=<span class="string">'V_0.98'</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="匹配一条K点路径"><a href="#匹配一条K点路径" class="headerlink" title="匹配一条K点路径"></a>匹配一条K点路径</h3><p>匹配一条类似<code>GM-X-L-M</code>格式的K点路径, 要求每一个特殊K点由1到2个大写字母组成.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^([A-Z]&#123;1,2&#125;-)+[A-Z]&#123;1,2&#125;$'</span>, <span class="string">'GM-X-L-GM-L'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">11</span>), match=<span class="string">'GM-X-L-GM-L'</span>&gt;</span><br></pre></td></tr></table></figure><p>简单解读:</p><ul><li><code>[A-Z]{1,2}</code>对大写字母匹配1次或2次</li><li><code>()+</code>: 对括号内(组)模式匹配1次或多次</li></ul><h2 id="compile函数"><a href="#compile函数" class="headerlink" title="compile函数"></a>compile函数</h2><p>利用<code>re.compile</code>产生模式对应的regular expression对象. regular expression对象拥有与<code>re</code>函数同名的方法, 之后所有有关该模式的匹配都通过该对象进行.</p><p>例如匹配邮件中用户名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PAT_USERNAME = re.compile(<span class="string">r'\w+'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PAT_USERNAME.match(<span class="string">'bob@163.com'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">3</span>), match=<span class="string">'bob'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PAT_USERNAME.match(<span class="string">'chris@163.com'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">5</span>), match=<span class="string">'chris'</span>&gt;</span><br></pre></td></tr></table></figure><p>这个例子可能还不怎么明显, 但当模式非常复杂时, regular expression对象代替字符串模式要方便很多, 也更易读.</p><h2 id="利用group和groups获得匹配内容"><a href="#利用group和groups获得匹配内容" class="headerlink" title="利用group和groups获得匹配内容"></a>利用group和groups获得匹配内容</h2><p>使用regex时, 我们有时需要获得具体的匹配内容, 这可以通过在模式中加入<code>()</code>以定义组(group)这一方式实现.</p><p>在上面匹配<code>V_x.y</code>的例子中, 如果我们要获得后面的具体数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># obtain and print the ratio of volume from the name of directory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dname = <span class="string">"V_0.98"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matched = re.fullmatch(<span class="string">r"V_([01]\.[0-9]+)"</span>, dname)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matched.group()</span><br><span class="line"><span class="string">'V_0.98'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matched.group(<span class="number">1</span>)</span><br><span class="line"><span class="string">'0.98'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matched.group(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'V_0.98'</span>, <span class="string">'0.98'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matched.group(<span class="number">2</span>)</span><br><span class="line">IndexError: no such group</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matched.groups()</span><br><span class="line">(<span class="string">'0.98'</span>,)</span><br></pre></td></tr></table></figure><p>这里比较了Match对象的两种方法<code>group</code>和<code>groups</code>. 总结一下</p><ul><li>如果没有参数或参数为<code>0</code>, <code>group</code>返回的是整条匹配的子字符串.</li><li>如果参数不为<code>0</code>, 则返回第n个组(括号)中匹配的字符串.</li><li>参数个数等于1时, 返回一个字符串; 大于1时返回一个字符串元组.</li><li>如果参数大于被匹配模式中包含的组数, 抛出<code>IndexError</code>.</li><li><code>groups</code>返回所有组的匹配结果, 总是一个字符串元组.</li></ul><h2 id="利用group标记的替换"><a href="#利用group标记的替换" class="headerlink" title="利用group标记的替换"></a>利用group标记的替换</h2><p>对于包含多个参数的输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param1 | param2 | param3 # this is comment</span><br></pre></td></tr></table></figure><p>注释以”#”开头, 是可选的, 参数之间用<code>|</code>隔开. 例如, 一条包含两个参数的字符串及其对应的匹配模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"2.0  |  1.E-15   # pwm, stctol"</span></span><br><span class="line">pat = <span class="string">r"^([\w \.-]+)\|([\w \.-]+)(#[\w \(\),\.-]*)?$"</span></span><br></pre></td></tr></table></figure><p>可利用group进行灵活有效的替换. 比如说, 现在只将第一个参数替换为5.0, 则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.sub(pat, <span class="string">r"5.0 | \2 \3"</span>, s)</span><br><span class="line"><span class="string">'5.0 |   1.E-15          # pwm, stctol'</span></span><br></pre></td></tr></table></figure><p>其中标记<code>\2</code>表示第二个组所匹配的子字符串, 以此类推. 这种方法的好处是只需要知道被匹配参数在文件中的位置(行号, 行内参数的总数以及所要参数的序号)就可以方便地替换, 不需要依赖<code>split</code>和其他判断函数.</p><p>具体来说, 对于参数个数可变的情形, 利用函数动态地产生匹配模式和替换格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pattern</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">'''Generate n parameters pattern'''</span></span><br><span class="line">    s = [<span class="string">r"([\w \.-]+)"</span>, ] * n</span><br><span class="line">    <span class="keyword">return</span> <span class="string">r'^'</span> + <span class="string">r'\|'</span>.join(s) + <span class="string">r'(#[\w \(\),\.-]*)?$'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_substr</span><span class="params">(n, i, value)</span>:</span></span><br><span class="line">    <span class="string">'''Return the sub string of n-parameter line with i+1-th parameter as value'''</span></span><br><span class="line">    sublist = [<span class="string">"\\"</span>+str(i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">    sublist[i] = str(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' | '</span>.join(sublist) + <span class="string">' \\'</span> + str(n+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>还是用前面的两个参数的行(<code>s</code>)作为例子, 替换参数的位置记录在字典<code>params</code>里, 要替换的参数值记录在字典<code>new_value</code>中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"2.0  |  1.E-15   # pwm, stctol"</span></span><br><span class="line">params = &#123;<span class="string">"pwm"</span>: (<span class="number">2</span>, <span class="number">0</span>), <span class="string">"stctol"</span>: (<span class="number">2</span>, <span class="number">1</span>)&#125;</span><br><span class="line">new_value = &#123;<span class="string">"pwm"</span>: <span class="number">5.0</span>, <span class="string">"stctol"</span>: <span class="number">1.0e-20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, nv <span class="keyword">in</span> new_value.items():</span><br><span class="line">    n, i = params.get(k, (<span class="keyword">None</span>, <span class="keyword">None</span>))</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        pat = get_pattern(n)</span><br><span class="line">        sub = get_substr(n, i, nv)</span><br><span class="line">        s = re.sub(pat, sub, s)</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># result: "5.0  | 1e-20 # pwm, stctol"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Hexo博文中嵌入Jupyter notebook</title>
      <link href="/2019/05/03/embed-jupyter-in-hexo/"/>
      <url>/2019/05/03/embed-jupyter-in-hexo/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>尝试在Hexo博文中嵌入Jupyter notebook (<code>.ipynb</code>)以展示Python代码 (快速入门到光速入土).</p><a id="more"></a><h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><p>首先安装<code>hexo-jupyter-notebook</code>和<code>co</code>两个npm包, 后者为前者的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-jupyter-notebook --save</span><br><span class="line">npm install co</span><br></pre></td></tr></table></figure><p>像<a href="/2019/05/01/embed-videos/" title="在Hexo博文中嵌入视频">在Hexo博文中嵌入视频</a>一文中的视频画面一样, 为了将嵌入帧尺寸做成响应式的, 修改<code>node_modules/hexo-jupyter-notebook/main.py</code>中的<code>template</code>变量, 加入<code>auto-resizable-iframe</code>容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    template = <span class="string">"""</span></span><br><span class="line"><span class="string">&lt;div class="auto-resizable-iframe"&gt;&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;iframe id='ipynb' marginheight="0" frameborder="0" srcdoc="%s"  style="scrolling:no;"&gt;</span></span><br><span class="line"><span class="string">&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$("#ipynb").load( function() &#123;</span></span><br><span class="line"><span class="string">console.log($("#ipynb").contents().find("body").find("#notebook"));</span></span><br><span class="line"><span class="string">document.getElementById('ipynb').height=$("#ipynb").contents().find("#notebook").height()+100;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">    """</span> % restr.replace(<span class="string">"\""</span>, <span class="string">"'"</span>)</span><br></pre></td></tr></table></figure><p>有这一部分后, 我就没有像参考链接里那样用jQuery来控制尺寸.</p><p>再准备好要嵌入的ipynb文件, 准备工作就做好了. 我这里用的是之前练习matplotlib时写的<code>meshgrid_plot.ipynb</code></p><h2 id="嵌入ipynb"><a href="#嵌入ipynb" class="headerlink" title="嵌入ipynb"></a>嵌入ipynb</h2><p>做好上述准备后, 进行下面三步操作</p><ol><li><p>在<code>_config.yml</code>中打开<code>post_asset_folder</code></p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>source/assets</code>中新建<code>codes</code>文件夹, 将准备好的ipynb放入其中.</p></li><li><p>Markdown文本中, 在要嵌入ipynb的位置加入</p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset<span class="emphasis">_jupyter /usr/local/bin/python3 ../../assets/codes/meshgrid_</span>plot.ipynb %&#125;</span><br></pre></td></tr></table></figure></li></ol><p>嵌入效果如图所示.</p><p><figure class="null"><img src="meshgrid_demo.png" alt="ipynb嵌入效果"><figcaption>ipynb嵌入效果</figcaption></figure></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>成功利用<code>hexo-jupyter-notebook</code>包, 在Hexo博文中嵌入了Jupyter notebook. 然而自己对这个效果不是很满意, 主要是两个原因</p><ol><li>嵌入的ipynb代码有滚动条. 修改<code>iframe</code>的大小(试到3000px)或修改JS里<code>+100</code>为更大数值, 也不能解决.</li><li>更关键的, <code>hexo s</code>渲染时间显著增加, 从600 ms左右增加到1.34 s. 且持续一段时间后系统明显卡顿, 调试变得更麻烦了.</li></ol><p>遂最终放弃了嵌入ipynb的想法  _(xз」∠)_</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=2ahUKEwj5-v20yf7hAhUFRqwKHYyID48QFjAAegQIBRAB&amp;url=https%3A%2F%2Fmedium.com%2F%40juanx002%2Fblogging-jupyter-notebooks-ipynb-with-hexo-on-github-7948b72636dc&amp;usg=AOvVaw1xUf2rSePZCUw7anF7uVRu" target="_blank" rel="noopener">Blogging Jupyter Notebooks (.ipynb) with Hexo on GitHub - Medium</a></p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Jupyter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在Hexo博文中嵌入视频</title>
      <link href="/2019/05/01/embed-videos/"/>
      <url>/2019/05/01/embed-videos/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>总结了如何用HTML源码在博文中嵌入youtube和bilibili视频, 并通过定义样式表, 统一且响应式的控制视频画面尺寸.</p><a id="more"></a><h2 id="Youtube视频"><a href="#Youtube视频" class="headerlink" title="Youtube视频"></a>Youtube视频</h2><p>在浏览器中进入想分享的视频, 点击分享, 选择第一个“嵌入”按钮, 就可以得到嵌入博文中所需要的代码, 例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">"560"</span> <span class="attr">height</span>=<span class="string">"315"</span> <span class="attr">src</span>=<span class="string">"https://www.youtube.com/embed/arj7oStGLkU"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">allow</span>=<span class="string">"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="bilibili视频"><a href="#bilibili视频" class="headerlink" title="bilibili视频"></a>bilibili视频</h2><p>类似油管视频, 将鼠标移到B站视频下方分享按钮, 就会出来一段嵌入代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=16091118&amp;cid=26251892&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="统一尺寸控制"><a href="#统一尺寸控制" class="headerlink" title="统一尺寸控制"></a>统一尺寸控制</h2><p>在Freemind主题下<code>source/css/style.css</code>中, 加入以下选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.auto-resizable-iframe</span> &#123;</span><br><span class="line">  <span class="comment">/*max-width: 540px;*/</span></span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.auto-resizable-iframe</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">75%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.auto-resizable-iframe</span> <span class="selector-tag">iframe</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将前面<code>iframe</code>放入两层<code>div</code>元素里, 最外层元素的类设为<code>auto-resizable-iframe</code>, 删除<code>iframe</code>中的宽度长度控制, 即</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"auto-resizable-iframe"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://www.youtube.com/embed/arj7oStGLkU"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">allow</span>=<span class="string">"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下(Youtube视频)</p><div class="auto-resizable-iframe"><br>  <div><br>    <iframe src="https://www.youtube.com/embed/arj7oStGLkU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>  </div><br></div><p>两层div使得画面尺寸是响应式的. 比起直接黏贴iframe稍微麻烦一些, 但是好看的多.</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><p>本来想在这篇博文里也把上面的B站视频嵌入的, 但是插入B站视频的iframe后本地server查看, 发现两个视频都是TED. 问题原因不是很清楚. 所以暂时一篇博文只能插入一个视频了 :(</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.tangycode.com/How-To-Embed-Youtube-Videos-Within-Hexo-Blogs/" target="_blank" rel="noopener">How To Embed Youtube Videos Within Hexo Blogs</a></p><p><a href="https://anywaywillgo.github.io/post/writing/hexo/embed-bilibili-video-in-hexo/" target="_blank" rel="noopener">在Hexo博客中插入bilibili视频的方式</a></p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Youtube </tag>
            
            <tag> bilibili </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决编译WIEN2k时找不到meta-GGA例程的问题</title>
      <link href="/2019/04/20/wien2k-libxc-mgga-error/"/>
      <url>/2019/04/20/wien2k-libxc-mgga-error/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>通过修改libxc.F, 解决编译WIEN2k v16.1时出现的未定义”xc_f03_mgga_x_tb09_set_params_”的错误</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在<a href="/2019/04/20/wien2k-fftw3-multi-def/" title="解决编译WIEN2k时FFTW3 multiple definition错误">解决编译WIEN2k时FFTW3 multiple definition错误</a>一文修正FFTW错误基础上, 利用Intel, Intel FFTW和LIBXC编译WIEN2k v16.1的<code>lapw0</code>时, 串行版本报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ld: libxc.o: in function `libxc_&apos;:</span><br><span class="line">libxc.F:(.text+0xcf7): undefined reference to `xc_f03_mgga_x_tb09_set_params_&apos;</span><br><span class="line">ld: libxc.F:(.text+0xd6b): undefined reference to `xc_f03_mgga_x_tb09_set_params_&apos;</span><br><span class="line">make[2]: *** [Makefile:83: lapw0] Error 1</span><br><span class="line">make[2]: Leaving directory &apos;/opt/software/wien2k/16.1/SRC_lapw0&apos;</span><br><span class="line">make[1]: *** [Makefile:72: seq] Error 2</span><br><span class="line">make[1]: Leaving directory &apos;/opt/software/wien2k/16.1/SRC_lapw0&apos;</span><br><span class="line">make: *** [Makefile:64: all] Error 2</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这个错误在<a href="https://www.mail-archive.com/wien@zeus.theochem.tuwien.ac.at/msg16924.html" target="_blank" rel="noopener">这封mail-list</a>里提到, 原因是由于LIBXC版本升级导致的一些参数改变. 用这个<a href="libxc.F">libxc.F</a>替代<code>SRC_lapw0</code>中同名文件, 即可正确编译.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compilation </tag>
            
            <tag> Intel </tag>
            
            <tag> Bugfix </tag>
            
            <tag> WIEN2k </tag>
            
            <tag> LIBXC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决编译WIEN2k时FFTW3 multiple definition错误</title>
      <link href="/2019/04/20/wien2k-fftw3-multi-def/"/>
      <url>/2019/04/20/wien2k-fftw3-multi-def/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>通过使用Intel FFTW3 wrapper, 解决了自编FFTW下编译WIEN2k v14.2时出现的多次定义”fftw_destroy_plan”错误</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>尝试用Intel 2018.0和对应编译的FFTW3库编译WIEN2k v14.2. 用<code>siteconfig_lapw</code>, 在编译<code>SRC_lapw0</code>中的并行程序<code>lapw0_mpi</code>时, 报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libfftw3.a (apiplan.o): In function `fftw_destroy_plan’:</span><br><span class="line">apiplan.c:(.text+0x430): multiple definition of `fftw_destroy_plan’</span><br><span class="line">mkl/lib/intel64/libmkl_intel_lp64.a(fftw_destroy_panl.o):fftw_destroy_plan.c(.text+0x0): first defined here</span><br><span class="line">make[1]: *** [Makefile:99: lapw0_mpi] Error 1</span><br></pre></td></tr></table></figure><p>最终编译信息里提示<code>tetra</code>, <code>joint</code>, <code>telnes3</code>报错, 错误为<code>Internal compiler error</code>.</p><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>因为是FFTW3和MKL的冲突, 所以考虑放弃自己编译的FFTW3, 用Intel自带的FFTW3 wrapper. 在编译好静态库<code>libfftw3xf_intel.a</code>后, 把<code>include</code>改为<code>mkl/interfaces/fftw</code>, 把<code>-lfftw3</code>改为该静态库的绝对路径, 删掉<code>lfftw3_mpi</code></p><p>作上述修改后用<code>siteconfig_lapw</code>重新编译<code>lapw0</code>, 出现<code>fft_modules</code>报错, 提示未定义MPI FFTW3变量的引用. 参考Intel的官方文档, 发现对MPI FFTW3有关变量的包装器定义在<code>fftw3x_cdtf</code>中, 需要编译这个lib. 链接时用它取代原来<code>lfftw3_mpi</code>的位置.</p><p>改完后再重新编译, 这一次报错<code>libfftw3x_cdft</code>链接错误: <code>Undefined reference to DftiSetValueDM</code>. 参考该 <a href="https://software.intel.com/en-us/forums/intel-math-kernel-library/topic/284696" target="_blank" rel="noopener">Intel forum链接</a> , 在静态链接时把<code>libmkl_cdft_core.a</code>放入链接的group中. 编译通过! 这时把RP_LIBS中的<code>libfftw3xf.a</code>去掉, 也可以正常编译.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compilation </tag>
            
            <tag> Intel </tag>
            
            <tag> Bugfix </tag>
            
            <tag> WIEN2k </tag>
            
            <tag> FFTW </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Valgrind笔记(一)——Memcheck初探</title>
      <link href="/2019/03/23/valgrind-1/"/>
      <url>/2019/03/23/valgrind-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>为了对GAP3程序进行调试和优化, 准备使用Valgrind对其内存调用进行检查. 本文是对Valgrind功能的初步探索, 对一个简单程序的Valgrind输出进行了分析.</p><a id="more"></a><h2 id="八卦"><a href="#八卦" class="headerlink" title="八卦"></a>八卦</h2><p>很早就听说过Valgrind这个软件, 对它的名字和Logo很好奇, 粗略搜了一下名字, 在<a href="http://valgrind.org/docs/manual/faq.html#faq.whence" target="_blank" rel="noopener">官方FAQ</a>里发现这样一段话</p><blockquote><p>Q: Where does the name “Valgrind” come from?</p><p>A: From Nordic mythology. Originally (before release) the project was named <a href="https://en.wikipedia.org/wiki/Heimdallr" target="_blank" rel="noopener">Heimdall</a>, after the watchman of the Nordic gods. He could “see a hundred miles by day or night, hear the grass growing, see the wool growing on a sheep’s back”, etc. This would have been a great name, but it was already taken by a security package “Heimdal”.</p><p>Keeping with the Nordic theme, Valgrind was chosen. Valgrind is the name of the main entrance to <a href="https://en.wikipedia.org/wiki/Valhalla" target="_blank" rel="noopener">Valhalla</a> (the Hall of the Chosen Slain in Asgard). Over this entrance there resides a wolf and over it there is the head of a boar and on it perches a huge eagle, whose eyes can see to the far regions of the nine worlds. Only those judged worthy by the guardians are allowed to pass through Valgrind. All others are refused entrance.</p><p>It’s not short for “value grinder”, although that’s not a bad guess.</p></blockquote><p>大意就是, Valgrind取自北欧神话中Valhalla<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="Valhalla在老伊达([The Poetic Edda](https://en.wikipedia.org/wiki/Poetic_Edda))里有记录, 想起来之前读文史大纲的时候遇到过, 见[郑振铎全集](https://book.douban.com/subject/1203864/)第十卷P343.">[1]</span></a></sup>入口的名字, 这个地方挂着熊头, 栖息着一匹狼和一只巨鹰, 视野达九界终焉. 只有被这些守卫者认为具有价值者才可通过Valgrind. 真是读书人呀 :P</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Valgrind的安装比较容易, 可以下载源码, 用<code>./configure; make; make install</code>的方式. 在Fedora上可以从源安装,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install valgrind</span><br></pre></td></tr></table></figure><p>撰写本文时Valgrind最新版本为3.15.0, macOS支持到10.13, 但不支持10.14 Mojave.</p><h2 id="程序编译选项"><a href="#程序编译选项" class="headerlink" title="程序编译选项"></a>程序编译选项</h2><p>为了让Valgrind能够工作, 在编译程序时, 应该采用<code>-g -O1</code>选项进行编译, 原因是</p><ul><li>使用<code>-g</code>产生所有debug需要的symbol.</li><li>优化选项推荐用O1. 可以用O0, 但那会非常慢, 因为在用Valgrind跑程序本身就要慢上<strong>20-30</strong>倍并用上数倍的内存.</li><li>不推荐用O2及以上, 那样会产生很多uninitialised value错误, 但这些error其实是由于优化产生, 并不实际存在于code当中.</li></ul><p>编译完程序以后, 在需要运行程序(比如<code>hello.out</code>)的地方执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --leak-check=yes ./hello.out</span><br></pre></td></tr></table></figure><p>将默认使用Memcheck工具, 检查内存leakage问题. 将<code>yes</code>改成<code>full</code>可以输出具体细节.</p><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>如果需要检查内存泄漏以外的问题, 尽量使用<code>-O0</code>. 这个可以在后面的例子里看到.</p></div><h2 id="实例-越界赋值与内存泄漏"><a href="#实例-越界赋值与内存泄漏" class="headerlink" title="实例: 越界赋值与内存泄漏"></a>实例: 越界赋值与内存泄漏</h2><h3 id="Fortran源码"><a href="#Fortran源码" class="headerlink" title="Fortran源码"></a>Fortran源码</h3><p>下面是一个Fortran程序例子<code>abf.f90</code>, 参考自Jason Blevins的<a href="https://jblevins.org/log/valgrind" target="_blank" rel="noopener">代码</a></p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> abc</span><br><span class="line">    <span class="keyword">integer</span> :: i</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">allocatable</span> :: <span class="keyword">data</span>(:)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">allocate</span>(<span class="keyword">data</span>(<span class="number">5</span>))</span><br><span class="line">    <span class="built_in">print</span>*, rank(<span class="keyword">data</span>), <span class="built_in">size</span>(<span class="keyword">data</span>), loc(<span class="keyword">data</span>)</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, <span class="number">5</span></span><br><span class="line">        <span class="keyword">data</span>(i-<span class="number">1</span>) = i</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>*, <span class="keyword">data</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>*, rank(<span class="keyword">data</span>), <span class="built_in">size</span>(<span class="keyword">data</span>), loc(<span class="keyword">data</span>)</span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> abc</span><br></pre></td></tr></table></figure><p>做一点说明</p><ul><li>这个程序存在两个问题, 一是对<code>data(0)</code>赋值, 但Fortran分配数组时下标从1开始. 这是一个<a href="http://www.qnx.com/developers/docs/qnxcar2/index.jsp?topic=%2Fcom.qnx.doc.neutrino.prog%2Ftopic%2Fhat_OverrunErrors.html" target="_blank" rel="noopener">heap block overrun</a>问题. 二是没有对<code>data</code>数组进行<code>deallocate</code>内存释放</li><li><code>rank</code>, <code>size</code>和<code>loc</code>内建函数分别返回<code>data</code>的维度, 数组中确定类型的数的个数, 即所有维度上长度连乘, 以及array descriptor的位置.</li></ul><h3 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h3><p>编译<code>abc.f90</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gfortran abc.f90 -o abc -g -O0</span><br></pre></td></tr></table></figure><p>为了不让程序直接报错, 没有加上debug需要的<code>-fbounds-check</code>.  运行Valgrind</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind ./abc --leak-check=full</span><br></pre></td></tr></table></figure><h3 id="输出解读"><a href="#输出解读" class="headerlink" title="输出解读"></a>输出解读</h3><p>运行Valgrind给出的输出是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">==28740== Memcheck, a memory error detector</span><br><span class="line">==28740== Copyright (C) 2002-2017, and GNU GPL&apos;d, by Julian Seward et al.</span><br><span class="line">==28740== Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">==28740== Command: ./abc --leak-check=full</span><br><span class="line">==28740==</span><br><span class="line">           1           5             97983168</span><br><span class="line">==28740== Invalid write of size 4</span><br><span class="line">==28740==    at 0x40098C: MAIN__ (abc.f90:8)</span><br><span class="line">==28740==    by 0x400A8F: main (abc.f90:12)</span><br><span class="line">==28740==  Address 0x5d71abc is 4 bytes before a block of size 20 alloc&apos;d</span><br><span class="line">==28740==    at 0x4C2CDCB: malloc (vg_replace_malloc.c:299)</span><br><span class="line">==28740==    by 0x400865: MAIN__ (abc.f90:5)</span><br><span class="line">==28740==    by 0x400A8F: main (abc.f90:12)</span><br><span class="line">==28740==</span><br><span class="line">           1           5             97983168</span><br><span class="line">==28740==</span><br><span class="line">==28740== HEAP SUMMARY:</span><br><span class="line">==28740==     in use at exit: 20 bytes in 1 blocks</span><br><span class="line">==28740==   total heap usage: 22 allocs, 21 frees, 13,516 bytes allocated</span><br><span class="line">==28740==</span><br><span class="line">==28740== LEAK SUMMARY:</span><br><span class="line">==28740==    definitely lost: 20 bytes in 1 blocks</span><br><span class="line">==28740==    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">==28740==      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">==28740==    still reachable: 0 bytes in 0 blocks</span><br><span class="line">==28740==         suppressed: 0 bytes in 0 blocks</span><br><span class="line">==28740== Rerun with --leak-check=full to see details of leaked memory</span><br><span class="line">==28740==</span><br><span class="line">==28740== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==28740== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>对这些输出做一些说明</p><ul><li>运行<code>./abc</code>不会报错, 两个<code>print</code>均正常打印结果, 输出<code>data(1)</code>值为2. <code>loc</code>在赋值前后不变.</li><li>28740是运行任务的PID</li><li>Invalid write部分指出越界赋值的问题. <code>at 0x40098C: MAIN__ (abc.f90:8)</code>表示该write在<code>abc.f90</code>的第8行. 如果采用<code>-O1</code>优化, 这个错误会被隐藏起来.</li><li>HEAP SUMMARY给出占用内存的信息. 可以看到, 由于没有free掉整数类型(4 bytes)的data(5), 在退出时还有20 bytes被占用(in use at exit)</li></ul><h2 id="关于memory-lost的类型"><a href="#关于memory-lost的类型" class="headerlink" title="关于memory lost的类型"></a>关于memory lost的类型</h2><p>LEAK SUMMARY给出内存泄漏的总结. 不同的lost对应的含义(总结于Valgrind <a href="http://valgrind.org/docs/manual/faq.html#faq.deflost" target="_blank" rel="noopener">FAQ</a>)</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">definitely lost</td><td style="text-align:left">程序有内存泄漏. 这些泄漏<strong>必须</strong>修正.</td></tr><tr><td style="text-align:left">indirectly lost</td><td style="text-align:left">程序的一个基于指针的结构里存在内存泄漏</td></tr><tr><td style="text-align:left">possibly lost</td><td style="text-align:left">程序存在内存泄漏, 除非做一些操作使得指针重新指向已分配的内存块.</td></tr><tr><td style="text-align:left">still reachable</td><td style="text-align:left">It didn’t free some memory it could have.</td></tr><tr><td style="text-align:left">suppressed</td><td style="text-align:left">存在内存泄漏, 但这些泄漏信息因为Valgrind设置的关系, 被抑制输出了</td></tr></tbody></table><p>做一点说明</p><ul><li>对于“indirectly lost”的解释是, 例如一个二叉树根节点definitely lost, 那么它的子节点就是indirectly lost. Indirectly lost通常在修复definitely lost后消失.</li><li>“still reachable”的含义还不是很清楚, 只是把FAQ原文抄录了, 因为自己还没有遇到, FAQ也说它是一个“常见和合理的错误”, 因此不做展开.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于一个简单的Fortran程序, 从编译源代码开始, 展示了用Valgrind对程序内存调用进行检查的过程. 对Valgrind输出信息进行了初步解读.</p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">Valhalla在老伊达(<a href="https://en.wikipedia.org/wiki/Poetic_Edda" target="_blank" rel="noopener">The Poetic Edda</a>)里有记录, 想起来之前读文史大纲的时候遇到过, 见<a href="https://book.douban.com/subject/1203864/" target="_blank" rel="noopener">郑振铎全集</a>第十卷P343.<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Valgrind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决运行VASP时set_indpw_full错误</title>
      <link href="/2019/03/20/vasp-set_indpw_full-error/"/>
      <url>/2019/03/20/vasp-set_indpw_full-error/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>通过恰当设置KPAR和NPAR, 解决VASP杂化泛函计算中出现的“set_indpw_full”错误.</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用ACFDT-RPA计算Ne的EOS曲线, 在进行+8%体积的非自洽HF计算一步时, 标准输出中打印错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">internal error in SET_INDPW_FULL: insufficient memory</span><br></pre></td></tr></table></figure><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>谷歌该错误,  在<a href="https://cms.mpi.univie.ac.at/vasp-forum/viewtopic.php?t=17510" target="_blank" rel="noopener">第一条vasp forum链接</a>的最后, 楼主给出了解决方法:</p><ol><li>恰当设置KPAR和NPAR, 使得$\rm KPAR\times NPAR$等于总的核数.</li><li>关闭对称性, ISYM=0.</li></ol><p>我试着加上了KPAR=4, 因为总核数为16, NPAR=4, 不再报该错误, 计算顺利完成. 考虑到链接里的错误来自HSE计算, 因此这有可能是进行大体系的VASP杂化泛函计算时容易出现的错误.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
            <tag> Bugfix </tag>
            
            <tag> MPI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>均匀格点与对数格点上的Numerov方法</title>
      <link href="/2019/03/03/numerov-on-log-grid/"/>
      <url>/2019/03/03/numerov-on-log-grid/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文在两种数值格点(均匀格点和对数格点)上推导了Numerov方法的递推方程, 给出了简单的Python实现.</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://en.wikipedia.org/wiki/Numerov%27s_method" target="_blank" rel="noopener">Numerov方法</a>是数值求解常微分方程(ODE)的一种方法, 适用于不含一阶项的二阶ODE</p><p>$$\begin{equation}<br>y’’ + f(r)y = s(r).<br>\end{equation}\label{eq:numerov-ode}<br>$$</p><p>在物理上有很多方程满足这种形式, 其中与我最为相关的是薛定谔方程(SE), 更确切的是三维有心势下的径向薛定谔方程(rSE). 原子单位下, rSE写成</p><p>$$<br>\left[-\frac{d^2}{d r^2} + \frac{l(l+1)}{r^2} + 2V(r)\right]R_l(r) = E_lR_l(r)<br>$$</p><p>其中$R_l$是定义在一维实空间$r$上的波函数$u_l$与矢径长$r$的积, $R_l(r)=ru_l(r)$, $E_l$是能量, $l$是角量子数. 这个方程满足Numerov方程要求的ODE形式</p><p>$$<br>\begin{cases}<br>f(r) = -\frac{l(l+1)}{r^2} - 2V(r) + E_l \\<br>s(r) = 0<br>\end{cases}<br>$$</p><p>因此可以用该方法数值求解. 本文首先在两种格点方案, 均匀格点和对数格点上推导Numerov方法的核心方程, 即格点递推公式, 然后给出简单的Python实现.</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><h3 id="均匀格点"><a href="#均匀格点" class="headerlink" title="均匀格点"></a>均匀格点</h3><p>首先在均匀格点上推导一下Numerov方法. 在$r$点附近对函数$y$作Taylor展开</p><p>$$<br>\begin{equation}\label{eq:deriv-1}<br>y(r\pm h) = y(r) \pm hy’(r) + \frac{h^2}{2}y’’(r) \pm \frac{h^3}{6}y’’’(r) + \frac{h^4}{24}y’’’’(r) + \cdots<br>\end{equation}<br>$$</p><p>将正负两式相加</p><p>$$<br>\begin{equation}\label{eq:deriv-2}<br>y(r-h)+y(r+h) = 2y(r) + h^2y’’(r) + \frac{h^4}{12}y’’’’(r) + \mathcal{O}(h^6)<br>\end{equation}<br>$$</p><p>由于</p><p>$$<br>y’’’’(r) = \frac{d^2}{d r^2}\left[f(r)y(r)-s(r)\right],<br>$$</p><p>定义$p(r):=f(r)y(r)-s(r), p=y’’, p’’=y’’’’$, 可以采用与式$\eqref{eq:deriv-1}\eqref{eq:deriv-2}$类似的办法处理$p$, 得到</p><p>$$<br>\begin{equation}\label{eq:deriv-3}<br>p(r-h)+p(r+h) = 2p(r) + h^2 p’’(r) + \frac{h^4}{12}p’’’’(r) + \mathcal{O}(h^6).<br>\end{equation}<br>$$</p><p>把$p, p’’$表达式$\eqref{eq:deriv-3}$回代到式$\eqref{eq:deriv-2}$中,</p><p>$$<br>y(r-h)+y(r+h) = 2y(r) + h^2p(r) + \frac{h^4}{12}\left[p(r-h)+p(r+h)-2p(r)\right] + \mathcal{O}(h^6).<br>$$</p><p>稍作整理, 得到</p><p>$$<br>\begin{aligned}<br>\left[1+\frac{h^2}{12}f(r-h)\right]y(r-h) +&amp; \left[1+\frac{h^2}{12}f(r+h)\right]y(r+h) = \\<br>&amp;2\left[1+\frac{h^2}{12}f(r)\right]y(r) - h^2f(r)y(r) + \frac{h^2}{12}\left[s(r-h)+10s(r)+s(r+h)\right] + \mathcal{O}(h^6).<br>\end{aligned}<br>$$</p><p>这就是Numerov方法的一般方程. 特别的, 对于齐次方程, $s=0$, 式子可以化简成</p><p>$$<br>\left[1+\frac{h^2}{12}f(r+h)\right]y(r+h) = 2\left[1+\frac{h^2}{12}f(r)\right]y(r) - \left[1+\frac{h^2}{12}f(r-h)\right]y(r-h) - h^2f(r)y(r) + \mathcal{O}(h^6).<br>$$</p><p>取间距为$h$的均匀格点, 此时上式化成三点递推方程,</p><p>$$<br>(1+\frac{h^2}{12}f_{n+1})y_{n+1} = 2(1+\frac{h^2}{12}f_n)y_n - (1+\frac{h^2}{12}f_{n-1})y_{n-1} - h^2f_n y_n<br>$$</p><p>精确到步长的六次方. 实际应用当中, 我们需要先确定前两个格点上的值, 然后就可以用上式推出第三点及之后所有格点上的函数值.</p><h3 id="对数格点"><a href="#对数格点" class="headerlink" title="对数格点"></a>对数格点</h3><p>除了实空间均匀格点, 我们也可以使用对数均匀格点(logarithmic grid), 其上第n个实空间格点为</p><p>$$<br>r_n = r_0 e^{nh}<br>$$</p><p>上面的Numerov方法不能直接用于格点$\{r_n\}$, 因为这种情况下格点$r$间距是变化的, 但是我们可以通过代数变换使之成为可能. 首先定义变量替换$x\mapsto r$</p><p>$$<br>r(x) = r_0e^x<br>$$</p><p>及定义$Y(x)$为</p><p>$$\begin{equation}<br>y(r) = r_0e^{x/2}Y(x).<br>\end{equation}\label{eq:log-trans-y}$$</p><p>从而</p><p>$$<br>\begin{aligned}<br>\frac{d^2}{d r^2}y(r) &amp;= \frac{1}{r_0e^x}\frac{d}{dx}\left[\frac{1}{e^x}\frac{d}{d x}\left(e^{x/2}Y(x)\right)\right] \\<br>&amp;=\frac{1}{r_0e^x}\left[-\frac{1}{4}e^{-x/2}Y(x) + e^{-x/2}Y’’(x)\right] \\<br>\end{aligned}<br>$$</p><p>其中撇号代表对$x$求导而非$r$. 代回到式$\eqref{eq:numerov-ode}$的ODE中</p><p>$$<br>\begin{aligned}<br>\frac{1}{r_0}e^{-3x/2}\left[-\frac{1}{4}Y(x) + Y’’(x)\right] + f(r)r_0e^{x/2}Y(x) &amp;= s(r)\\<br>Y’’ + \left[f(r)r^2_0e^{2x}-\frac{1}{4}\right]Y(x) &amp;= r_0e^{3x/2}s(r).<br>\end{aligned}<br>$$</p><p>令</p><p>$$\begin{equation}<br>\begin{aligned}<br>F(x):=&amp;f(r)r^2_0e^{2x}-\frac{1}{4}= f(r(x))r(x)^2-\frac{1}{4} \\<br>S(x):=&amp;r_0e^{3x/2}s(r) = \sqrt{\frac{r(x)^3}{r_0}}s(r(x))<br>\end{aligned}<br>\end{equation}\label{eq:log-trans-f-s}$$</p><p>于是得到ODE</p><p>$$<br>Y’’(x) + F(x)Y(x) = S(x)<br>$$</p><p>这与原始ODE$\eqref{eq:numerov-ode}$相似, 但它定义在变量$x$上而非实空间$r$上. 由于格点$x$是均匀的, 我们可以应用前面均匀格点的算法解出$Y(x)$, 然后再通过式$\eqref{eq:log-trans-y}$变换回$y(r)$.</p><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><p>以下是忽略了s后, Numerov方法在均匀格点和对数格点上的Python实现. Numba装饰器用于编译优化.</p><p>首先是均匀格点上的实现<code>numerov</code>, 参考了<a href="https://www.physics.rutgers.edu/grad/509/src_prog/hmw/Hydrogen.html" target="_blank" rel="noopener">Kristjan Haule</a>的代码.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@numba.njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numerov</span><span class="params">(f, h, y0, dy0)</span>:</span></span><br><span class="line">    <span class="string">'''Solve y''(r) + f(r)y(r)=0 by Numerov method on a linear r grid</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        f (1d-array): f</span></span><br><span class="line"><span class="string">        h (float): the step size of linear grid</span></span><br><span class="line"><span class="string">        y0 (float): y value at the first grid point</span></span><br><span class="line"><span class="string">        dy0 (float): first-order derivaitve at the first grid point</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    y = np.zeros(len(f))</span><br><span class="line">    y[<span class="number">0</span>] = y0</span><br><span class="line">    y[<span class="number">1</span>] = y0 + h * dy0</span><br><span class="line">    h2 = h**<span class="number">2</span></span><br><span class="line">    h2d12 = h2/<span class="number">12.0</span></span><br><span class="line">    w0 = y0 * (<span class="number">1</span> + h2d12 * f[<span class="number">0</span>])</span><br><span class="line">    w1 = y[<span class="number">1</span>] * (<span class="number">1</span> + h2d12 * f[<span class="number">1</span>])</span><br><span class="line">    yn = y[<span class="number">1</span>]</span><br><span class="line">    fn = f[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, len(f)):</span><br><span class="line">        w2 = <span class="number">2</span> * w1 - w0 - h2 * fn * yn</span><br><span class="line">        fn = f[n]</span><br><span class="line">        yn = w2 / (<span class="number">1</span> + h2d12 * fn)</span><br><span class="line">        y[n] = yn</span><br><span class="line">        w0, w1 = w1, w2</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>然后是对数格点上的实现<code>numerov_log</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@numba.njit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numerov_log</span><span class="params">(r, f, y0, dy0)</span>:</span></span><br><span class="line">    <span class="string">'''Solve y''(r) + f(r)y(r) = 0 by Numerov method on an exponential r grid</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        r (1d-array): the logarithmic grid</span></span><br><span class="line"><span class="string">        f (1d-array)</span></span><br><span class="line"><span class="string">        y0 (float): y at the first grid</span></span><br><span class="line"><span class="string">        dy0 (float): first-order derivaitve at the first grid</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    r0 = r[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># calculate F(x)</span></span><br><span class="line">    F = np.multiply(f, np.power(r, <span class="number">2</span>)) - <span class="number">0.25E0</span></span><br><span class="line">    x = np.log(r/r0)</span><br><span class="line">    <span class="comment"># step size in x</span></span><br><span class="line">    hx = x[<span class="number">1</span>] - x[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># convert boundary condition of y to Y</span></span><br><span class="line">    Y0 = y0 / r0</span><br><span class="line">    dY0 = - Y0/<span class="number">2</span> + dy0 * r0</span><br><span class="line">    <span class="comment"># call Numerov on linear grid x</span></span><br><span class="line">    Y = numerov(F, hx, Y0, dY0)</span><br><span class="line">    <span class="keyword">return</span> Y * np.sqrt(r * r0)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numerical method </tag>
            
            <tag> Grid technique </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pandoc笔记(二)——使用panflute编写过滤器</title>
      <link href="/2019/01/05/panflute_practice/"/>
      <url>/2019/01/05/panflute_practice/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文简单介绍了笔者学习通过panflute编写pandoc过滤器的过程, 实现了一个将<code>#anytag(date, mood)</code>转化为可用Bootstrap CSS渲染的HTML源码的过滤器.</p><a id="more"></a><p>在<a href="/2019/01/02/pandoc-md-to-pdf/" title="Pandoc笔记(一)——转化Markdown为PDF">Pandoc笔记(一)——转化Markdown为PDF</a>一文里我尝试用HTML和LaTeX转化Markdown文本到PDF, 包括用CSS和LaTeX模板自定义PDF输出. 但有时我们需要在转化时对Markdown文本本身进行on-the-fly的修改. 这是仅仅修改样式无法完成的, 需要借助<a href="https://pandoc.org/filters.html" target="_blank" rel="noopener">pandoc过滤器</a>直接修改抽象语义树(abstract syntax tree, AST).</p><p>过滤器原则上需要用Haskell写. 对于不会写Haskell的开发人员, jgm老师提供了它的Python包装<a href="https://github.com/jgm/pandocfilters">pandocfilters</a>. 它的一个替代品是<a href="http://scorreia.com/software/panflute/" target="_blank" rel="noopener">panflute</a>, 特点是提供了额外的帮助函数, 便于debug等等. 下面过滤器代码都是基于panflute的.</p><h2 id="学习简单例子"><a href="#学习简单例子" class="headerlink" title="学习简单例子"></a>学习简单例子</h2><h3 id="强调转删除线"><a href="#强调转删除线" class="headerlink" title="强调转删除线"></a>强调转删除线</h3><p>官网上一个将<code>*x*</code>强调文字换成<code>~~x~~</code>删除线文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># filename: emph_so.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Replace Emph elements with Strikeout elements</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> panflute <span class="keyword">import</span> Emph, Strikeout, run_filter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(elem, doc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(elem, Emph):</span><br><span class="line">        <span class="keyword">return</span> Strikeout(*elem.content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(doc=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> run_filter(action, doc=doc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pandoc sometext.md --filter emph_so.py -t gfm -o filtered.md</span><br></pre></td></tr></table></figure><p>下面的文字可作为测试</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里有一句<span class="emphasis">*本来被强调的文字*</span>. 处理后会和这一段~~被删除的文字~~一样.</span><br></pre></td></tr></table></figure><h3 id="删除注释"><a href="#删除注释" class="headerlink" title="删除注释"></a>删除注释</h3><p>用的是Panflute GitHub repo里的例子<a href="https://github.com/sergiocorreia/panflute/blob/master/examples/panflute/comments.py">comments.py</a>. 注意原链接17行(这里19行)应该是<code>el.format</code>, 而不是<code>doc.format</code>. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># filename: comments.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Pandoc filter that causes everything between</span></span><br><span class="line"><span class="string">'&lt;!-- BEGIN COMMENT --&gt;' and '&lt;!-- END COMMENT --&gt;'</span></span><br><span class="line"><span class="string">to be ignored.  The comment lines must appear on</span></span><br><span class="line"><span class="string">lines by themselves, with blank lines surrounding</span></span><br><span class="line"><span class="string">them.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> panflute <span class="keyword">as</span> pf</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(doc)</span>:</span></span><br><span class="line">    doc.ignore = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment</span><span class="params">(el, doc)</span>:</span></span><br><span class="line">    is_relevant = (type(el) == pf.RawBlock) <span class="keyword">and</span> (el.format == <span class="string">'html'</span>)</span><br><span class="line">    <span class="keyword">if</span> is_relevant <span class="keyword">and</span> re.search(<span class="string">"&lt;!-- BEGIN COMMENT --&gt;"</span>, el.text):</span><br><span class="line">        doc.ignore = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> doc.ignore:</span><br><span class="line">        <span class="keyword">if</span> is_relevant <span class="keyword">and</span> re.search(<span class="string">"&lt;!-- END COMMENT --&gt;"</span>, el.text):</span><br><span class="line">            doc.ignore = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pf.toJSONFilter(comment, prepare=prepare)</span><br></pre></td></tr></table></figure><p>以下文字可供测试：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- BEGIN COMMENT --&gt;</span></span></span><br><span class="line"></span><br><span class="line">在这里的文字在经过comments.py过滤后会消失. </span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- END COMMENT --&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="将所有标题上升一层"><a href="#将所有标题上升一层" class="headerlink" title="将所有标题上升一层"></a>将所有标题上升一层</h3><p>自己的原始Markdown笔记都是以h1开始, 这样在LaTeX转化时可以正常转为section. 但Hexo博文正文标题是h2开始的, 因此将原始Markdown笔记转化为Hexo博文中需要修改标题层级结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># filename: header-up.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Set headers to 1 level higher. </span></span><br><span class="line"><span class="string">Remove h6, and add '.' at the end if there was no '.'</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> panflute <span class="keyword">import</span> Header, Para, run_filter, Block, Str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(el, doc)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(el, Header):</span><br><span class="line">        <span class="keyword">if</span> el.level &lt; <span class="number">6</span>:</span><br><span class="line">            el.level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            _contents = el.content</span><br><span class="line">            _lastcont = _contents[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> isinstance(_lastcont, Str):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> _lastcont.text.endswith(<span class="string">'.'</span>):</span><br><span class="line">                    _lastcont.text += <span class="string">'.'</span></span><br><span class="line">            <span class="keyword">return</span> Para(*el.content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(doc=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> run_filter(action, doc=doc) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这段代码还处理了h6的特殊情况. 下面的文字可以作为测试</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># was a level-1 header</span></span><br><span class="line"></span><br><span class="line"><span class="section">## was a level-2 header</span></span><br><span class="line"></span><br><span class="line"><span class="section">### was a level-3 header</span></span><br><span class="line"></span><br><span class="line"><span class="section">#### was a level-4 header</span></span><br><span class="line"></span><br><span class="line"><span class="section">##### was a level-5 header</span></span><br><span class="line"></span><br><span class="line"><span class="section">###### was a level-6 header</span></span><br></pre></td></tr></table></figure><h2 id="进阶尝试-转换-lt-badge-gt"><a href="#进阶尝试-转换-lt-badge-gt" class="headerlink" title="进阶尝试: 转换&lt;badge /&gt;"></a>进阶尝试: 转换<code>&lt;badge /&gt;</code></h2><p>基于上面<a href="#删除注释">删除注释</a>的例子, 写了一个这样的一个例子, 目的是将<code>&lt;badge id=id text=text /&gt;</code>形式的HTML文本转换为<code>&lt;span class=&quot;badge badge-id&quot;&gt;text&lt;/span&gt;</code>, 后者可以被Bootstrap CSS渲染. 代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># filename: badge_span.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Pandoc filter that turns the inline &lt;xxx id=id text=text /&gt;</span></span><br><span class="line"><span class="string">to &lt;span class="xxx xxx-id"&gt;text&lt;/span&gt;</span></span><br><span class="line"><span class="string">xxx equals to 'badge, label' currently</span></span><br><span class="line"><span class="string">text should have no space</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> panflute <span class="keyword">as</span> pf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_id_text</span><span class="params">(raw_inline)</span>:</span></span><br><span class="line">    <span class="string">'''return (id, string) tuple</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _ide = <span class="string">''</span></span><br><span class="line">    _str = <span class="string">''</span></span><br><span class="line">    iden = re.findall(<span class="string">'(id=[\"\']?\w+[\"\']?[ ]*[/&gt;]?)'</span>, raw_inline)</span><br><span class="line">    text = re.findall(<span class="string">'(text=[\"\']?\w+[\"\']?[ ]*[/&gt;]?)'</span>, raw_inline)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(iden) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> iden[<span class="number">0</span>] != <span class="string">''</span>:</span><br><span class="line">            _ide = iden[<span class="number">0</span>][<span class="number">3</span>:<span class="number">-1</span>].strip()</span><br><span class="line">    <span class="keyword">if</span> len(text) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> text[<span class="number">0</span>] != <span class="string">''</span>:</span><br><span class="line">            _str = text[<span class="number">0</span>][<span class="number">5</span>:<span class="number">-1</span>].strip()</span><br><span class="line"></span><br><span class="line">    _ret = [_ide, _str]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, token <span class="keyword">in</span> enumerate(_ret):</span><br><span class="line">        <span class="keyword">if</span> token != <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">if</span> token.startswith((<span class="string">"\'"</span>, <span class="string">"\""</span>)):</span><br><span class="line">                _ret[i] = _ret[i][<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> token.endswith((<span class="string">"\'"</span>, <span class="string">"\""</span>)):</span><br><span class="line">                _ret[i] = _ret[i][:<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> tuple(_ret)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rawinline_label_badge</span><span class="params">(el, doc)</span>:</span></span><br><span class="line">    is_rawinline = isinstance(el, pf.RawInline) <span class="keyword">and</span> (el.format == <span class="string">'html'</span>)</span><br><span class="line">    <span class="keyword">if</span> is_rawinline:</span><br><span class="line">        <span class="keyword">if</span> re.match(<span class="string">"&lt;label"</span>, el.text) <span class="keyword">or</span> re.match(<span class="string">"&lt;badge"</span>, el.text):</span><br><span class="line">            __cls = re.findall(<span class="string">'(&lt;\w+)'</span>, el.text)</span><br><span class="line">            __cls[<span class="number">0</span>] = __cls[<span class="number">0</span>][<span class="number">1</span>:]</span><br><span class="line">            identi, text = extract_id_text(el.text)</span><br><span class="line">            <span class="keyword">if</span> identi != <span class="string">''</span>:</span><br><span class="line">                __cls.append(__cls[<span class="number">0</span>] + <span class="string">'-'</span> + identi)</span><br><span class="line">            <span class="keyword">return</span> pf.Span(pf.Str(text), classes=__cls)</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pf.toJSONFilter(rawinline_label_badge)</span><br></pre></td></tr></table></figure><p>由于转化基于<code>RawInline</code>对象, 所以单独为一行的badge或者label是无法正常转化的. 例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">右侧两个是可以的 <span class="xml"><span class="tag">&lt;<span class="name">badge</span> <span class="attr">id</span>=<span class="string">"warn"</span> <span class="attr">text</span>=<span class="string">"badge-warn"</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">badge</span> <span class="attr">id</span>=<span class="string">"info"</span> <span class="attr">text</span>=<span class="string">"badge-info"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>下面有一个单独成行的<code>badge-danger</code>是在这个脚本下是渲染不出来的. </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">badge</span> <span class="attr">id</span>=<span class="string">"danger"</span> <span class="attr">text</span>=<span class="string">"单独成行的badge-danger"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="过滤器调试"><a href="#过滤器调试" class="headerlink" title="过滤器调试"></a>过滤器调试</h2><p>直接用<code>--filter</code>选项套用过滤器比较难调试. 可以用以下方法来调试, 其中pandoc输出格式必须作为过滤器的第一个变量声明. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc -t json | ./filter.py latex | pandoc -f json -t latex</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc --filter./filter.py -f json -t latex</span><br></pre></td></tr></table></figure><p>也可以使用<code>convert_text</code>来检查自己对一段文字的AST的理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> panflute <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag1 = <span class="string">'Some #Tag(abc, cde)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>convert_text(tag1)</span><br><span class="line">[Para(Str(Some) Space Str(<span class="comment">#Tag(abc,) Space Str(cde)))]</span></span><br></pre></td></tr></table></figure><h2 id="实际例子-转化行内带-的标签"><a href="#实际例子-转化行内带-的标签" class="headerlink" title="实际例子: 转化行内带#的标签"></a>实际例子: 转化行内带<code>#</code>的标签</h2><p>这个例子的目的是转化<code>#anytag(date, mood)</code>到HTML源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;badge badge-tag&quot;&gt;#anytag(date, mood)&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>之所以想做这个转化是因为在笔记软件里会用<code>#tag</code>做笔记分类, 想在转化时把这个tag转化成bootstrap的徽章, 这样在借助HTML转化时就能用BS渲染标签.</p><p>在上面过滤器调试的<code>tag1</code>例子里, 我们看到如果<code>date</code>和<code>mod</code>之间如果有空格时, 上面的tag会转化成两个<code>[Str Space Str]</code>. 这个时候就要用到前面<code>comments.py</code>中的<code>doc.ignore</code>来判断一个标签是否完成, 以及处理中间出现的空间. </p><p>最后的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/local/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># filename: tag_span.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Pandoc filter that turns </span></span><br><span class="line"><span class="string">   "#XXX(...)" to '&lt;span class="badge badge-warn"&gt;#XXX(...)&lt;/span&gt;'</span></span><br><span class="line"><span class="string">and</span></span><br><span class="line"><span class="string">   "@XXX(...)" to &lt;span class="badge badge-info"&gt;@XXX(...)&lt;/span&gt;</span></span><br><span class="line"><span class="string">letters, numbers, comas, underscore, hyphon and space are allowed in the parenthese</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> panflute <span class="keyword">as</span> pf</span><br><span class="line"></span><br><span class="line">str_to_replace = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepare</span><span class="params">(doc)</span>:</span></span><br><span class="line">    <span class="string">'''ignore represents whether in the tag/people environment</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    doc.ignore = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_tag_people</span><span class="params">(el, doc)</span>:</span></span><br><span class="line"></span><br><span class="line">    dict_tag_people = &#123;<span class="string">"#"</span>: <span class="string">"warn"</span>, <span class="string">"@"</span>: <span class="string">"info"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> str_to_replace</span><br><span class="line">    is_str = isinstance(el, pf.Str)</span><br><span class="line">    <span class="keyword">if</span> is_str:</span><br><span class="line">        _text = el.text</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> doc.ignore:</span><br><span class="line">            <span class="comment"># outside the tag/people, check if meet a tag/people</span></span><br><span class="line">            <span class="keyword">if</span> re.fullmatch(<span class="string">"[#@][\w-]+\([\w,-]*\)"</span>, _text):</span><br><span class="line">                <span class="comment"># direct return the span if the string has both left parenthese and right parenthese</span></span><br><span class="line">                str_to_replace = <span class="string">''</span></span><br><span class="line">                <span class="keyword">return</span> pf.Span(pf.Str(_text), \</span><br><span class="line">                        classes=[<span class="string">"badge"</span>, <span class="string">"badge"</span>+<span class="string">'-'</span>+dict_tag_people[_text[<span class="number">0</span>]]])</span><br><span class="line">            <span class="keyword">if</span> re.fullmatch(<span class="string">"[#@][\w-]+"</span>, _text):</span><br><span class="line">                <span class="comment"># direct return span if the string has noparenthese</span></span><br><span class="line">                str_to_replace = <span class="string">''</span></span><br><span class="line">                <span class="keyword">return</span> pf.Span(pf.Str(_text), \</span><br><span class="line">                        classes=[<span class="string">"badge"</span>, <span class="string">"badge"</span>+<span class="string">'-'</span>+dict_tag_people[_text[<span class="number">0</span>]]])</span><br><span class="line">            <span class="keyword">if</span> re.fullmatch(<span class="string">"[#@][\w-]+\([\w,-]*"</span>, _text):</span><br><span class="line">                <span class="comment"># string with left parenthese in it, but with no right parenthese</span></span><br><span class="line">                <span class="comment"># initialize the str_to_replace</span></span><br><span class="line">                str_to_replace = _text</span><br><span class="line">                doc.ignore = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># inside the tag/people, check if the tag/people string ends.</span></span><br><span class="line">            <span class="comment"># Found right parenthese at the end, return the whole string</span></span><br><span class="line">            <span class="keyword">if</span> re.fullmatch(<span class="string">"[^#@][\w,-]+\)"</span>, _text):</span><br><span class="line">                doc.ignore = <span class="keyword">False</span></span><br><span class="line">                str_to_replace += _text</span><br><span class="line">                new_Str = pf.Str(str_to_replace)</span><br><span class="line">                <span class="keyword">return</span> pf.Span(new_Str, \</span><br><span class="line">                        classes=[<span class="string">"badge"</span>, <span class="string">"badge"</span>+<span class="string">'-'</span>+dict_tag_people[str_to_replace[<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">            <span class="comment"># no right parenthese found, purge it to str_to_replace, return empty element</span></span><br><span class="line">            str_to_replace += _text</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Not a normal string. If within the tag/people and is a space, add space to str_to_replace</span></span><br><span class="line">        <span class="comment"># otherwise, just give it back to AST</span></span><br><span class="line">        <span class="keyword">if</span> doc.ignore:</span><br><span class="line">            <span class="keyword">if</span> isinstance(el, pf.Space):</span><br><span class="line">                str_to_replace += <span class="string">' '</span></span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pf.toJSONFilter(convert_tag_people, prepare=prepare)</span><br></pre></td></tr></table></figure><p>这个脚本里还对<code>@</code>开头做进行了同样处理, 在Agenda里它用来代表人名. 尝试转化下面的文字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tags: #todo , #todo() , #todo(today) , #todo(today, tomorrow)</span><br><span class="line">People: @todo , @todo() , @todo(today) , @todo(today, tomorrow)</span><br></pre></td></tr></table></figure><p>转化结果</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Tags: <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-warn"</span>&gt;</span></span>\#todo<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> ,</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-warn"</span>&gt;</span></span>\#todo()<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> ,</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-warn"</span>&gt;</span></span>\#todo(today)<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> ,</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-warn"</span>&gt;</span></span>\#todo(today, tomorrow)<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">People: <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-info"</span>&gt;</span></span>@todo<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> ,</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-info"</span>&gt;</span></span>@todo<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>() ,</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-info"</span>&gt;</span></span>@todo<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>(today) ,</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"badge badge-info"</span>&gt;</span></span>@todo<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>(today, tomorrow)</span><br></pre></td></tr></table></figure><p>可以看到以<code>#</code>为前缀的都正确转化了, 而以<code>@</code>前缀的, 含括号的字符串都没有正确转化. </p><p>由于在<code>re.fullmatch</code>中<code>#</code>和<code>@</code>是同样处理的, 出现这种情形只有可能是在<code>pf.Span</code>转化字符串时对<code>#</code>和<code>@</code>做了区别对待. 为了验证, 我们看一下<code>convert_text</code>的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>md2 = <span class="string">"@todo(today, tomorrow)"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>convert_text(md2)</span><br><span class="line">[Para(Cite(Str(@todo)) Str((today,) Space Str(tomorrow)))]</span><br></pre></td></tr></table></figure><p>可见<code>Str</code>对象<code>@todo</code>是<code>Cite</code>对象的子对象, 跟括号所含字符串对应的<code>Str</code>完全分开了, 而我上面的代码没有考虑这个问题. </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于panflute编写了几个pandoc过滤器, 用途包括将原始Markdown标题结构转化为适用于Hexo博文的, 将<code>#tag</code>形式的标签转化为可用Bootstrap CSS渲染的HTML源码.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandoc </tag>
            
            <tag> Markdown </tag>
            
            <tag> Panflute </tag>
            
            <tag> AST </tag>
            
            <tag> Bootstrap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pandoc笔记(一)——转化Markdown为PDF</title>
      <link href="/2019/01/02/pandoc-md-to-pdf/"/>
      <url>/2019/01/02/pandoc-md-to-pdf/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍了使用pandoc工具将markdown文件转化为PDF文件的方法, 讨论了HTML和LaTeX两种转换中介. 由于LaTeX对学术写作有着更好的支持, 笔者将重点放在了后者上. 文中总结了一些模板变量的用法和注意事项, 最后以转换demo.md为例, 用Makefile展示了markdown+pandoc+xelatex+bibtex的一整条工具链.<br><a id="more"></a></p><p>需求之一来自于最近开始将读文献和看日语原版漫画时遇到的单词和用例记录在一个markdown笔记里. 在电脑上阅读这些markdown笔记完全没有问题, 但是在移动端中阅读就比较困难, 每次在Typora里手动导出也很麻烦, 于是就想着能不能把markdown转化成pdf的过程自动化. 自然就想到了在文件格式转换中非常有名的<a href="https://pandoc.org/" target="_blank" rel="noopener">pandoc</a>.</p><h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><p>从Homebrew安装pandoc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pandoc</span><br></pre></td></tr></table></figure><p>然后用pandoc转换一个包含中文释义的笔记demo.md(见<a href="demo.tar.gz">压缩包</a>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc demo.md -o demo.pdf</span><br></pre></td></tr></table></figure><p>返回错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Error producing PDF.</span><br><span class="line">! Package inputenc Error: Unicode character 因 (U+56E0)</span><br><span class="line">(inputenc)                not set up for use with LaTeX.</span><br><span class="line">...</span><br><span class="line">Try running pandoc with --pdf-engine=xelatex.</span><br></pre></td></tr></table></figure><p>照错误信息换用<code>xelatex</code>则出现了一大堆中文字符的<code>Missing character</code>警告</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[WARNING] Missing character: There is no 因 in font [lmroman10-regular]:mapping=tex-text;!</span><br><span class="line">[WARNING] ...</span><br></pre></td></tr></table></figure><p>生成的PDF里这些中文字符都消失了, 只有孤零零的英文. 看来事情没这么简单.</p><h2 id="基于HTML向PDF转化"><a href="#基于HTML向PDF转化" class="headerlink" title="基于HTML向PDF转化"></a>基于HTML向PDF转化</h2><p>一开始转化单词笔记的时候就是想转成GitHub Favored Markdown风格的PDF, 于是第一反应是找了一个类似GFM的<a href="https://gist.github.com/killercup/5917178" target="_blank" rel="noopener">CSS</a>, 下载为<code>gfm.css</code>, 和md存放在一个文件夹下, 运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wrong command</span></span><br><span class="line">pandoc note.md -o note.pdf --css gfm.css</span><br></pre></td></tr></table></figure><p>进行转化, 但这样仍然会报最开始的错误. 其原因是pandoc默认使用LaTeX作为PDF生成引擎, 在这种情况css显然是没有效果的.</p><p>HTML转到PDF的转换引擎的一种选择是开源工具<a href="https://wkhtmltopdf.org/" target="_blank" rel="noopener">wkhtmltopdf</a>, 用Homebrew安装后, 执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandoc note.md -o note.pdf --css gfm.css --pdf-engine wkhtmltopdf -t html5</span><br></pre></td></tr></table></figure><p>就能正常转换了！上面去掉<code>-t html5</code>也可以正常运行. 除了<a href="https://wkhtmltopdf.org/" target="_blank" rel="noopener">wkhtmltopdf</a>外也可以用<a href="http://www.princexml.com/" target="_blank" rel="noopener">prince</a>, 但它太贵了…</p><p><code>gfm.css</code>对自己来说不是特别好看, 尤其没有GitHub那样的浅蓝色代码背景以及对行间代码的渲染, 所以对css稍微做了一些修改. <code>pre code</code>部分参考了这个<a href="https://github.com/sindresorhus/github-markdown-css">CSS</a>, 但它其他样式做得不好看, 也是后来才发现它的, 所以没从它出发_(xз」∠)_</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在一级标题前面加上朝右的蓝色三角 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\25B6\2005"</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0645ad</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">60%</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">pre</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.45</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f6f8fa</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.2em</span> <span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(27,31,35,0.05);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">pre</span>&gt;<span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">max-width</span>: auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: visible;</span><br><span class="line">  <span class="attribute">line-height</span>: inherit;</span><br><span class="line">  <span class="attribute">word-wrap</span>: normal;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2019-04-30补充: 后来又陆续做了其他改进, 转化了北大超算的使用教程, 最终效果大概是下面这样</p><p><figure class="null"><img src="pandoc-html-pdf.png" alt="pandoc-html-pdf"><figcaption>pandoc-html-pdf</figcaption></figure></p><h2 id="借助模板的基于LaTeX的转化"><a href="#借助模板的基于LaTeX的转化" class="headerlink" title="借助模板的基于LaTeX的转化"></a>借助模板的基于LaTeX的转化</h2><p>如果markdown只是写一些代码片断和非常简单的数学公式, 那么上面的HTML转换完全足够了. 但在markdown里写复杂的LaTeX公式仍然非常要命, 有如下两个原因</p><ul><li>在编辑多次出现的复杂记号上有困难. 最简单的例如算符矩阵元尖括号环境, Bloch函数(<code>\varphi_{n\mathbf{k}}(\mathbf{r})</code>), 还有其他上下标特别多的记号. 这种情况下显然没有在tex里直接调<code>physics</code>包和<code>\newcommand</code>自定义来得方便好用, 而重复写很长的LaTeX源码显然使得Markdown失去了它原有的便携性.</li><li>用HTML作为中介产生包含数学公式的PDF需要使用诸如MathJax、MathML或者KaTeX来渲染, 而这些工具的渲染效果在应对复杂公式方面远远不及原生LaTeX.</li></ul><p>所以对于公式密集的笔记还是得用LaTeX作为PDF引擎.</p><h3 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h3><p>在通过LaTeX进行PDF格式转化时, 为了使得转化的tex能够正常编译, 需要用<code>--template</code>选项套用模板. 不借助模板转化得到的tex是无法正常编译的, 例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pandoc.note.md -o note_no_template.tex <span class="comment"># unable to compile</span></span><br><span class="line">pandoc note.md -o note.tex --template default <span class="comment"># compile ok</span></span><br></pre></td></tr></table></figure><p>其中<code>default</code>表示使用默认templates文件夹下后缀对应输出格式、文件名为<code>default</code>的文件作为模板. 默认模板文件的位置(macOS)在<code>share/x86_64-osx-ghc-8.4.4/pandoc-2.4/data/templates/</code>. 在那里可以看到一个<code>default.latex</code>, 就是第二行命令所用的模板. 除LaTeX外, 有其他输出格式的默认模板.</p><p>通过修改模板, 加入想要的LaTeX指令, 可以将markdown转成包含合适的<code>tex</code>文件, 进而得到目标的PDF输出. 要利用编辑好的自定义模板<code>abc.latex</code>有两种办法</p><ol><li>把它放在和<code>note.md</code>同一文件夹下, 将<code>default</code>改为<code>./abc.latex</code>.</li><li>把<code>abc.latex</code>移动到默认templates文件夹下, 将<code>default</code>改为<code>abc</code>.</li></ol><h3 id="编辑模板"><a href="#编辑模板" class="headerlink" title="编辑模板"></a>编辑模板</h3><p>接下来的问题就是怎么写出自己想要的模板. 默认的模板很复杂(至少对我来说), 而且它同不少LaTeX的高级指令有关, 直接看模板会晕. 所以还是从pandoc的<a href="https://pandoc.org/MANUAL.html#templates" target="_blank" rel="noopener">templates手册</a>开始.</p><p>LaTeX模板主要包含序言部分和<code>document</code>环境. 比如我想在序言里包含<code>amsmath</code>包, 那就在模板中序言部分加一句</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br></pre></td></tr></table></figure><p>那它就会出现在被转换的<code>tex</code>文件里.</p><h3 id="文件元数据控制"><a href="#文件元数据控制" class="headerlink" title="文件元数据控制"></a>文件元数据控制</h3><p>为了应对多种情境(handout, slides, book, thesis), 默认模板里通常包含许多pandoc变量. 由这些变量值和一些条件语法, 可以在产生对应于情境的添加文本, 这样就可以用一个模板通吃了. (然而通吃又好用的模板很难维护. )</p><p>这些变量值都可以在一个遵循YAML语法的元数据块(metadata block)中定义. YAML块可以以<code>---</code>开头、<code>...</code>或<code>---</code>结尾的形式写在被转化的文档里(对于md来说这和Hexo一样), 也可以写在一个单独的<code>.yaml</code>文件里, 转化时一并作为输入.</p><p>Pandoc所利用的文件元数据可以在YAML元数据块中定义如下(从manual改编)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">A</span> <span class="string">Fake</span> <span class="string">Thesis</span></span><br><span class="line"><span class="attr">author:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Aristotle</span></span><br><span class="line"><span class="attr">  affiliation:</span> <span class="string">The</span> <span class="string">Academy</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">minyez</span></span><br><span class="line"><span class="attr">  affiliation:</span> <span class="string">PKU</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-01</span><span class="bullet">-02</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">a</span> <span class="string">Pandoc</span> <span class="string">Template</span> <span class="string">Example</span></span><br><span class="line"><span class="attr">abstract:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  Just a non-existing thesis for pandoc test.</span></span><br><span class="line"><span class="string">  The abstract can have multiple lines.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Also can have multiple paragraphs.</span></span><br><span class="line"><span class="string"></span><span class="attr">keywords:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">pandoc</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">markdown</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>做一点解释</p><ul><li>若用如上<code>author</code>写法, 在模板中使用时需要用<code>author.name</code>和<code>author.affiliation</code>来获取对应的姓名和单位, 并对<code>author</code>遍历. 否则这么写是不会在tex中正确产生author的.</li><li><code>abstract</code>可以有多行和多段.</li></ul><p>这些元数据会被包含在生成的PDF元数据中. 下面几节总结一些其他常用的Pandoc变量.</p><h3 id="TOC和文档首尾"><a href="#TOC和文档首尾" class="headerlink" title="TOC和文档首尾"></a>TOC和文档首尾</h3><p>可以用<code>toc</code>变量产生目录页</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">toc-title:</span> <span class="string">"Custom TOC title"</span></span><br><span class="line"><span class="attr">include-before:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"In default template, "</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"we are in the document part, "</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"right after abstract and before TOC"</span></span><br><span class="line"><span class="attr">include-after:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"we are next to the end of the document."</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">"Yep."</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>一些解释</p><ul><li><p><code>toc</code>只需要是一个非空值, 就可以显示目录.</p></li><li><p><code>include-before</code>和<code>include-after</code>的内容会出现document环境内.</p></li><li><p>有<code>header-includes</code>, 可用来在元数据块中定义序言命令. 需要使用LaTeX的源代码环境标记起来, 否则会被当作markdown代码进行转换. 实际使用的时候肯定是把需要的宏包和自定义命令都写在template里面, 比较少用<code>header-includes</code>来定义, 这里就不展开了.</p></li></ul><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">lang:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">dir:</span> <span class="string">ltr</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p><code>lang</code>标识文档的主要语言, 语言代码符合<a href="https://tools.ietf.org/html/bcp47" target="_blank" rel="noopener">BCP 47</a>(BCP: Best Current Practices). 虽说要符合, 但是这个网站并没有直接给出所有可用的语言标签. 暂时只用英语en.</p><p><code>dir</code>控制文字从左向右(ltr)还是从右向左(rtl). 只有<code>xelatex</code>作为PDF引擎使才能完全支持<code>dir</code>. 测试发现rtl在<code>--pdf-engine=pdflatex</code>下不会报错, 但也没有效果.</p><h3 id="可用的LaTeX变量"><a href="#可用的LaTeX变量" class="headerlink" title="可用的LaTeX变量"></a>可用的LaTeX变量</h3><p>这一节总结一些针对LaTeX转换的pandoc变量, 按照用途不同做了简单分类.</p><h4 id="排版布局"><a href="#排版布局" class="headerlink" title="排版布局"></a>排版布局</h4><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td><code>papersize</code></td><td>纸张大小, <code>letter</code>,<code>a4</code></td></tr><tr><td><code>fontsize</code></td><td>字体大小</td></tr><tr><td><code>documentclass</code></td><td>文档类型, <code>article</code>, <code>report</code>, <code>book</code>, <code>memoir</code></td></tr><tr><td><code>beameroption</code></td><td>beamer选项</td></tr><tr><td><code>geometry</code></td><td>设置geometry包的选项, 可设多个值</td></tr><tr><td><code>linestretch</code></td><td>使用<code>setspace</code>包调节行间距</td></tr><tr><td><code>subparagraph</code></td><td>禁用LaTeX模板中将段落重定义为节的行为</td></tr><tr><td><code>lof</code>,<code>lot</code></td><td>包含图和表的列表</td></tr><tr><td><code>thanks</code></td><td>在标题后添加致谢内容</td></tr></tbody></table><p>使用<code>ctexart</code>文档类型可以解决字体问题, 因为这个宏包中包含了字体设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">documentclass:</span> <span class="string">ctexart</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>也可以通过改变下面的字体变量手动调节.</p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td><code>fontfamily</code></td><td>设置<code>pdflatex</code>使用的字体包, 默认为Latin Modern (lm).</td></tr><tr><td><code>fontfamilyoption</code></td><td>对应<code>fontfamily</code>的选项</td></tr><tr><td><code>mainfont</code>等</td><td><code>xelatex</code>使用的字体. 利用<code>fontspec</code>包, 可使用系统字体.</td></tr><tr><td><code>mainfontoption</code>等</td><td>对应于<code>mainfont</code>等的字体选项</td></tr><tr><td><code>fontenc</code></td><td>字体编码. 默认<code>T1</code>应该够用.</td></tr></tbody></table><p><code>mainfont</code>等中包含字体变量<code>mainfont</code>, <code>romanfont</code>, <code>sansfont</code>, <code>monofont</code>,<code>mathfont</code>和<code>CJKmainfont</code>. <code>CJKmainfont</code>的使用需要有<code>xecjk</code>包. 每一个都对应一个<code>fontoption</code>字体选项变量. 系统中可用的中文字体可通过<code>fc-list:lang=zh-cn</code>查看. 日语字体用<code>:lang=ja</code>.</p><p>做以下改动</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">CJKmainfont:</span> <span class="string">Songti</span> <span class="string">SC</span></span><br><span class="line"><span class="attr">mainfont:</span> <span class="string">Times</span> <span class="string">New</span> <span class="string">Roman</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>将<code>CJKmainfont</code>设为<code>Songti SC</code>后上面的字体缺失Warning就没有了. 如果直接把<code>mainfont</code>改成<code>Songti SC</code>也可以解决问题, 但如此一来英文字体也会应用宋体, 看上去就会比较奇怪(用Word应该很有体验). <a href="https://github.com/jgm/pandoc/wiki/Pandoc-With-Chinese-\(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\">Pandoc Wiki</a>)上说用应该把<code>mainfont</code>设为中文字体, 我觉得并不必要.</p><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td><code>colorlinks</code></td><td>链接颜色开关</td></tr><tr><td><code>linkcolor</code></td><td>内链颜色</td></tr><tr><td><code>filecolor</code></td><td>外链颜色</td></tr><tr><td><code>citecolor</code></td><td>引用颜色</td></tr><tr><td><code>urlcolor</code></td><td>URL链接颜色</td></tr><tr><td><code>toccolor</code></td><td>TOC链接颜色</td></tr></tbody></table><p>颜色选项由<code>xcolor</code>提供, 链接颜色由<code>hyperref</code>包及<code>\hypersetup{}</code>命令设置. <code>xcolor</code>手册Section 4中给出了基本颜色和通过<code>dvipsnames</code>,<code>svgnames</code>,<code>x11names</code>选项可用的颜色名字. 比如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">colorlinks:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">linkcolor:</span> <span class="string">red</span></span><br><span class="line"><span class="attr">filecolor:</span> <span class="string">Cyan</span></span><br><span class="line"><span class="attr">urlcolor:</span> <span class="string">Navy</span></span><br><span class="line"><span class="attr">toccolor:</span> <span class="string">Ivory3</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>Navy和Ivory3分别是svgnames和x11names里的颜色名字. 使用svgnames和x11names里的颜色时, 由于默认模板里关于xcolor的语句是</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">[dvipsnames,svgnames*,x11names*]</span><span class="string">&#123;xcolor&#125;</span></span></span><br></pre></td></tr></table></figure><p>此时要使用这两种颜色必须用<code>\definecolors{}</code>事先激活. 比如在模板里xcolor包后添加</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">definecolors</span><span class="string">&#123;Navy&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">definecolors</span><span class="string">&#123;Ivory3&#125;</span></span></span><br></pre></td></tr></table></figure><p>否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! Package xcolor Error: Undefined color `Navy&apos;.</span><br></pre></td></tr></table></figure><p>用相对路径、<code>file://</code>加相对路径或直接绝对路径的本地文件和URL链接都是Navy色. 用<code>run:</code>可以产生Cyan色的文件链接(file link), 但是这样的链接对markdown没有意义.</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>因为暂时还不会考虑加入参考文献(目前至多考虑脚注), 而且想要用markdown+模板达到和用期刊模板一样的参考文献效果似乎不是那么简单, 所以暂不做深入讨论, 可以参考最后的例子和其他网络资源.</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td><code>bibliograph</code></td><td>包含参考文献的bib文件</td></tr><tr><td><code>biblio-style</code></td><td>参考文献风格</td></tr><tr><td><code>biblio-title</code></td><td>参考文献标题</td></tr><tr><td><code>biblatexoptions</code></td><td>biblatex选项</td></tr><tr><td><code>natbiboptions</code></td><td>natbib选项</td></tr><tr><td><code>csl</code></td><td>引用和参考文献风格文件</td></tr></tbody></table><p>使用<code>--filter pandoc-citeproc</code>工具来处理文献时, 会从bib文件中根据markdown提取所需要的参考文献, 再通过CSL文件进行剪裁后加入. 引用的语法为<code>[@bibkey]</code>. 如果脚注上出现引用, 选择. 另外还有一个比较重要的问题是, 直接用<code>pandoc-citeproc</code>无法建立到文献的链接.</p><p>另一种做法是使用<code>--biblatex</code>, 但pandoc manual上注明它不是面向直接转化为PDF的, 而是在产生tex文件后手动编译tex. 为了确认这一点, 我尝试直接输出到PDF, 发现尽管<code>[@bibkey]</code>引用可以正常转化成<code>\cite{bibkey}</code>, 但实际在文档里只显示出加粗的<code>[bibkey]</code>,且<code>\printbibliography</code>指令也打印不出参考文献, 跟<a href="https://tex.stackexchange.com/questions/135484/still-biblatex-will-not-print-bibliography" target="_blank" rel="noopener">这个链接描述的现象</a>一模一样. 这是由于交叉引用需要执行一整套工具链, 而pandoc只运行一步latex.</p><p><code>biblatex</code>默认使用<code>biber</code>为后端, 若使用<code>bibtex</code>来处理参考文献, 需要在元数据块中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">biblatexoptions:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">backend=bibtex</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>这个选项只会在<code>--biblatex</code>开启时有用. 另外<a href="https://pandoc.org/MANUAL.html#citations" target="_blank" rel="noopener">手册指出</a>, 在<code>--bibliography</code>选项中使用<code>.bibtex</code>扩展名的文件时会强制使用<code>bibtex</code>(force bibtex), 但不应该误解: 这里我仍然用的是biblatex, 只是用bibtex而不是biber作为其后端.</p><p>参考文献和引用格式可以通过<code>biblio-style</code>变量设定, 比如<code>-M biblio-style=nature</code>选择nature引用风格. 查看<a href="https://www.ctan.org/tex-archive/macros/latex/exptl/biblatex-contrib" target="_blank" rel="noopener">CTAN的biblatex-contrib</a>查看有哪些可用的风格, 或者在Tex Live Utility搜索biblatex, 查看每个相关包的说明, 又或者查看这个overleaf链接<a href="https://www.overleaf.com/learn/latex/Biblatex_citation_styles" target="_blank" rel="noopener">Biblatex citation styles</a>.</p><h3 id="插入图表"><a href="#插入图表" class="headerlink" title="插入图表"></a>插入图表</h3><p>除了直接用makrdown语法插入图片外, Pandoc支持属性和名称引用, 包含在花括号<code>{}</code>内</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">This is my website logo.</span>](<span class="link">icon.jpg</span>)&#123;width=50% #fig:favicon&#125;</span><br></pre></td></tr></table></figure><p>可在正文中插入<code>+@fig:favicon</code>以引用. 为了得到正确的交叉引用链接, 需要安装<a href="https://github.com/tomduck/pandoc-fignos">pandoc-fignos</a>作为过滤器.</p><p>在制作表格时, pandoc支持单元格含多行文字的表格, 也能非常方便的调整列的对齐方式, 比如以下三列分别是左中右对齐的.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|left | center | right|</span><br><span class="line">|:----|:------:|-----:|</span><br><span class="line">|l    |c       |r     |</span><br><span class="line"></span><br><span class="line">Table: demo left-center-right table &#123;#tbl:demo-tbl&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">left</th><th style="text-align:center">center</th><th style="text-align:right">right</th></tr></thead><tbody><tr><td style="text-align:left">l</td><td style="text-align:center">c</td><td style="text-align:right">r</td></tr></tbody></table><p>在正文中插入<code>+@tbl:demo-tbl</code>以引用. 类似的, 转化时用<a href="https://github.com/tomduck/pandoc-tablenos">pandoc-tablenos</a>过滤后才能得到正确的交叉引用链接.</p><h2 id="实例-转换demo-md到demo-pdf"><a href="#实例-转换demo-md到demo-pdf" class="headerlink" title="实例: 转换demo.md到demo.pdf"></a>实例: 转换<code>demo.md</code>到<code>demo.pdf</code></h2><p>最后放一个用<code>markdown+pandoc+xelatex+bibtex</code>的实际例子, 所需文件都在<a href="demo.tar.gz">压缩包</a>里, 欢迎下载. <code>make</code>编译需要有pandoc和TeXLive等LaTeX发行版.</p><ul><li><code>demo.md</code>：Markdown源文件</li><li><code>Makefile</code>: 产生需要的<code>template.tex</code>和<code>HW.md</code>, 执行LaTeX工具链</li><li><code>demo.bib</code>: 用到的参考文献</li><li><code>icon.jpg</code>: 要插的图片, 就是我的网站图标啦.</li></ul><p>作为参考, 在<a href="https://gist.github.com/maxogden/97190db73ac19fc6c1d9beee1a6e4fc8" target="_blank" rel="noopener">这个gist</a>里作者也详细介绍了如何将markdown转化成paper. 但对于其中的pizza图片, markdown下用的<code>![It&#39;s a pizza]</code>作为图片注释, 转化到PDF后图片注释却变成了<code>Figure 1</code>. 我这里倒是没有这个问题.</p><p>另外, 由于用HTML的转化比较直接, 所需要的就是找个喜欢的CSS, 就不展示了 :P</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文整理了笔者在第一次尝试用pandoc转化markdown文件为PDF的过程中学到的技巧, 并提供了一个简单的pandoc+latex转换PDF的样例输入.</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandoc </tag>
            
            <tag> Markdown </tag>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GPAW笔记(一)——安装及测试</title>
      <link href="/2018/07/20/gpaw-1/"/>
      <url>/2018/07/20/gpaw-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本系列将介绍如何使用第一性原理电子结构计算Python包<a href="https://wiki.fysik.dtu.dk/gpaw/index.html" target="_blank" rel="noopener">GPAW</a>，进行材料的电子结构模拟，包括最基本的DFT基态计算以及更高级的准粒子<em>GW</em>和BSE的光谱性质计算。本文作为该系列的第一篇文章，对GPAW在本地和集群上的安装、样例测试进行介绍，总结了这一过程中遇到的问题和解决方案。<br> <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>相比较VASP、WIEN2k、QE等主流材料几何和电子结构计算程序，GPAW具有的最大特点就是它是一个Python模块，而不是一个独立的程序。你可以像读其他Python模块代码一样读它，查看它属性和docstring，函数依赖参数明确。GPAW中体系构筑依赖于<a href="https://wiki.fysik.dtu.dk/ase" target="_blank" rel="noopener">ASE</a>，一个集成度很高的原子模拟函数模块，作为各种DFT calculator的接口和数据处理及可视化模块被广泛使用。事实上GPAW和ASE都是DTU Thygesen课题组开发维护，因此可以把GPAW看成是ASE自己的first-principles calculator。GPAW中一些performance-critical组件由NumPy或自编的C扩展实现，因此GPAW的计算效率也是有保证的。</p><p>我对GPAW的了解始于对低维体系准粒子能带结构的研究，在这方面Thygesen课题组做了很多重要的工作，这些自然是在GPAW中进行的代码实现，包括参数收敛测试和analytical correction to long wavelength limit，尤其后者是我们希望在LAPW框架下实现的。在读懂代码之前，总应该先熟悉它的使用吧。于是想到了做这个系列。这一回从编译安装开始。</p><p>GPAW安装基于Python模块ASE、NumPy，线性代数库BLAS/LAPACK以及交换关联泛函库LIBXC。快速傅里叶变换可以通过链接FFTW3加速，并行计算可(大规模并行时必须)链接ScaLAPACK。本文将利用以上所有的库，其中线性代数库和ScaLAPACK用Intel MKL代替。</p><p>以下过程所用的<code>python</code>均为在<a href="https://hpc.pku.edu.cn" target="_blank" rel="noopener">北京大学高性能计算平台</a>上anaconda/2-4.4.0.1模块[<code>anaconda (version 1.6.3)</code>]内的<code>python 2.7.15</code>，C扩展的编译器为Intel 2017 update 1的<code>mpiicc</code>，FFTW3(3.3.4)和LIBXC(4.2.3)均由该版本Intel编译器编译。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>作为Python模块，GPAW在<a href="https://pypi.org/" target="_blank" rel="noopener">Python Package Index</a>有项目记录，因此可以使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install gpaw --user</span><br></pre></td></tr></table></figure><p>将其安装到本地用户目录。但这种安装方式不容易控制和自定义外部库的链接，因此我们采用从源码手动安装的方式。主要分以下几步进行。</p><h3 id="依赖的安装"><a href="#依赖的安装" class="headerlink" title="依赖的安装"></a>依赖的安装</h3><h4 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h4><p>载入<code>anaconda</code>环境中已经预装了NumPy环境</p><h4 id="ASE"><a href="#ASE" class="headerlink" title="ASE"></a>ASE</h4><p>使用<code>pip</code>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ase --user</span><br></pre></td></tr></table></figure><h4 id="FFTW3"><a href="#FFTW3" class="headerlink" title="FFTW3"></a>FFTW3</h4><p>留待补充，可先参考官方文档。</p><h4 id="LIBXC"><a href="#LIBXC" class="headerlink" title="LIBXC"></a>LIBXC</h4><p>留待补充，可先参考官方文档。</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>登录GPAW的<a href="https://gitlab.com/gpaw/gpaw/tags" target="_blank" rel="noopener">GitLab-tags</a>，或者在<a href="https://wiki.fysik.dtu.dk/gpaw/install.html#getting-the-source-code" target="_blank" rel="noopener">这里</a>获取最新版本GPAW的tarball, 解压缩得到文件夹<code>gpaw-x.x.x</code>，其中<code>x.x.x</code>为版本号。该文件夹的结构如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── c/                 # C扩展源码</span><br><span class="line">├── CHANGELOG.rst</span><br><span class="line">├── config.py</span><br><span class="line">├── configuration.log</span><br><span class="line">├── CONTRIBUTING.rst</span><br><span class="line">├── COPYING</span><br><span class="line">├── customize.py       # 自定义文件</span><br><span class="line">├── gpaw/              # Python源码</span><br><span class="line">├── LICENSE</span><br><span class="line">├── MANIFEST.in</span><br><span class="line">├── PKG-INFO</span><br><span class="line">├── README.rst</span><br><span class="line">├── setup.py</span><br><span class="line">└── tools/             # 可执行程序，包括并行解释器gpaw-python</span><br></pre></td></tr></table></figure><p>我们暂时将其放在家目录下，即<code>~/gpaw-x.x.x</code>，之后我们将称其为GPAW家目录。</p><h3 id="修改customize-py"><a href="#修改customize-py" class="headerlink" title="修改customize.py"></a>修改<code>customize.py</code></h3><p>经过各种标准的和愚蠢的试错，一个可行的自定义文件写法为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">compiler = <span class="string">'mpiicc -fPIC'</span></span><br><span class="line">mpicompiler = <span class="string">'mpiicc -fPIC'</span>  <span class="comment"># use None if you don't want to build a gpaw-python</span></span><br><span class="line">mpilinker = mpicompiler</span><br><span class="line"></span><br><span class="line"><span class="comment"># the following variables should be defined according to your own environment</span></span><br><span class="line">FFTW3_HOME = <span class="string">'/path/to/FFTW3'</span></span><br><span class="line">MKLROOT    = <span class="string">'/path/to/mkl'</span></span><br><span class="line">LIBXC_HOME = <span class="string">'/path/to/libxc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the order is adapted from Intel MKL link advisor</span></span><br><span class="line">libraries = [</span><br><span class="line">              <span class="string">'mkl_scalapack_lp64'</span>,</span><br><span class="line">              <span class="string">'mkl_intel_lp64'</span> ,<span class="string">'mkl_sequential'</span> ,<span class="string">'mkl_core'</span>,</span><br><span class="line">              <span class="string">'mkl_blacs_intelmpi_lp64'</span>,</span><br><span class="line">              <span class="string">'pthread'</span>,<span class="string">'m'</span>,<span class="string">'dl'</span>,</span><br><span class="line">            ]</span><br><span class="line">mpi_libraries = []</span><br><span class="line"></span><br><span class="line">library_dirs = [ MKLROOT+<span class="string">'/lib/intel64/'</span> , FFTW3_HOME+<span class="string">'/lib/'</span>]</span><br><span class="line"><span class="comment"># include numpy header to use array object</span></span><br><span class="line">include_dirs += [np.get_include(), MKLROOT+<span class="string">'/include/'</span>, FFTW3_HOME+<span class="string">'/include/'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># switch on ScaLAPACK</span></span><br><span class="line">scalapack = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> scalapack:</span><br><span class="line">    define_macros += [(<span class="string">'GPAW_NO_UNDERSCORE_CBLACS'</span>, <span class="string">'1'</span>)]</span><br><span class="line">    define_macros += [(<span class="string">'GPAW_NO_UNDERSCORE_CSCALAPACK'</span>, <span class="string">'1'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># - dynamic linking LIBXC (requires rpath or setting LD_LIBRARY_PATH at runtime):</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">True</span>:</span><br><span class="line">    include_dirs += [LIBXC_HOME+<span class="string">'/include'</span>]</span><br><span class="line">    library_dirs += [LIBXC_HOME+<span class="string">'/lib'</span>]</span><br><span class="line">    <span class="comment"># You can use rpath to avoid changing LD_LIBRARY_PATH:</span></span><br><span class="line">    extra_link_args += [<span class="string">'-Wl,-rpath=%s/lib'</span> % LIBXC_HOME]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'xc'</span> <span class="keyword">not</span> <span class="keyword">in</span> libraries:</span><br><span class="line">        libraries.append(<span class="string">'xc'</span>)</span><br></pre></td></tr></table></figure><span class="label label-danger">问题</span> 之前在这里遇到过一个问题是，当设置<code>compiler=icc</code>时，尽管可以编译通过，但在运行测试时会报错<br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libmkl_blacs_intelmpi_lp64.so: undefined symbol 'MPI_Finalize'</span><br></pre></td></tr></table></figure><span class="label label-success">解决</span>事实上<code>MPI_Finalize</code>本就不是在BLACS里定义的符号，而是MPI库中<code>libmpi.so.12</code>中定义的。这个错误的原因在于<code>libraries</code>是由<code>compiler</code>和<code>mpicompiler</code>公用的链接选项，尽管<code>mpiicc</code>会自动链接<code>libmpi.so</code>，但<code>icc</code>不会，所以会缺少MPI符号定义。将<code>compiler=icc</code>改成<code>compiler=mpiicc</code>即可解决问题。另一种办法是在<code>libraries</code>中增加成员<code>mpi</code>，同时在<code>library_dirs</code>和<code>library_include</code>中分别增加MPI库的lib和include，但这就比较繁琐了。<br><br><span class="label label-info">其他尝试</span> 在出现上面错误的时候，我也尝试了不链接ScaLAPACK和BLACS的办法(<code>scalapack=False</code>)，可以正常通过所有串行和并行测试，但在做Diamond (两原子) <em>GW</em>的全节点32核并行计算时报错<br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: BLACS is unavailable. GPAW must be compiled with BLACS/ScaLAPACK, and must run in MPI-enabled interpreter (gpaw-python)</span><br></pre></td></tr></table></figure><p>所以看来在做大规模并行时，GPAW要求BLACS/ScaLAPACK是必须的，从计算的经济性角度上来看也是可以理解的，帮用户省些钱。我也尝试了用GCC(4.8.5)编译依赖和GPAW，但在链接ScaLAPACK时遇到了问题，要求我用<code>-fPIC</code>选项重新编译所有静态库，但其实我在编译时一直带着该选项。在此注明。</p><h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>在GPAW根目录下，输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install --user</span><br></pre></td></tr></table></figure><p>开始编译。C扩展的编译过程会创建<code>build</code>文件夹，编译结束后会将<code>gpaw</code>文件夹和编译产生的C扩展库<code>_gpaw.so</code>复制到<code>~/.local/lib/python2.7/site-packages/</code>下，复制<code>gpaw</code>等可执行程序到<code>~/.local/bin</code>下。</p><h3 id="安装PAW集测试"><a href="#安装PAW集测试" class="headerlink" title="安装PAW集测试"></a>安装PAW集测试</h3><p>测试前需要将<code>~/.local/bin</code>添加到<code>PATH</code>下。此时还仍然无法进行计算，因为GPAW依赖于赝势和PAW数据集，而下载的源代码中并不包含这一部分。此时需要执行(例如在GPAW根目录下)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpaw install-data pawdir</span><br></pre></td></tr></table></figure><p>让GPAW下载PAW数据集(需要联网，PKUHPC上请使用<code>connect</code>命令，见<a href="https://its.pku.edu.cn/download_ipgwclient.jsp" target="_blank" rel="noopener">pku-its-download</a>)。下载完成后，GPAW会将<code>pawdir</code>绝对路径添加到<code>~/.gpaw/rc.py</code>中，以作为赝势PAW搜索路径。</p><p>结束以上步骤后即可进行测试，四核独立串行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpaw test -j 4</span><br></pre></td></tr></table></figure><p>四核并行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpaw -P 4 test</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec -np 4 gpaw-python -m gpaw test</span><br></pre></td></tr></table></figure><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>用上面的<code>customize.py</code>做并行测试时会在<code>parallel/augment_grid.py</code>报<code>MPI_Barrier</code>错误从而无法全部通过, 但可以使用32核跑官网Tutorial<a href="https://wiki.fysik.dtu.dk/gpaw/tutorials/gw_tutorial/gw_tutorial.html" target="_blank" rel="noopener">准粒子计算</a>的例子<a href="https://wiki.fysik.dtu.dk/gpaw/tutorials/gw_tutorial/gw_tutorial.html#convergence-with-respect-to-cutoff-energy-and-number-of-k-points" target="_blank" rel="noopener">C_ecut_k_conv_GW.py</a> </p></div><h3 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h3><p>测试通过(Hopefully)！可以做具体计算啦。如果写好了名为<code>runscript.py</code>的GPAW并行计算脚本，那么在添加可执行权限后，可以按照如下指令在本地或登录节点执行计算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpiexec -np 4 gpaw-python runscript.py</span><br></pre></td></tr></table></figure><p>而<code>runscript.py</code>具体要怎么写，就是后面教程要做的事情了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过了一段比较挣扎和丢人的编译历程，总算将GPAW编译成功并能用PKUHPC上一整个节点的核心并行计算官方算例。</p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compilation </tag>
            
            <tag> Intel </tag>
            
            <tag> GPAW </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python笔记(一)——利用F2PY调用Fortran函数或子程序</title>
      <link href="/2018/05/15/f2py-1/"/>
      <url>/2018/05/15/f2py-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍了如何在Python脚本中，通过引入Fortran动态库调用Fortran子程序，加速Python中的数值计算。以矩阵乘法为例，比较了调用Python中NumPy和SciPy包的方法和使用Fortran子程序两种方式在计算效率上的差别。<br><a id="more"></a></p><p>Python作为一种动态的解释型编译器，尽管具有新手友好、直观易读、适用范围广的特点，但比起静态的编译型语言Fortran/C，在数值计算方面的表现要差许多，这是由于Python没有被预先编译到机器语言层面。目前流行的Python数值计算包<a href="http://www.numpy.org/" target="_blank" rel="noopener">NumPy</a>和<a href="https://www.scipy.org/scipylib/index.html" target="_blank" rel="noopener">SciPy</a>提供了大量数值计算相关的函数和方法，在很大程度上弥补了Python这一缺点，但仍然无法满足数值计算的全部需求，特别是难以链接一些尚未Python模块化的数学库和工具库。</p><p>作为老牌数值计算语言，Fortran拥有许多高效的数学库，我们很容易在Fortran程序中使用他们，但要把他们用到Python中则并不是那么容易。一种解决方案是使用<a href="https://docs.scipy.org/doc/numpy/f2py/" target="_blank" rel="noopener">F2PY</a>产生Python接口，它是NumPy项目的一部分。基于F2PY，在Python中调用Fortran函数的基本流程是</p><ol><li>编写使用了数学库的Fortran代码</li><li>在恰当的编译选项下使用<code>f2py</code>编译Fortran代码，产生可供引入的动态库</li><li>在Python中通过<code>import</code>引入动态库</li></ol><p>这样就能像调用Python包一样使用Fortran代码中定义的子程序和函数了。下面先简单介绍如何使用<code>f2py</code>，再以矩阵乘法作为例子做说明。</p><h2 id="使用F2PY产生供Python引入的动态库"><a href="#使用F2PY产生供Python引入的动态库" class="headerlink" title="使用F2PY产生供Python引入的动态库"></a>使用F2PY产生供Python引入的动态库</h2><h3 id="聪明的方法-创建署名文件"><a href="#聪明的方法-创建署名文件" class="headerlink" title="聪明的方法: 创建署名文件"></a>聪明的方法: 创建署名文件</h3><p><code>f2py</code>安装就不多说了, 直接上用法.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2py mysubr.F90 -m mysubr -h mysubr.pyf</span><br></pre></td></tr></table></figure><p>其中产生的<code>.pyf</code>就是所谓的署名文件(signature file)。其中定义了Python模块<code>mysubr</code>，它包含一个接口，<code>mysubr.F90</code>中所有函数和子程序都被声明在该接口中。每个声明中包含函数所需参量的类型和维度具体信息。具体可参照<a href="https://docs.scipy.org/doc/numpy/f2py/getting-started.html#the-smart-way" target="_blank" rel="noopener">官方文档</a>。产生<code>.pyf</code>文件后，可用下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2py -c mysub.pyf mysubr.F90</span><br></pre></td></tr></table></figure><p>产生动态库。编译时链接外部函数库(MKL或者FFTW)和一般的编译器相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># link mysubr against libabc.a in /lib/dir/</span></span><br><span class="line">f2py -c mysub.pyf mysubr.F90 -L/lib/dir/ -labc</span><br></pre></td></tr></table></figure><p>所有<code>f2py</code>命令可以用<code>python -m numpy.f2py</code>等价替换, 这样做的好处是f2py版本总是与python版本兼容.</p><h2 id="举例-矩阵乘法"><a href="#举例-矩阵乘法" class="headerlink" title="举例: 矩阵乘法"></a>举例: 矩阵乘法</h2><h3 id="矩阵生成"><a href="#矩阵生成" class="headerlink" title="矩阵生成"></a>矩阵生成</h3><p>在进行矩阵乘法前，首先利用<code>random</code>模块产生<code>ndarray</code>类型的矩阵，这里取100维的方阵进行测试。具体代码如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> seed, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the dimensions</span></span><br><span class="line">m = <span class="number">100</span></span><br><span class="line">k = <span class="number">100</span></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create mat1(m,k) and mat2(k,n) matrices</span></span><br><span class="line">seed()</span><br><span class="line">mat1 = np.array([[random() <span class="keyword">for</span> col <span class="keyword">in</span> range(k)] <span class="keyword">for</span> row <span class="keyword">in</span> range(m)], \</span><br><span class="line">                order=<span class="string">'F'</span>, dtype=<span class="string">'float64'</span>)</span><br><span class="line">seed()</span><br><span class="line">mat2 = np.array([[random() <span class="keyword">for</span> col <span class="keyword">in</span> range(n)] <span class="keyword">for</span> row <span class="keyword">in</span> range(k)], \</span><br><span class="line">                order=<span class="string">'F'</span>, dtype=<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure><p><code>order=&#39;F&#39;</code>使用Fortran的数据存储方式。为保证计算效率，必须<strong>手动设置该值</strong>。</p><div class="alert alert-danger"><i class="fa fa-bug  float-left"></i>  <p>order默认为C。如果不覆盖默认值，Fortran代码的运算效率将下降很多。</p></div><h3 id="执行矩阵乘法"><a href="#执行矩阵乘法" class="headerlink" title="执行矩阵乘法"></a>执行矩阵乘法</h3><p>我们比较四种不同的矩阵乘法实现</p><ol><li><p>NumPy的<code>matmul</code>函数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mat3 = np.matmul(mat1, mat2)</span><br></pre></td></tr></table></figure></li><li><p>SciPy的<code>linalg.blas.dgemm</code>函数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line">mat3 = linalg.blas.dgemm(<span class="number">1.0</span>, mat1, mat2)</span><br></pre></td></tr></table></figure></li><li><p>Fortran的<code>matmul</code>函数</p> <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! file: f_matmul.F90</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> f_matmul(m, n, k, mat1, mat2, mat3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>)  :: m, n, k</span><br><span class="line">    <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">in</span>)  :: mat1(m,k), mat2(k,n)</span><br><span class="line">    <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">out</span>) :: mat3(m,n)</span><br><span class="line"></span><br><span class="line">    mat3 = <span class="built_in">matmul</span>(mat1, mat2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> f_matmul</span><br></pre></td></tr></table></figure><p> <code>m,n,k</code>用于确定矩阵<code>mat1,mat2,mat3</code>的维度，这在纯Fortran中是必须声明的参数，但<code>f2py</code>会将其转化为可选参数，矩阵规模由从Python输入的<code>mat1,mat2</code>确定。在对应Python文件中加入</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> f_matmul <span class="keyword">import</span> f_matmul</span><br></pre></td></tr></table></figure><p> 即可调用.</p></li><li><p>Intel MKL的<code>dgemm</code>子程序</p><p> 将上面Fortran代码中的<code>matmul</code>行替换为</p> <figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">! file: f_dgemm.F90</span></span><br><span class="line"><span class="function"><span class="keyword">subroutine</span></span> f_dgemm(m, n, k, mat1, mat2, mat3)</span><br><span class="line"><span class="comment">!...</span></span><br><span class="line">    <span class="keyword">call</span> dgemm(<span class="string">'N'</span>, <span class="string">'N'</span>, m, n, k, <span class="number">1.0D0</span>, mat1, m, mat2, k, <span class="number">0.0D0</span>, mat3, m)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> f_dgemm</span><br></pre></td></tr></table></figure><p> 此时编译需要链接MKL库，编译命令为</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f2py -c f_dgemm.pyf --fcompiler=intelem --compiler=intelem -L<span class="variable">$MKLROOT</span>/lib/intel64/ -lmkl_rt f_dgemm.F90</span><br></pre></td></tr></table></figure><p> 在对应Python文件中加入</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> f_dgemm <span class="keyword">import</span> f_dgemm</span><br></pre></td></tr></table></figure></li></ol><p>所有源码和编译用Makefile打包在这个<a href="f2py-1.tar.gz">压缩包</a>里了, 方便取用.</p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试结果如下</p><table><thead><tr><th>Dimension</th><th>3000 (o=C)</th><th>5000 (o=C)</th><th>3000</th><th>5000</th><th>10000</th></tr></thead><tbody><tr><td><code>np.matmul</code></td><td>1.1611</td><td>5.2340</td><td>1.1611</td><td>5.2404</td><td>41.8116</td></tr><tr><td>SciPy <code>dgemm</code></td><td>1.3578</td><td>5.8640</td><td>1.1568</td><td>5.2255</td><td>41.4386</td></tr><tr><td>Fortran <code>matmul</code></td><td>1.4907</td><td>6.5730</td><td>1.3204</td><td>5.9488</td><td>48.3035</td></tr><tr><td>Intel MKL <code>dgemm</code></td><td>1.2586</td><td>5.4831</td><td>1.0553</td><td>4.8380</td><td>38.9050</td></tr></tbody></table><p>其中<code>o=C</code>表示使用C存储方式, 不注明则是用Fortran。通过比较可以得到下面的一些结论</p><ul><li>在Fortran order下，计算效率顺序为Fortran <code>matmul</code>&lt;<code>np.matmul</code>&lt;<code>scipy.linalg.blas.dgemm</code>&lt; Intel MKL <code>dgemm</code>。</li><li><code>np.array</code>在内存中的存储方式(<code>order=&#39;C&#39;|&#39;F&#39;</code>)显著影响Fortran <code>matmul</code>, <code>scipy.linalg.blas.dgemm</code>和Intel MKL <code>dgemm</code>的计算效率，<code>order=&#39;F&#39;</code>要比<code>&#39;C&#39;</code>快约10%。</li><li>不合理的存储方式(<code>&#39;C&#39;</code>)导致MKL效率低于<code>np.matmul</code>。</li><li>存储方式对<code>np.matmul</code>没有显著影响。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了使用F2PY工具将Fortran代码编译为可供Python调用的动态库，并以矩阵乘法为例进行演示。同时，比较了流行的Python数值计算模块NumPy和SciPy中的实现与Fortran语言下<code>matmul</code>和MKL<code>dgemm</code>实现的计算效率。测试结果发现，在高维情况下，Intel MKL具有最高的效率。产生<code>ndarray</code>时的存储方式(<code>order=F</code>)对Fortran库中函数计算效率有显著影响。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>使用MKL的DGEMM时，用<code>f2py</code>链接MKL库编译后执行<code>test_mm.py</code>，报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intel MKL FATAL ERROR: Cannot load libmkl_avx2.so or libmkl_def.so</span><br></pre></td></tr></table></figure><p>解决方法是在编译前preload几个核心的Intel库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_PRELOAD=<span class="string">"<span class="variable">$MKLROOT</span>/lib/intel64/libmkl_def.so:<span class="variable">$MKLROOT</span>/lib/intel64/libmkl_sequential.so:<span class="variable">$MKLROOT</span>/lib/intel64/libmkl_core.so"</span></span><br></pre></td></tr></table></figure><p>必须按顺序全部预载入，否则<code>ld</code>会报错。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-05-02"><a href="#2019-05-02" class="headerlink" title="2019-05-02"></a>2019-05-02</h3><ol><li><p>时隔一年各类包都有更新, 原来的代码运行各种问题, 包括在<code>import f_matmul</code>时出现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: dynamic module does not define module export function (PyInit_f_matmul)</span><br></pre></td></tr></table></figure><p> 这一条<a href="https://github.com/pytorch/ELF/issues/98">pytorch issue</a>陈述了类似的问题, 我的理解是由于f2py和python<a href="https://github.com/numpy/numpy/issues/7769">版本不兼容</a>所致. 用<code>python -m numpy.f2py</code>替代<code>f2py</code>即解决了这一问题.</p></li><li><p><code>order=&#39;Fortran&#39;</code>替换为<code>order=&#39;F&#39;</code>.</p></li><li>为方便测试, 将所有源码和Makefile<a href="f2py-1.tar.gz">打包</a>.</li></ol><p>修改后, Fedora 27下运行正常, 但macOS 10.14.4下会报错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: dlopen(f_matmul.cpython-37m-darwin.so, 2): __dyld section not supported in f_matmul.cpython-37m-darwin.so</span><br></pre></td></tr></table></figure><p>根据<a href="https://software.intel.com/zh-cn/forums/intel-fortran-compiler-for-linux-and-mac-os-x/topic/799102" target="_blank" rel="noopener">这条18年10月的Intel Forum帖</a>, 这个问题似乎跟Xcode版本有关. 因为要赶ddl所以暂时没有考虑macOS, 如果有人知道如何解决的话麻烦指点我一下 :)</p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Fortran </tag>
            
            <tag> F2PY </tag>
            
            <tag> MKL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo笔记(一)——安装, Markdown写作与主题</title>
      <link href="/2018/02/15/Hexo-1/"/>
      <url>/2018/02/15/Hexo-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文介绍了使用Hexo配置本博客和用Markdown进行博文写作的基本方法和技巧，为撰写排版更好更清晰的技术文本作准备。 <a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前代码从来都是习惯在组里LinuxPC或者学校HPC上写的，但时常会因为不在随手可及的地方觉得不安。年前从学长手中购入MBP作为自己今后的代码生产主力，同时跑一点简单的科学代码，也想着把Linux和原笔记本上的一些代码项目移到Mac上。这自然就包括了这个Hexo博客。<br>尽管技术写作和笔记并没有停滞，但是一直处于比较粗浅的笔记状态，就没有敢上传到这里(还是希望比较成型后再传)。更主要的一个原因是觉得这个博客的界面配置还始终是未完成状态，自己不甚满意，平时也没有时间好好研究JavaScript和Nodejs代码，最后就没有上传笔记的动力了，导致这个个人域名完全处于浪费钱的状态。于是想趁着春节假期把博客框架好好整一整。<br>这篇文章内所有命令均在macOS High Sierra (10.13)或Mojave (10.14)下执行。默认Homebrew基本配置完成，包括本文所涉及的Git和Nodejs开发环境等，执行命令前需要拥有GitHub账户并完成Git全局配置。</p><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><p>个人博客服务端使用<a href="https://pages.github.com" target="_blank" rel="noopener">Git Pages</a>，它是GitHub专为个人、组织用户和代码项目提供的页面服务，通过Git将本地HTML和CSS文件结构部署(deploy)到Page仓库master分支来实现。创建个人页面的方法是</p><ol><li>类似于一般代码仓库，在GitHub主页上创建名为<code>username@github.io</code>的仓库。以自己为例的话就是<code>minyez@github.io</code>的仓库。个人主页必须以此种方式命名。</li><li>进入新建的仓库，点击Setting标签，在<code>Options</code>下翻到<code>GitHub Pages</code>标签，可以看到这一部分处于激活模式。可与你的其他一般仓库(没有制作<code>doc</code>分支用于文档网站)进行对比。一般代码仓库也可以通过<code>Setting-&gt;Options-&gt;GitHub Pages</code>配置项目文档页面，需要选择<code>doc</code>分支承载HTML文件结构。</li><li>回到Code标签，新建<code>hexo</code>分支，并将其设为默认分支。之后<code>master</code>分支用来存储静态网页，<code>hexo</code>分支存储博文和主题的源文件。</li></ol><h3 id="安装Hexo和Git部署模块"><a href="#安装Hexo和Git部署模块" class="headerlink" title="安装Hexo和Git部署模块"></a>安装Hexo和Git部署模块</h3><p>Hexo是一个模块集成的HTML和CSS文件结构生成程序，用户可以把精力集中在博文内容上，而让Hexo管理界面风格和样式。通过node包管理器<code>npm</code>安装<code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm hexo install</span><br></pre></td></tr></table></figure><p>安装完成后，在某路径下，创建本地Hexo文件夹并初始化。以<code>my-hexo-dir</code>为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir my-hexo-dir</span><br><span class="line">cd my-hexo-dir</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化后，文件夹内结构为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── node_modules</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><code>node_modules</code>内包含在搭建网站时可能需要的模块，比如数学渲染模块<code>hexo-renderer-mathjax</code>和Git部署模块<code>hexo-deployer-git</code>，后者是我们通过Git部署GitHub Pages所必须的。安装模块通过<code>npm</code>完成，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>加入<code>save</code>选项会更新<code>package.json</code>内的包依赖。 <code>--save</code>和<code>--save-dev</code>选项的比较可见这篇<a href="http://pwcong.me/2017/01/05/npm引入模块时--save-与--save-dev-的区别/" target="_blank" rel="noopener">文章</a>。</p><p>修改<code>_config.yml</code>中网络链接和与部署方法相关的代码块以启用<code>git</code>部署</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://minyez.github.io</span></span><br><span class="line"><span class="comment"># deploy method. By Git</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">    repo:</span> <span class="attr">https://github.com/minyez/minyez.github.io.git</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>这样一来，通过Hexo发布自己个人GitHub Pages博客的必要准备已经完成了。在<code>my-hexo-dir</code>下键入以下命令生成静态博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g         <span class="comment"># 使用Hexo生成HTML</span></span><br><span class="line">hexo s -p 4000 <span class="comment"># 生成本地网址，端口为4000</span></span><br></pre></td></tr></table></figure><p>在浏览器访问<code>https://localhost:4000</code> 即可看到生成的Hexo博客。通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>可以将静态页面推送到GitHub Pages中, 此时就能在username.github.io上看到博客了.</p><h3 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h3><p>本博客使用的是从<a href="https://github.com/PytLab/hexo-theme-freemind">PytLab</a>处Fork来的<a href="https://github.com/minyez/hexo-theme-freemind">Freemind</a>主题。首先将仓库下载到本地<code>themes</code>文件夹内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/minyez/hexo-theme-freemind freemind</span><br></pre></td></tr></table></figure><p>下载完成后，修改根目录下<code>_config.yml</code>文件中的<code>theme</code>标签以启用Freemind</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">freemind</span></span><br></pre></td></tr></table></figure><p>若对其他主题感兴趣，可自行google并通过类似的方法架设。此时重新生成并访问，可以发现博客已经从Landscape变为Freemind主题。</p><h3 id="开始写作-从模板新建"><a href="#开始写作-从模板新建" class="headerlink" title="开始写作: 从模板新建"></a>开始写作: 从模板新建</h3><p>在基本设置完成以后，我们就可以开始写作博客了。通过Hexo内建指令<code>new</code>创建新的博文</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post pname</span><br></pre></td></tr></table></figure><p>这会在<code>source/_posts</code>下创建Markdown文件<code>pname.md</code>和文件夹<code>pname</code>，后者用于存放md内引用的图片或代码文件。新建文件名的默认格式可通过修改<code>_config.yml</code>中的<code>new_post_name</code>来调整，例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year-:month-:day-:title.md</span> <span class="comment"># yyyy-mm-dd-pname</span></span><br></pre></td></tr></table></figure><p>此时按上面指令新建<code>pname</code>将得到<code>2018-02-21-pname.md</code>和文件夹<code>2018-02-21-pname</code>。如果文章本身未成型，想先写一个草稿，用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft dname</span><br></pre></td></tr></table></figure><p>会在<code>source/_draft</code>下创建<code>dname.md</code>文件和<code>dname</code>文件夹。草稿写作完成后可用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish dname</span><br></pre></td></tr></table></figure><p>发布，此时Hexo会将<code>dname.md</code>和<code>dname</code>按照<code>new_post_name</code>的格式重命名后，移动到<code>source/_post</code>文件夹下，不需要自己手动改名。</p><h2 id="Hexo写作"><a href="#Hexo写作" class="headerlink" title="Hexo写作"></a>Hexo写作</h2><p>Hexo博客正文写作基于Markdown语法，网络上已经有非常多的教程和帮助文档，例如我现在在<a href="https://kapeli.com/dash" target="_blank" rel="noopener">Dash</a>中使用的<a href="http://daringfireball.net/projects/markdown/syntax#" target="_blank" rel="noopener">cheat sheet</a>。对于Hexo比较特别的是，为了识别博文的基本信息，我们需要一个front matter。另外，除了基本Markdown语法以外，我们还可以使用开源作者编写的Hexo渲染器及主题允许的各种特性，来丰富我们的写作手段。</p><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front matter"></a>Front matter</h3><p><del>对任一篇Hexo博文，文件夹非必须，但一定会有对应的<code>.md</code>文件。</del>Hexo要求博文的<code>.md</code>文件开头需要有一个YAML格式的front matter。根据该front matter，Hexo可识别博文的标题、创建日期、标签、分类等各种特征以及需要用到的渲染器。Front matter的基本格式为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">pname</span>              <span class="comment"># 标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-02</span><span class="bullet">-21</span> <span class="number">16</span><span class="string">:58:25</span> <span class="comment"># 创建时间</span></span><br><span class="line"><span class="attr">tags:</span>                     <span class="comment"># 标签. 不止一个时写成[tag1, tag2]格式</span></span><br><span class="line"><span class="attr">categories:</span>               <span class="comment"># 分类</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>利用<code>hexo new post</code>产生的博文，front matter会套用<code>scaffold</code>中的<code>post.md</code>，相当于post的初始化模板</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&#123;&#123;</span> <span class="string">title</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">date:</span> <span class="string">&#123;&#123;</span> <span class="string">date</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>可根据自己需要修改模板，如增加目录<code>toc</code>、归类<code>categories</code>以及首页图片<code>feature</code>。当存在与md文件名一致的文件夹时，md中图片和代码引用会在该文件夹中搜索，只需要把欲引用的图片代码放入文件夹，将引用路径设为文件名即可。</p><h3 id="基于MathJax的数学公式插入"><a href="#基于MathJax的数学公式插入" class="headerlink" title="基于MathJax的数学公式插入"></a>基于MathJax的数学公式插入</h3><p>由于专业原因，可以预想到很多时候需要插入大量的公式，实现方法是使用浏览器公式引擎<a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a>。推荐使用<a href="https://github.com/phoenixcw/hexo-renderer-mathjax">hexo-renderer-mathjax</a>，安装很方便，对<code>_config.yml</code>的改动量也很小。通过npm安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-mathjax --save</span><br></pre></td></tr></table></figure><p>安装完就可以正常使用。如果出现无法渲染的情况，在<code>_config.yml</code>中加入:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Plugins:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">hexo-renderer-mathjax</span></span><br></pre></td></tr></table></figure><p>输入行内公式可使用<code>$math$</code>，例如</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$P=iGG, G=<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;\omega - \hat&#123;H&#125;</span></span>_&#123;<span class="tag">\<span class="name">text</span><span class="string">&#123;KS&#125;</span></span>&#125;&#125;$</span></span><br></pre></td></tr></table></figure><p>效果：$P=iGG, G=\frac{1}{\omega - \hat{H}_{\text{KS}}}$</p><p>输入公式块可使用<code>$$mathblock$$</code>，例如</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$ <span class="tag">\<span class="name">nabla</span></span>^2 <span class="tag">\<span class="name">phi</span> = </span>-<span class="tag">\<span class="name">rho</span></span> $$</span></span><br></pre></td></tr></table></figure><p>效果：</p><p>$$\nabla^2 \phi = -\rho$$</p><p>此外还可以使用<code>\begin{equation}\end{equation}</code>来产生带编号的公式，但需要对hexo-renderer-mathjax包的内容进行修改。将<code>node_modules/hexo-renderer-mathjax/mathjax.html</code>中间<code>MathJax.Hub.Config</code>函数改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MathJax.Hub.Config(&#123;</span><br><span class="line">    tex2jax: &#123;</span><br><span class="line">        inlineMath: [ [<span class="string">"$"</span>,<span class="string">"$"</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],</span><br><span class="line">        skipTags: [<span class="string">'script'</span>, <span class="string">'noscript'</span>, <span class="string">'style'</span>, <span class="string">'textarea'</span>, <span class="string">'pre'</span>, <span class="string">'code'</span>],</span><br><span class="line">        processEscapes: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    TeX: &#123;<span class="attr">equationNumbers</span>: &#123; <span class="attr">autoNumber</span>: <span class="string">"AMS"</span> &#125;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>即增加<code>TeX</code>一行(不要忘了前面的逗号<code>,</code>)。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula">a=b+&amp;c <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">&amp;+e+f</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;eq1&#125;</span></span>$$</span></span><br></pre></td></tr></table></figure><p>效果：<br>$$\begin{equation}<br>\begin{aligned}<br>a=b+&amp;c \\<br>&amp;+e+f<br>\end{aligned}<br>\end{equation}\label{eq1}$$</p><p>还可以用<code>$\eqref{eq1}$</code>来引用公式$\eqref{eq1}$。上面equation例子还需要注意的是，默认的Markdown渲染器会将两个斜线<code>\\</code>渲染为<code>\</code>，从而导致无法转行。这里根据网络上的办法，修改<code>node_modules/marked/lib/marked.js</code>，将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([\\`*&#123;&#125;\[\]()#+\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">escape</span>: <span class="regexp">/^\\([`*\[\]()# +\-.!_&gt;])/</span>,</span><br></pre></td></tr></table></figure><p>移除marked对花括号和反斜线的渲染。如果出现下划线渲染问题，再将<code>em:</code>一行从</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^_([^\s_](?:[^_]|__)+?[^\s_])_\b|^\*((?:\*\*|[^*])+?)\*(?!\*)/</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure><p>以移除对下划线<code>_</code>的渲染. 看一下结果</p><table><thead><tr><th style="text-align:left">Markdown</th><th style="text-align:left">类型</th><th style="text-align:left">渲染结果</th></tr></thead><tbody><tr><td style="text-align:left"><code>$a_b$</code></td><td style="text-align:left">公式</td><td style="text-align:left">$a_b$</td></tr><tr><td style="text-align:left"><code>$a^*$</code></td><td style="text-align:left">公式</td><td style="text-align:left">$a^*$</td></tr><tr><td style="text-align:left"><code>$a^* b^*$</code></td><td style="text-align:left">公式</td><td style="text-align:left">$a^<em> b^</em>$</td></tr><tr><td style="text-align:left"><code>$a^\ast b^\ast$</code></td><td style="text-align:left">公式</td><td style="text-align:left">$a^\ast b^\ast$</td></tr><tr><td style="text-align:left"><code>*em*</code></td><td style="text-align:left">强调文本</td><td style="text-align:left"><em>em</em></td></tr><tr><td style="text-align:left"><code>_em_</code></td><td style="text-align:left">强调文本</td><td style="text-align:left">_em_</td></tr></tbody></table><p>可以看到, 当公式里同时出现两个星号时, 公式将无法正常渲染. 一种解决方案是用<code>\ast</code>代替<code>*</code>.</p><p>由于Mathjax的CDN<a href="https://www.mathjax.org/cdn-shutting-down/#alternative-cdn-providers" target="_blank" rel="noopener">在17年中退役</a>, 修改<code>mathjax.html</code>中CDN脚本一行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="链接自己博客内的文章"><a href="#链接自己博客内的文章" class="headerlink" title="链接自己博客内的文章"></a>链接自己博客内的文章</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link md-filename-wo-extension %&#125;</span><br></pre></td></tr></table></figure><p>如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link compile_VASP_on_macOS %&#125;</span><br></pre></td></tr></table></figure><a href="/2018/01/02/compile_VASP_on_macOS/" title="解决macOS上编译VASP时遇到的libparser.a未定义符号问题">解决macOS上编译VASP时遇到的libparser.a未定义符号问题</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link f2py<span class="number">-1</span> %&#125;</span><br></pre></td></tr></table></figure><a href="/2018/05/15/f2py-1/" title="Python笔记(一)——利用F2PY调用Fortran函数或子程序">Python笔记(一)——利用F2PY调用Fortran函数或子程序</a><h3 id="图片说明"><a href="#图片说明" class="headerlink" title="图片说明"></a>图片说明</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-image-caption</span><br></pre></td></tr></table></figure><p>在<code>_config.yml</code>中加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image_caption:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  class_name:</span></span><br></pre></td></tr></table></figure><p>并按照这一条<a href="https://github.com/wayou/hexo-image-caption/pull/4/files">PR</a>修改<code>node_modules/hexo-image-caption/index.js</code>.</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>安装<a href="https://github.com/bubkoo/hexo-filter-flowchart">hexo-filter-flowchart</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-filter-flowchart</span><br></pre></td></tr></table></figure><p>直接使用即可. 具体语法参考<a href="https://flowchart.js.org/" target="_blank" rel="noopener">flowchart.js官网</a></p><div id="flowchart-0" class="flow-chart"></div><p>对于比较长的流程, 需要在<code>_config.yml</code>中</p><h2 id="Freemind特性"><a href="#Freemind特性" class="headerlink" title="Freemind特性"></a>Freemind特性</h2><h3 id="首页摘要"><a href="#首页摘要" class="headerlink" title="首页摘要"></a>首页摘要</h3><p>在要作为摘要的文字后面加上<code>&lt;!--more--&gt;</code>，首页将只显示<code>&lt;!--more--&gt;</code>前面的内容，同时出现”Read More”的按钮。摘要内容仍然会在正文中显示。</p><h3 id="标签插件"><a href="#标签插件" class="headerlink" title="标签插件"></a>标签插件</h3><p>使用标签插件(Tag plugins)可以使得文章的可读性更好。在这里我参考了wxpan提供的<a href="https://github.com/PytLab/hexo-theme-freemind/blob/source/_posts/tag-plugins-cn.md">样例</a>。<del>总结一些tag plugins用法，包括一般Hexo和Bootstrap的tag plugins。</del>在使用插件前，需要先安装<a href="https://github.com/wzpan/hexo-tag-bootstrap">Bootstrap</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-tag-bootstrap --save</span><br></pre></td></tr></table></figure><h4 id="标签-label"><a href="#标签-label" class="headerlink" title="标签(label)"></a>标签(label)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label <span class="keyword">default</span> %&#125;</span><br><span class="line">&#123;% label warn warning %&#125;</span><br><span class="line">&#123;% label succ success %&#125;</span><br><span class="line">&#123;% label danger danger %&#125;</span><br><span class="line">&#123;% label prim primary %&#125;</span><br><span class="line">&#123;% label info info %&#125;</span><br></pre></td></tr></table></figure><p>效果是插入一个醒目的颜色小标签<br><span class="label label-default">default</span> <span class="label label-warning">warn</span> <span class="label label-success">succ</span> <span class="label label-danger">danger</span> <span class="label label-primary">prim</span> <span class="label label-info">info</span></p><h4 id="警报-alert"><a href="#警报-alert" class="headerlink" title="警报(alert)"></a>警报(alert)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% alert warning %&#125; 这是一个警告类型的警报 &#123;% endalert %&#125;</span><br><span class="line">&#123;% alert danger %&#125; 这是一个危险类型的警报 &#123;% endalert %&#125;</span><br><span class="line">&#123;% alert success %&#125; 这是一个成功类型的警报 &#123;% endalert %&#125;</span><br><span class="line">&#123;% alert info %&#125; 这是一个信息类型的警报 &#123;% endalert %&#125;</span><br></pre></td></tr></table></figure><p>效果是插入一个带特定背景色的文字块，左上方含有标识文本性质的符号。</p><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>这是一个警告类型的警报 </p></div><div class="alert alert-danger"><i class="fa fa-bug  float-left"></i>  <p>这是一个危险类型的警报 </p></div><div class="alert alert-success"><i class="fa fa-lightbulb-o  float-left"></i>  <p>这是一个成功类型的警报 </p></div><div class="alert alert-info"><i class="fa fa-info  float-left"></i>  <p>这是一个信息类型的警报 </p></div><h4 id="徽章-badge"><a href="#徽章-badge" class="headerlink" title="徽章(badge)"></a>徽章(badge)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% badge 徽章测试 %&#125;</span><br></pre></td></tr></table></figure><p>效果是<span class="badge badge-secondary">徽章测试</span></p><h2 id="Freemind调教"><a href="#Freemind调教" class="headerlink" title="Freemind调教"></a>Freemind调教</h2><div class="alert alert-warning"><i class="fa fa-bell  float-left"></i>  <p>若非特别指出，所有的关于Freemind的调教都是在<code>themes/freemind</code>文件夹内，不要与Hexo根目录混淆。 </p></div><h3 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h3><p><del>Hexo会在根目录下<code>source/assets/images/favicon/</code>内寻找图片作为网站图标。另一种方法是在<code>_config.yml</code>内通过编辑<code>favicon</code>标签显示指定</del></p><p>网站图标设定功能在<code>layout/_partial/head.ejs</code>中定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.favicon</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"&lt;%- config.root %&gt;assets/images/favicon/icon.png"</span> <span class="attr">rel</span>=<span class="string">"icon"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>_config.yml</code>中设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>然后将命名为<code>icon.png</code>的网站图标图片放入Hexo根目录下的<code>source/assets/images/favicon</code>下即可。也可以修改<code>href</code>属性，换成自己想要的路径。</p><h3 id="Wiki型浮窗式的脚注"><a href="#Wiki型浮窗式的脚注" class="headerlink" title="Wiki型浮窗式的脚注"></a>Wiki型浮窗式的脚注</h3><p>用<code>npm</code>安装<a href="https://github.com/kchen0x/hexo-reference">hexo-reference</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-refernce --save</span><br></pre></td></tr></table></figure><p>在Hexo根目录<code>_config.yml</code>中启用插件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Plugins:</span></span><br><span class="line">  <span class="string">hexo-reference</span></span><br></pre></td></tr></table></figure><p>为了跟网页主体风格相一致, 稍微修改了一下其中的源码(<code>hint.min.css</code>)以调整浮窗文字的背景颜色, 置于主题CSS文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">'s/b34e4d/1863a1/g'</span> node_modules/hexo-reference/src/hint.min.css &gt; themes/freemind/<span class="built_in">source</span>/css/hint.min.css</span><br></pre></td></tr></table></figure><p>同时修改<code>index.js</code>, 将<code>href</code>的CDN地址改为本地地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> node_modules/hexo-reference/</span><br><span class="line">mv index.js index.js_bak <span class="comment"># back up original file</span></span><br><span class="line">sed <span class="string">'s/https:\/\/cdn.jsdelivr.net\/hint.css\/2.4.1\//\/css\//g'</span> index.js_bak &gt; index.js</span><br></pre></td></tr></table></figure><p>测试一下效果.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="这是一个脚注测试">[1]</span></a></sup></p><h3 id="边栏链接及链接图标"><a href="#边栏链接及链接图标" class="headerlink" title="边栏链接及链接图标"></a>边栏链接及链接图标</h3><p>在<code>_config.yml</code>内编辑<code>links</code>标签，每一条短线对应一个链接条目</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="attr">  - title:</span> <span class="string">"Github-minyez"</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">https://github.com/minyez</span></span><br><span class="line"><span class="attr">    icon:</span> <span class="string">"fa fa-github"</span></span><br></pre></td></tr></table></figure><p>其中<code>icon</code>对应链接旁显示的图标。本示例使用了<a href="https://fontawesome.com" target="_blank" rel="noopener">Font Awesome</a>提供的图标，该项目提供的全部图标可以在<a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">这里</a>找到。</p><h3 id="谷歌统计GA"><a href="#谷歌统计GA" class="headerlink" title="谷歌统计GA"></a>谷歌统计GA</h3><p>使用谷歌账号登录<a href="https://analytics.google.com/analytics/web/#/" target="_blank" rel="noopener">谷歌统计</a>, 在管理标签中找到用户管理。在媒体资源设置中找到自己的跟踪ID，并设置默认跟踪网址, 然后在跟踪信息-跟踪代码中，将全局网站代码粘贴到<code>layout/_partial/after_foot.ejs</code>底部, 并把明文的GA ID改成<code>&lt;%= theme.google_analytics.siteid %&gt;</code>.</p><p><figure class="null"><img src="follow-code-GA.png" alt="跟踪代码块截图"><figcaption>跟踪代码块截图</figcaption></figure></p><p>在GA主页上, 可以通过”管理-过滤器-添加过滤条件”来排除来自特定IP的流量. GA通过浏览器工作, 而<a href="https://www.en.advertisercommunity.com/t5/Google-Analytics-Filters/Employee-Mobile-Phone-MAC-Address-exclusions/td-p/853289#.XNEMq8OoASk.google" target="_blank" rel="noopener">浏览器不会读取MAC地址</a>, 因此无法通过检测MAC地址的方式排除特定设备的流量.</p><h3 id="不蒜子站点和页面统计"><a href="#不蒜子站点和页面统计" class="headerlink" title="不蒜子站点和页面统计"></a>不蒜子站点和页面统计</h3><p>将<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>整合到Freemind中, 以支持站点访客数统计和页面访问量统计. (GA也可以完成, 但没精力读API了…) 在<code>_config.yml</code>中加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line"><span class="comment"># number of page views from busuanzi</span></span><br><span class="line"><span class="attr">  pageview:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># number of total visitors from busuanzi</span></span><br><span class="line"><span class="attr">  visitor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>以提供一致的开关. 在<code>layout/_partial/post/analytics.ejs</code>中引入js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.busuanzi.pageview || theme.busuanzi.visitor)&#123; %&gt;</span><br><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p>然后在<code>layout/_partial/footer.ejs</code>中加入总访客数标记</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.busuanzi.visitor) &#123; %&gt;</span><br><span class="line">   | <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> visitors<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>在<code>layout/_partial/post/meta.ejs</code>中加入页面总访问数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- page view by busuanzi --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (theme.busuanzi.pageview) &#123; %&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"meta-widget"</span>&gt;</span><br><span class="line">&lt;span id=<span class="string">"busuanzi_container_page_pv"</span>&gt;</span><br><span class="line">&lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-eye"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">&lt;span id=<span class="string">"busuanzi_value_page_pv"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> views</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>页面每被点击一次, 总访问数就加一.</p><h3 id="全站字数统计"><a href="#全站字数统计" class="headerlink" title="全站字数统计"></a>全站字数统计</h3><p>使用<a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>. 类似不蒜子, 在<code>layout/_partial/footer.ejs</code>加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.wordcount.site) &#123; %&gt;</span><br><span class="line">  | <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">totalcount</span>(<span class="attr">site</span>) %&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> words</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>在YAML中开启</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wordcount:</span></span><br><span class="line"><span class="attr">  site:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="修改页尾标记"><a href="#修改页尾标记" class="headerlink" title="修改页尾标记"></a>修改页尾标记</h3><p>在<code>layout/_partial/footer.ejs</code>中修改.</p><h3 id="配色修改"><a href="#配色修改" class="headerlink" title="配色修改"></a>配色修改</h3><p>由于个人偏好蓝色和深绿色，需要简单修改一下博文大小标题和行间代码的配色。在<code>source/css/highlight.css</code>中修改行间代码的CSS样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d6d6d6</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">90%</span>;</span><br><span class="line">    <span class="comment">/*text-shadow: 0 1px #fff; */</span> <span class="comment">/*删去白色阴影*/</span></span><br><span class="line">    <span class="attribute">word-break</span>: break-all;</span><br><span class="line">    <span class="attribute">word-wrap</span>: break-word;</span><br><span class="line">    <span class="attribute">white-space</span>: normal;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#458B00</span>; <span class="comment">/* 翠绿 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>source/css/style.css</code>中修改文章中大小标题的样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h2</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0.83em</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#104E8B</span>; <span class="comment">/* 二级标题藏青 */</span></span><br><span class="line">  <span class="comment">/*  color: green; */</span></span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">  <span class="comment">/*  color: #9C4C17; */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#1E90FF</span>; <span class="comment">/* 三级标题湖蓝 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h4</span> &#123;</span><br><span class="line">  <span class="comment">/*  color: #B94A48; */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#CC0033</span>; <span class="comment">/* 四级标题红色以防标题层级过低看不到 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字两端对齐"><a href="#文字两端对齐" class="headerlink" title="文字两端对齐"></a>文字两端对齐</h3><p>在<code>source/css/style.css</code>中加入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: justify</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DISQUS评论"><a href="#DISQUS评论" class="headerlink" title="DISQUS评论"></a>DISQUS评论</h3><p>注册<a href="https://disqus.com/" target="_blank" rel="noopener">DISQUS</a>账号，选择”I want to install disqus on my site”，使用universal code安装，将这部分代码拷贝到<code>layout/_partial/post/comment.ejs</code>中。接下来配置Disqus，主要是<code>Website Name</code>和<code>Website URL</code>，前者我设置为我的shigaro。然后在Hexo根目录<code>_config.yml</code>下加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># comment</span></span><br><span class="line"><span class="attr">disqus_shortname:</span> <span class="string">shigaro</span></span><br></pre></td></tr></table></figure><h3 id="三线表"><a href="#三线表" class="headerlink" title="三线表"></a>三线表</h3><p>在<code>source/css/style.css</code>中加入</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 居中三线表 */</span></span><br><span class="line"><span class="selector-pseudo">:not(figure)</span>&gt;<span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">2px</span> solid <span class="number">#4088b8</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#4088b8</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1.5em</span> auto <span class="number">1.5em</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span> <span class="number">10px</span> <span class="number">12px</span> <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#4088b8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非代码块table元素, 悬停表格主体行时灰色高量 */</span></span><br><span class="line"><span class="selector-pseudo">:not(figure)</span>&gt;<span class="selector-tag">table</span>&gt;<span class="selector-tag">tbody</span>&gt;<span class="selector-tag">tr</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#D9D9D9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>在<code>layout/layout.ejs</code>中, 修改body标签, 增加一段ejs</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body &lt;%- partial('_partial/background') %&gt;&gt;</span><br></pre></td></tr></table></figure><p>新建<code>layout/_partial/background.ejs</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.background) &#123; %&gt;</span><br><span class="line">style="background:url(&lt;%- config.root %&gt;assets/images/&lt;%- theme.background %&gt;);" class="body-img-background"</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><code>body-img-background</code>类的样式由<code>source/css/style.css</code>控制</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fixed image background by minyez*/</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.body-img-background</span> &#123;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">-webkit-background-size</span>: cover;</span><br><span class="line">  <span class="attribute">-o-background-size</span>: cover;</span><br><span class="line">  <span class="attribute">-moz-background-size</span>: cover;</span><br><span class="line">  <span class="attribute">-ms-background-size</span>: cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>_config.yml</code>中加入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">background:</span> <span class="string">background.png</span></span><br></pre></td></tr></table></figure><p>再把想作为背景的图片background.png放到Hexo根目录<code>source/assets/images/</code>下面就可以了. 目前样式参考了<a href="https://vonsdite.cn/posts/c08e78b.html" target="_blank" rel="noopener">这条链接</a>.</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li style="list-style: none"><input type="checkbox" checked> Bugfix: 点击<code>Software</code>的category徽章后显示的文章不全. 启用根目录下<code>category_generator</code>并将<code>per_page</code>设为0即可解决.</li><li style="list-style: none"><input type="checkbox"> 代码块复制功能.</li><li style="list-style: none"><input type="checkbox"> Quotes页面, 存储一些摘句, 同时有一个即时搜索引擎.</li><li style="list-style: none"><input type="checkbox"> 文章中侧边栏随正文一同滚动. 对于TOC较长的情形, 鼠标移动到侧边栏上对TOC滚动浏览.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>笔者基于Hexo框架和Freemind主题搭建了个人博客，根据自己的需求进行了自定义，并利用MathJax渲染器和Bootstrap特性进行了Markdown写作。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://jdhao.github.io/2018/01/25/hexo-mathjax-equation-number/" target="_blank" rel="noopener">LaTeX Equation Numbering Done Right in Hexo</a><br>另一个渲染器hexo-math及一个讨论其用法的<a href="https://github.com/hexojs/hexo-math/issues/26">Issue</a><br>如何在自己的主题下实现MathJax支持：<a href="https://www.cnblogs.com/wangxin37/p/8185688.html" target="_blank" rel="noopener">在Hexo中渲染MathJax数学公式</a><br>代码块复制：<a href="https://www.ofind.cn/blog/HEXO/HEXO%E4%BC%98%E5%8C%96%E4%B9%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%B7%BB%E5%8A%A0%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD.html" target="_blank" rel="noopener">HEXO优化之（二）—-添加复制功能</a><br><a href="https://vonsdite.cn/posts/c08e78b.html" target="_blank" rel="noopener">Hexo 添加背景图片并自适应</a></p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-05-07"><a href="#2019-05-07" class="headerlink" title="2019-05-07"></a>2019-05-07</h3><ol><li>增加基于<code>hexo-reference</code>的wiki浮窗式的脚注.</li><li>MathJax: 比较各种情况下<code>*</code>和<code>_</code>的渲染结果. 更改CDN.</li></ol><h3 id="2019-05-10"><a href="#2019-05-10" class="headerlink" title="2019-05-10"></a>2019-05-10</h3><ol><li>增加对不蒜子统计的支持.</li><li>去掉了Archives不必要的下拉菜单, 直接进入<code>archives</code>页面.</li></ol><h3 id="2019-05-22"><a href="#2019-05-22" class="headerlink" title="2019-05-22"></a>2019-05-22</h3><ol><li>增加背景图片, 位置由YAML中<code>background</code>变量指定.</li></ol><h3 id="2019-05-25"><a href="#2019-05-25" class="headerlink" title="2019-05-25"></a>2019-05-25</h3><ol><li>利用<code>hexo-wordcount</code>进行全站和页面字数统计<br><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Startop=>operation: Your Operationcond=>condition: Yes or No?e=>endst->op->condcond(yes)->econd(no)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":3,"line-length":25,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">这是一个脚注测试<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div></li></ol>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Freemind </tag>
            
            <tag> Blogging </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解决macOS上编译VASP时遇到的libparser.a未定义符号问题</title>
      <link href="/2018/01/02/compile_VASP_on_macOS/"/>
      <url>/2018/01/02/compile_VASP_on_macOS/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文介绍了笔者在macOS High Sierra上编译VASP.5.4.4时解决libparser.a中undefined symbols的问题. <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>购买mac后，我希望能在macOS运行常用的科学计算程序，方便我做小规模测试，其中之一是<a href="https://www.vasp.at/" target="_blank" rel="noopener">VASP</a>。系统环境为macOS High Sierra 10.13，编译VASP时编译环境为</p><ul><li>Intel Parallel Composer XE 2018.0.1</li><li>Intel ifort和icc编译的MPICH3</li><li>Intel ifort和icc编译的FFTW3 (MPICH3并行)</li><li>Intel ifort和icc编译的ScaLAPACK和BLACS (MPICH3并行)</li></ul><p>我的目标是编译5.4.1和VASP.5.4.4两个版本并成功用于Silicon的算例. VASP.5.4.1的编译很容易就通过了并能够正常地跑Silicon的例子, 但VASP.5.4.4始终无法编译通过，主要问题是在用C++编译parser库时无法链接到部分symbol上。</p><h2 id="问题细节"><a href="#问题细节" class="headerlink" title="问题细节"></a>问题细节</h2><p>VASP编译过程用到的<code>makefile.include</code>文件如下所示。5.4.4版同5.4.1版include文件的主要区别，除了最后的GPU部分外，还有一个用C++编译<code>libparser.a</code>的选项，即<code>CXX_PARS</code>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Precompiler options</span></span><br><span class="line">CPP_OPTIONS= -DHOST=\<span class="string">"LinuxIFC\"\</span></span><br><span class="line"><span class="string">             -DMPI -DMPI_BLOCK=8000 \</span></span><br><span class="line"><span class="string">             -Duse_collective \</span></span><br><span class="line"><span class="string">             -DscaLAPACK \</span></span><br><span class="line"><span class="string">             -DCACHE_SIZE=4000 \</span></span><br><span class="line"><span class="string">             -Davoidalloc \</span></span><br><span class="line"><span class="string">             -Duse_bse_te \</span></span><br><span class="line"><span class="string">             -Dtbdyn \</span></span><br><span class="line"><span class="string">             -Duse_shmem</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CPP        = fpp -f_com=no -free -w0  <span class="variable">$*</span><span class="variable">$(FUFFIX)</span> <span class="variable">$*</span><span class="variable">$(SUFFIX)</span> <span class="variable">$(CPP_OPTIONS)</span></span></span><br><span class="line"><span class="string">FC         = mpifort</span></span><br><span class="line"><span class="string">FCL        = mpifort #-mkl=sequential -lstdc++</span></span><br><span class="line"><span class="string">FREE       = -free -names lowercase</span></span><br><span class="line"><span class="string">FFLAGS     = -assume byterecl -w</span></span><br><span class="line"><span class="string">OFLAG      = -O2</span></span><br><span class="line"><span class="string">OFLAG_IN   = <span class="variable">$(OFLAG)</span></span></span><br><span class="line"><span class="string">DEBUG      = -O0</span></span><br><span class="line"><span class="string">MKL_PATH   = <span class="variable">$(MKLROOT)</span>/lib/</span></span><br><span class="line"><span class="string">BLAS       =</span></span><br><span class="line"><span class="string">LAPACK     = <span class="variable">$(MKLROOT)</span>/lib/libmkl_intel_lp64.a <span class="variable">$(MKLROOT)</span>/lib/libmkl_sequential.a <span class="variable">$(MKLROOT)</span>/lib/libmkl_core.a -lpthread -lm -ldl</span></span><br><span class="line"><span class="string">BLACS      =</span></span><br><span class="line"><span class="string">SCALAPACK  = /Users/stevezhang/software/mathlib/scalapack/2.0.2/intel/18.0.1/libscalapack.a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OBJECTS    = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o <span class="variable">$(HOME)</span>/lib/libfftw3xf_intel.a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">INCS       = -m64 -I<span class="variable">$(MKLROOT)</span>/include/fftw -I<span class="variable">$(MKLROOT)</span>/include/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LLIBS      = <span class="variable">$(SCALAPACK)</span> <span class="variable">$(LAPACK)</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OBJECTS_O1 += fftw3d.o fftmpi.o fftmpiw.o</span></span><br><span class="line"><span class="string">OBJECTS_O2 += fft3dlib.o</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># For what used to be vasp.5.lib</span></span><br><span class="line"><span class="string">CPP_LIB    = <span class="variable">$(CPP)</span></span></span><br><span class="line"><span class="string">FC_LIB     = <span class="variable">$(FC)</span></span></span><br><span class="line"><span class="string">CC_LIB     = icc</span></span><br><span class="line"><span class="string">CFLAGS_LIB = -O</span></span><br><span class="line"><span class="string">FFLAGS_LIB = -O1</span></span><br><span class="line"><span class="string">FREE_LIB   = <span class="variable">$(FREE)</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OBJECTS_LIB= linpack_double.o getshmem.o</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># For the parser library</span></span><br><span class="line"><span class="string">CXX_PARS   = icpc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LIBS       += parser</span></span><br><span class="line"><span class="string">LLIBS      += -Lparser -lparser -lstdc++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Normally no need to change this</span></span><br><span class="line"><span class="string">SRCDIR     = ../../src</span></span><br><span class="line"><span class="string">BINDIR     = ../../bin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### GPU stuff below</span></span><br></pre></td></tr></table></figure><p>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make std</span><br></pre></td></tr></table></figure><p>在最后链接产生<code>vasp</code>前报错, 提示libparser.a中大量Undefined symbols,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> architecture x86_64:</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ld: symbol(s) not found <span class="keyword">for</span> architecture x86_64</span><br><span class="line">make[2]: *** [vasp] Error 1</span><br><span class="line">cp: vasp: No such file or directory</span><br><span class="line">make[1]: *** [all] Error 1</span><br><span class="line">make: *** [std] Error 2</span><br></pre></td></tr></table></figure><p><code>Undefined symbols for architecture x86_64</code>表示在x86_64架构下符号未被定义, 具体错误信息在<a href="libparser_undefined_sym.error">这里</a>, 总结起来未定义的符号包括</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__ZNKSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7compareEmmPKcm</span><br><span class="line">__ZNKSt3__120__vector_base_commonILb1EE20__throw_length_errorEv</span><br><span class="line">__ZNKSt3__16locale9use_facetERNS0_2idE</span><br><span class="line">__ZNKSt3__18ios_base6getlocEv</span><br><span class="line">__ZNSt11logic_errorC2EPKc</span><br><span class="line">__ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm</span><br><span class="line">__ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEmc</span><br><span class="line">__ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6appendEPKcm</span><br><span class="line">__ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc</span><br><span class="line">__ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED1Ev</span><br><span class="line">__ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE3putEc</span><br><span class="line">__ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE5flushEv</span><br><span class="line">__ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE6sentryC1ERS3_</span><br><span class="line">__ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEE6sentryD1Ev</span><br><span class="line">__ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEd</span><br><span class="line">__ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEf</span><br><span class="line">__ZNSt3__113basic_ostreamIcNS_11char_traitsIcEEElsEi</span><br><span class="line">__ZNSt3__14coutE</span><br><span class="line">__ZNSt3__15ctypeIcE2idE</span><br><span class="line">__ZNSt3__16localeD1Ev</span><br><span class="line">__ZNSt3__18ios_base33__set_badbit_and_consider_rethrowEv</span><br><span class="line">__ZNSt3__18ios_base5clearEj</span><br></pre></td></tr></table></figure><h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><p>首先在<code>makefile.include</code>里面的<code>CXX_PARS</code>后面加上Homebrew安装的GCC库和<code>-lstdc++</code>，即</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-L/usr/<span class="built_in">local</span>/Cellar/gcc/7.2.0/lib/gcc/7 -lstdc++</span><br></pre></td></tr></table></figure><p>这样子可以正常编译通过。但是跑VASP时会出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> running on    1 total cores</span><br><span class="line"> distrk:  each k-point on    1 cores,    1 groups</span><br><span class="line"> distr:  one band on    1 cores,    1 groups</span><br><span class="line"> using from now: INCAR</span><br><span class="line"> vasp.5.4.4.18Apr17-6-g9f103f2a35 (build Jan 09 2018 16:27:40) complex</span><br><span class="line"></span><br><span class="line"> POSCAR found <span class="built_in">type</span> information on POSCAR  Si</span><br><span class="line"> POSCAR found :  1 types and       2 ions</span><br><span class="line"> scaLAPACK will be used</span><br><span class="line">dyld: lazy symbol binding failed: Symbol not found: __ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev</span><br><span class="line">  Referenced from: /Users/stevezhang/software/sci/vasp/vasp.5.4.4-intel-2018.0.1/common/build/std/vasp</span><br><span class="line">  Expected <span class="keyword">in</span>: flat namespace</span><br><span class="line"></span><br><span class="line">dyld: Symbol not found: __ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev</span><br><span class="line">  Referenced from: /Users/stevezhang/software/sci/vasp/vasp.5.4.4-intel-2018.0.1/common/build/std/vasp</span><br><span class="line">  Expected <span class="keyword">in</span>: flat namespace</span><br><span class="line"></span><br><span class="line">forrtl: error (76): Abort <span class="built_in">trap</span> signal</span><br><span class="line">Image              PC                Routine            Line        Source</span><br><span class="line">vasp               0000000103C7ABFA  for__signal_handl     Unknown  Unknown</span><br><span class="line">libsystem_platfor  00007FFF6C6DEF5A  _sigtramp             Unknown  Unknown</span><br><span class="line">fish: <span class="string">'vasp'</span> terminated by signal SIGABRT (Abort)</span><br></pre></td></tr></table></figure><p>主要错误是<code>dyld</code>没有找到symbol。用<code>nm</code>命令检查<code>libstdc++.a</code>和<code>libstdc++.dylib</code>，可以看到<code>__ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev</code>都是有定义的，但始终链接不上去。考虑<code>dyld</code>的搜索路径<code>DYLD_LD_LIBRARY</code>。将<code>/usr/local/Cellar/gcc/7.2.0/lib/gcc/7</code>添加到环境变量<code>DYLD_LD_LIBRARY</code>中后重新编译<code>libparser.a</code>，再编译<code>vasp</code>就能成功运行。</p><p>最后5.4.4编译成功时的环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$DYLD_LIBRARY_PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/gcc/7.2.0/lib/gcc/7:/usr/<span class="built_in">local</span>/Cellar/gcc/7.2.0/lib/gcc/7/gcc/x86_64-apple-darwin17.0.0/7.2.0/:/Users/stevezhang/software/compiler/mpich/3.2.1/intel/18.0.1/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/compiler/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/compiler/lib/intel64:/opt/intel/compilers_and_libraries_2018.1.126/mac/ipp/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/compiler/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/mkl/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/tbb/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/tbb/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/daal/lib:/opt/intel/compilers_and_libraries_2018.1.126/mac/daal/../tbb/lib:/usr/<span class="built_in">local</span>/opt/tcl-tk/lib:/usr/<span class="built_in">local</span>/lib:/usr/lib:</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$LIBRARY_PATH</span></span><br><span class="line">... <span class="comment"># 和DYLD一样</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/gcc/7.2.0/lib/gcc/7:/usr/<span class="built_in">local</span>/Cellar/gcc/7.2.0/lib/gcc/7/gcc/x86_64-apple-darwin17.0.0/7.2.0/:/Users/stevezhang/software/mathlib/scalapack/2.0.2/intel/18.0.1/:/Users/stevezhang/software/mathlib/fftw/3.3.7/intel/18.0.1/lib:/Users/stevezhang/software/compiler/mpich/3.2.1/intel/18.0.1/lib:/usr/<span class="built_in">local</span>/opt/tcl-tk/lib:/usr/<span class="built_in">local</span>/lib:/usr/lib:</span><br></pre></td></tr></table></figure><p>注意到<code>LD_LIBRARY_PATH</code>和<code>LIBRARY_PATH</code>之间的差别, 由于MKLROOT之类的环境变量是通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> compilervars.sh intel64</span><br></pre></td></tr></table></figure><p>来添加的，可见<code>compilervars.sh</code>并没有编辑<code>LD_LIBRARY_PATH</code>这一变量。</p><p>最终可用的include文件如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Precompiler options</span></span><br><span class="line">CPP_OPTIONS= -DHOST=\<span class="string">"LinuxIFC\"\</span></span><br><span class="line"><span class="string">             -DMPI -DMPI_BLOCK=8000 \</span></span><br><span class="line"><span class="string">             -Duse_collective \</span></span><br><span class="line"><span class="string">             -DscaLAPACK \</span></span><br><span class="line"><span class="string">             -DCACHE_SIZE=4000 \</span></span><br><span class="line"><span class="string">             -Davoidalloc \</span></span><br><span class="line"><span class="string">             -Duse_bse_te \</span></span><br><span class="line"><span class="string">             -Dtbdyn \</span></span><br><span class="line"><span class="string">             -Duse_shmem</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CPP        = fpp -f_com=no -free -w0  <span class="variable">$*</span><span class="variable">$(FUFFIX)</span> <span class="variable">$*</span><span class="variable">$(SUFFIX)</span> <span class="variable">$(CPP_OPTIONS)</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FC         = mpifort</span></span><br><span class="line"><span class="string">FCL        = mpifort -mkl=sequential -lstdc++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FREE       = -free -names lowercase</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FFLAGS     = -assume byterecl -w</span></span><br><span class="line"><span class="string">OFLAG      = -O2</span></span><br><span class="line"><span class="string">OFLAG_IN   = <span class="variable">$(OFLAG)</span></span></span><br><span class="line"><span class="string">DEBUG      = -O0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MKL_PATH   = <span class="variable">$(MKLROOT)</span>/lib/</span></span><br><span class="line"><span class="string">BLAS       =</span></span><br><span class="line"><span class="string">LAPACK     = <span class="variable">$(MKLROOT)</span>/lib/libmkl_intel_lp64.a <span class="variable">$(MKLROOT)</span>/lib/libmkl_sequential.a <span class="variable">$(MKLROOT)</span>/lib/libmkl_core.a -lpthread -lm -ldl</span></span><br><span class="line"><span class="string">BLACS      =</span></span><br><span class="line"><span class="string">SCALAPACK  = /Users/stevezhang/software/mathlib/scalapack/2.0.2/intel/18.0.1/libscalapack.a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OBJECTS    = fftmpiw.o fftmpi_map.o fft3dlib.o fftw3d.o <span class="variable">$(HOME)</span>/lib/libfftw3xf_intel.a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">INCS       = -m64 -I<span class="variable">$(MKLROOT)</span>/include/fftw -I<span class="variable">$(MKLROOT)</span>/include/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LLIBS      = -L/usr/local/lib/gcc/7/ <span class="variable">$(SCALAPACK)</span> <span class="variable">$(LAPACK)</span>  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OBJECTS_O1 += fftw3d.o fftmpi.o fftmpiw.o</span></span><br><span class="line"><span class="string">OBJECTS_O2 += fft3dlib.o</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># For what used to be vasp.5.lib</span></span><br><span class="line"><span class="string">CPP_LIB    = <span class="variable">$(CPP)</span></span></span><br><span class="line"><span class="string">FC_LIB     = <span class="variable">$(FC)</span></span></span><br><span class="line"><span class="string">CC_LIB     = icc</span></span><br><span class="line"><span class="string">CFLAGS_LIB = -O</span></span><br><span class="line"><span class="string">FFLAGS_LIB = -O1</span></span><br><span class="line"><span class="string">FREE_LIB   = <span class="variable">$(FREE)</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">OBJECTS_LIB= linpack_double.o getshmem.o</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># For the parser library</span></span><br><span class="line"><span class="string">#CXX_PARS   = c++ #/usr/local/lib/gcc/7/libstdc++.a</span></span><br><span class="line"><span class="string">#CXX_PARS = clang++ -++ -std=gnu++11</span></span><br><span class="line"><span class="string">CXX_PARS = icpc -lstdc++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LIBS       += parser</span></span><br><span class="line"><span class="string">LLIBS      += -Lparser  -lparser -L/usr/local/lib/gcc/7/ -lstdc++</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Normally no need to change this</span></span><br><span class="line"><span class="string">SRCDIR     = ../../src</span></span><br><span class="line"><span class="string">BINDIR     = ../../bin</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#================================================</span></span><br><span class="line"><span class="string"># GPU Stuff</span></span><br><span class="line"><span class="string">#... # skipped for clarity</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>macOS的操作系统是Darwin。</p><blockquote><p>Darwin是由苹果电脑于2000年所释出的一个开放原始码操作系统。Darwin 是MacOSX 操作环境的操作系统成份。苹果电脑于2000年把Darwin 释出给开放原始码社群。现在的Darwin皆可以在苹果电脑的PowerPC 架构和X86 架构下执行，而后者的架构只有有限的驱动程序支援。</p></blockquote><p>在Darwin内存储函数库搜索路径的不是像Fedora和Ubuntu的<code>LD_LIBRARY_PATH</code>，而是<code>LIBRARY_PATH</code>和<code>DYLD_LIBRARY_PATH</code>。前者是<code>ld</code>的搜索路径，后者是动态链接指令<code>dyld</code>的搜索路径。需要使用<code>.la</code>和<code>.dylib</code>动态库时，需要将库路径加入<code>DYLD_LIBRARY_PATH</code>内。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>编译成功后，我在几乎所有的modulefile中增加了<code>prepend-path DYLD_LIBRARY_PATH</code>行，在module load它们时出现警告</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyld: warning, unknown environment variable: DYLD_LIBRARY_PATH_modshare</span><br></pre></td></tr></table></figure><p>这个错误在跑vasp的时候也会产生。出现原因是<code>dyld</code>和Tcl版的<code>module</code>之间不兼容。更新到最新版本的Environment module可以解决这个问题.</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2019-05-02"><a href="#2019-05-02" class="headerlink" title="2019-05-02"></a>2019-05-02</h3><p>Environment module 4.2.1已经修正了<code>DYLD_LIBRARY_PATH</code>的问题</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://baike.baidu.com/item/Darwin/2537108?fr=aladdin" target="_blank" rel="noopener">Darwin 百度百科</a></p><p><a href="http://d.hatena.ne.jp/kimuraw/20150919/p1" target="_blank" rel="noopener">http://d.hatena.ne.jp/kimuraw/20150919/p1</a></p><p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/dyld.1.html" target="_blank" rel="noopener">man dyld</a></p>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VASP </tag>
            
            <tag> Compilation </tag>
            
            <tag> macOS </tag>
            
            <tag> Intel </tag>
            
            <tag> Bugfix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPS与SSR配置科学上网</title>
      <link href="/2017/12/22/VPS_and_SSR/"/>
      <url>/2017/12/22/VPS_and_SSR/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文简单介绍了使用Shadowsocks翻越GFW实现对包括Google、Youtube、Twitter在内的国外网站的访问，叙述了基于Vultr公司服务器的SSR服务端部署和macOS/Windows客户端使用方法。 <a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>谷歌搜索对于学术研究的重要性无须赘述，Youtube上原创的优秀的讲座、课程录像和视频教程对于自学者来说也是非常好的资源。Facebook和Twitter也能帮助我们取得与外国同学的联系。但对于非IPv6用户而言，由于GFW的存在，直接连接这些网站的尝试最后都是徒劳。目前的解决方案包括hosts文件、VPN以及Shadowsocks。hosts文件指定域名解析IP，避免DNS污染，但通常隔一段时间需要更换，且周期不定。VPN通常价格较高，且同时使用的终端数量一般是受限的。Shadowsocks本身只是一个协议，它需要境外服务器支持，但使用VPS作为服务器，可以在较低价格情况下(￥15/月)同时保证10台左右终端的正常流量需求，且只要VPS的IP不被屏蔽，可以一直使用下去，不必更换。VPN越来越贵，hosts不灵的频率越来越高，于是以最近一次hosts失效为契机，我研究了一下SS的架设，自己配置了SS服务器和客户端。</p><div class="alert alert-info"><i class="fa fa-info  float-left"></i>  <p>最近在BBS上看到别人推荐<a href="https://github.com/v2ray/v2ray-core">V2Ray项目</a>。</p></div><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="Virtual-Private-Server-VPS"><a href="#Virtual-Private-Server-VPS" class="headerlink" title="Virtual Private Server (VPS)"></a>Virtual Private Server (VPS)</h3><p>虚拟专有服务器, 是”将一台服务器分区成多个虚拟专享服务器的服务”(<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">中文维基</a>)，通常是由专门的VPS供应商提供。它的核心是基于虚拟机技术，将单个物理服务器的硬盘、网络、CPU计算、内存等资源进行隔离，模拟出多个独立服务器的使用体验。不同VPS在软件上相互独立，都可以独立地安装操作系统、启动与重启，用户在其上拥有超级用户权限，可进行自由配置和软件安装。缺点是，由于多个VPS用户在同一个物理服务器上，硬件资源会相互影响，特别是当供应商超卖导致超负荷时。专有服务器(Dedicated server)不存在这种情形，但也因为单个用户独占物理服务器，价格要比VPS高很多。</p><h3 id="Shadowsocks-SS"><a href="#Shadowsocks-SS" class="headerlink" title="Shadowsocks (SS)"></a>Shadowsocks (SS)</h3><p>由<a href="https://github.com/clowwindy">clowwindy</a>首先开发的一个开源的加密代理项目，主要用于绕过GFW对国内网络请求的检测。其原理如图所示(<a href="https://ieeexplore.ieee.org/document/8048116/" target="_blank" rel="noopener">来源</a>)。在服务器端设置好密码、端口、协议、加密方式等等，客户端以相同的设置连接服务端。成功连接后，客户端与服务端之间建立sock5连接。在一次网络通信时，首先由本地客户端发送请求，与SS客户端通信。然后，SS客户端将请求加密，数据包以普通TCP包的外观发送到SS服务端。随后，SS服务端将数据包解密，将请求传递给墙外的网络服务器，最后再将网站响应数据返回给SS客户端。<br><figure class="null"><img src="ss-comm-principle.gif" alt="Shadowsocks原理"><figcaption>Shadowsocks原理</figcaption></figure><br>由于历史原因，我们还需要决定用什么版本的SS。笔者在这里使用的是<a href="https://github.com/shadowsocksrr/shadowsocksr.git">ShadowsocksR</a>，它相比原版SS具有更多功能。尽管经历了<a href="https://t.du9l.com/2015/08/qi-wen-gong-shang/" target="_blank" rel="noopener">疑似违反GPL的事件</a>，但目前SSR源码已经公开且开发人员主要由新贡献者构成，它也是当前SS的主要项目分支(<a href="https://zh.wikipedia.org/wiki/Shadowsocks#ShadowsocksR" target="_blank" rel="noopener">中文维基20180702</a>)。</p><h3 id="Proxy-Auto-Config-PAC"><a href="#Proxy-Auto-Config-PAC" class="headerlink" title="Proxy Auto-Config (PAC)"></a>Proxy Auto-Config (PAC)</h3><p>代理自动配置。PAC定义了”如何自动选择适当的代理服务器来访问一个网址(<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">中文维基</a>)”。使用PAC需要一个PAC文件，其中必须包含名为<code>FindProxyForURL</code>的javascript函数。一个简单的例子是(来自中文维基)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"PROXY proxy.example.com:8080; DIRECT"</span></span><br><span class="line">    <span class="comment">//通过服务器proxy.example.com的8080端口来获取页面</span></span><br><span class="line">    <span class="comment">//如果服务器没有响应，则通过www直接访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dynamics-Domain-Name-System-DDNS"><a href="#Dynamics-Domain-Name-System-DDNS" class="headerlink" title="Dynamics Domain Name System (DDNS)"></a>Dynamics Domain Name System (DDNS)</h3><h2 id="Step-by-step-基于Vultr-VPS的SSR"><a href="#Step-by-step-基于Vultr-VPS的SSR" class="headerlink" title="Step by step: 基于Vultr VPS的SSR"></a>Step by step: 基于Vultr VPS的SSR</h2><p>基于SS原理我们可以知道，为了使用SSR，我们需要部署SSR客户端和服务端，而服务端需要部署在境外服务器上。那么需要做什么事情就很清楚了</p><ul><li><p>购买境外VPS</p></li><li><p>在VPS上部署SS服务端</p></li><li><p>在本地部署SS客户端</p></li></ul><p>接下来我们一条条看。</p><h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><p>境外服务器选择<a href="www.vultr.com">Vultr</a>公司。访问主页(如下图)，注册账号后登录到个人页面管理。<br><figure class="null"><img src="vultr-homepage.png" alt="Vultr首页"><figcaption>Vultr首页</figcaption></figure><br>个人页面如下所示，点击右上角加号部署新服务器<br><figure class="null"><img src="vultr-mypage.png" alt="Vultr个人页面"><figcaption>Vultr个人页面</figcaption></figure><br>在新服务器的配置中，需要选择以下项目</p><h4 id="Server-Location"><a href="#Server-Location" class="headerlink" title="Server Location"></a>Server Location</h4><p>服务器位置。根据自己的网络情况选择最佳的服务器，一般判断标准是PING延迟，以及是否有较便宜的规模可供选择</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ping hnd-jp-ping.vultr.com    # Tokyo</span><br><span class="line">ping sgp-ping.vult.com        # Singapore</span><br><span class="line">ping sjo-ca-us-ping.vultr.com # Silicon Valley, CA</span><br><span class="line">ping lax-ca-us-ping.vultr.com # Los Angeles, CA</span><br><span class="line">ping fra-de-ping.vultr.com    # Frankfurt</span><br><span class="line">ping nj-us-ping.vultr.com     # NY, New Jersey</span><br><span class="line">ping il-us-ping.vultr.com     # Chicago, Illinois</span><br><span class="line">ping fl-us-ping.vultr.com     # Miami, Florida</span><br><span class="line">ping syd-au-ping.vultr.com    # Sydney, Australia</span><br><span class="line">ping lon-gb-ping.vultr.com    # London, UK</span><br></pre></td></tr></table></figure><h4 id="Server-Type"><a href="#Server-Type" class="headerlink" title="Server Type"></a>Server Type</h4><p>操作系统。推荐选择比较稳定的Linux发行版，如CentOS, Ubuntu LTS等。推荐CentOS。</p><h4 id="Server-Size"><a href="#Server-Size" class="headerlink" title="Server Size"></a>Server Size</h4><p>服务器资费方案。一般来说，最低\$2.5的500G带宽足够个人或者三五同学公用的需求。但近日(20180714)发现这个方案已经不再分配公网IPv4，所以改用\$3.5或\$5的方案。这个价格比某些廉价VPN要贵不少，所以推荐多人分摊公用，这样既不浪费带宽，也能省些钱。</p><h4 id="Additional-Features"><a href="#Additional-Features" class="headerlink" title="Additional Features"></a>Additional Features</h4><p>额外特性。建议启用IPv6和DDoS保护(部分地区服务器支持)。2018年9月后Vultr DDoS防护价格飙升, 显然是不会勾的.</p><h4 id="SSH公钥授权"><a href="#SSH公钥授权" class="headerlink" title="SSH公钥授权"></a>SSH公钥授权</h4><p>选择部署时添加的SSH公钥. 有公钥后登录VPS就不需要输入繁杂的密码了. 更重要的是, 可以将<code>/etc/ssh/sshd_config</code>(CentOS)中的<code>PasswordAuthentication</code>关闭以禁止密码登陆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure><p>这样就可以防止别人对你进行密码爆破. 关于如何生成公钥, 网上有很多教程, 这里就不多说了.</p><h4 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h4><p>选择好后点击deploy完成部署，等待自动安装。完成后点击主页上刚刚部署的服务器右侧的三个小点，选择Server Details，记下IP Address和Password。Vultr网站上的准备到这里就完成了。</p><h3 id="部署服务端"><a href="#部署服务端" class="headerlink" title="部署服务端"></a>部署服务端</h3><p>在终端上用<code>ssh</code>登录刚刚部署的服务器(CentOS)，用户为root(根用户)。首次登录最好先进行更新,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@vultrip  # with Password</span><br><span class="line">yum update        # for first login</span><br></pre></td></tr></table></figure><p>其中<code>vultrip</code>是你的Vultr服务器IP. 登录后部署服务端, 可以使用秋水逸冰的<a href="https://teddysun.com/486.html" target="_blank" rel="noopener">一键安装脚本</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br></pre></td></tr></table></figure><p>加上执行权限后运行之</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure><p>过程中需要依次对以下内容进行设置</p><ul><li>SS版本。选择SSR (2)。</li><li>密码。</li><li>端口(port)。初始端口随机生成。</li><li>加密方法(encryption)。</li><li>协议(protocol)。</li><li>混淆(obf)。</li></ul><p>记下以上设置，回车安装。上述设置也可以在<code>shadowsocks-all.log</code>中查询。接下来就可以退出服务器，回到本地设置客户端。</p><h3 id="部署客户端"><a href="#部署客户端" class="headerlink" title="部署客户端"></a>部署客户端</h3><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><p>推荐使用<a href="https://github.com/shadowsocks/ShadowsocksX-NG">ShadowsocksX-NG</a>作为客户端。在GitHub上下载最新版本(Release标签内)，解压缩、安装。启用后单击右上角标记，按照上一步中的服务端部署方式，编辑服务器设置。<br><figure class="null"><img src="ssr-client.png" alt="ShadowsocksX-NG服务器设置"><figcaption>ShadowsocksX-NG服务器设置</figcaption></figure><br>编辑完后点击”打开Shadowsocks”，即可使用。</p><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>推荐使用<a href="https://github.com/shadowsocks/shadowsocks-windows">Shadowsocks-windows</a>。下载解压后运行，双击任务栏中SS图标，弹出服务器配置窗口。具体配置方法与macOS类似。</p><h4 id="PAC分流"><a href="#PAC分流" class="headerlink" title="PAC分流"></a>PAC分流</h4><p>以上客户端均允许对访问请求进行分流，即仅对必须绕过GFW才能访问的地址使用sock5协议，这对应于PAC模式。一般通过<a href="https://github.com/gfwlist/gfwlist">GFW List</a>设置PAC地址列表。用户也可以进行自定义: 对于ShadowsocksX-NG，可以在”代理设置-编辑PAC用户自定义规则”中设置。对于Shadowsocks-windows，”PAC-编辑本地PAC文件”，手动编辑<code>pac.txt</code>中的<code>domains</code>变量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾从VPN、hosts到SS的过程，其实是自己能力和心态逐渐变化的过程。一开始什么也不懂，依靠别人的VPN过活; 后来看到了免费的hosts，自己也愿意稍微折腾一下，但渐渐也受不了每个hosts文件的短暂寿命和找hosts的痛苦，最后走上了折腾钱折腾时间但是一定程度上”一劳永逸”的SS(感谢开源项目开发者们和脚本作者)。也许之后还会继续折腾到V2Ray吧。谨把这Vultr VPS+SSR搭建过程献给与GFW战斗的勇者们。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li style="list-style: none"><input type="checkbox"> 2018-10-15 增加DDNS部分</li><li style="list-style: none"><input type="checkbox" checked> 2019-05-22 增加SSH公钥授权</li></ul>]]></content>
      
      <categories>
          
          <category> Software </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ShadowsocksR </tag>
            
            <tag> VPS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GNU/Make笔记(一)——编写Makefile</title>
      <link href="/2017/10/12/make-1/"/>
      <url>/2017/10/12/make-1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="/css/hint.min.css"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从编译一个简单的质数判断程序入手, 介绍了如何利用GNU/Make方便地编译较复杂的程序项目。<a id="more"></a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>如果我们希望用C语言实现判断一个从外部输入的正整数<code>a</code>是否是质数的程序(要求<code>a</code>小于一预设值<code>intmax</code>)，那么我们需要在程序中实现以下功能：</p><ul><li><p>读取外部输入<code>a</code>，并判断<code>a</code>是否为整数且小于<code>intmax</code>；</p></li><li><p>求不大于<code>a</code>的平方根的正整数<code>b</code>；</p></li><li><p>判断是否存在小于等于<code>b</code>且不等于1的整数<code>c</code>能整除<code>a</code>。若存在，则<code>a</code>为合数，否则为质数。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>上述功能由三个函数实现，分别保存在三个.c文件中，由main.c中<code>main()</code>统一调用。各函数功能见表格，具体代码见最后一节附录。通过编译.c产生.o文件，然后将所有.o链接起来，产生可执行程序<code>prime</code>。注意到这里需要<code>math.h</code>中的函数<code>sqrt</code>，因此需要用<code>-lm</code>链接数学库。</p><table><thead><tr><th>文件名</th><th>函数名</th><th>形参</th><th>功能</th><th>返回值</th></tr></thead><tbody><tr><td>main.c</td><td><code>main</code></td><td></td><td>流程控制</td><td></td></tr><tr><td>read_a.c</td><td><code>read_a</code></td><td></td><td>从外部读取<code>a</code></td><td><code>a</code>; -1</td></tr><tr><td>isqrt.c</td><td><code>isqrt</code></td><td><code>a</code></td><td>求不大于$\sqrt{\texttt{a}}$的整数<code>b</code></td><td></td></tr><tr><td>judge_p.c</td><td><code>judge_p</code></td><td><code>a,b</code></td><td>循环判断<code>a</code>是否质数</td><td></td></tr><tr><td>prime.h</td><td></td><td></td><td>头文件, 声明函数</td></tr></tbody></table><h2 id="GNU-Make基本"><a href="#GNU-Make基本" class="headerlink" title="GNU/Make基本"></a>GNU/Make基本</h2><h3 id="什么是make"><a href="#什么是make" class="headerlink" title="什么是make"></a>什么是<code>make</code></h3><p>比较大的工程通常包含很多源文件，需要逐个编译并链接才能得到目标执行程序。手动编译和链接不仅操作麻烦，每次链接时还要重新输入所有目标文件以及需要的函数库，浪费时间精力。<code>make</code>是一种帮助我们自动编译与构建大型工程的工具。通过将<strong>规则（rule）</strong>写入Makefile文件，<code>make</code>就会根据规则中的依赖关系逐层编译目标文件，最后链接得到执行程序。<code>make</code>在Linux上的标准实现是GNU/Make，以下所有<code>make</code>指令均为GNU make。</p><p>事实上，除了编译程序外，<code>make</code>也可以帮助我们完成其他的工作，具体内容由规则决定。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p><code>make</code>需要Makefile来告诉它以什么样的顺序去编译和链接程序。Makefile中最核心的概念是规则，一个Makefile里可以包含多个规则。规则一般写成如下形式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[目标文件]: [前提文件]</span></span><br><span class="line">    [命令 1]</span><br><span class="line">    ...</span><br><span class="line">    [命令 n]</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><strong>目标文件（Target）</strong>可以是一个.o文件，或者可执行程序，也可以仅仅是一个标签（比如clean目标是清除所以已编译的.o文件和可执行程序）。</li><li><p><strong>前提文件（Prerequisites）</strong>是完成该目标所需要的文件或者目标。目标文件和前提文件之间用冒号分开。命令（Command）为该目标下执行的Shell命令，<strong>必须</strong>用Tab对命令缩进。这一系列命令统一称为规则的recipe。如果你不喜欢用Tab缩进，那么需要修改<code>.RECIPEPREFIX</code>换成你想要的符号。比如</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.RECIPEPREFIX := :</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">:@echo <span class="string">"Recipe prefix symbol set to $(.RECIPEREFIX)"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="make运行机制"><a href="#make运行机制" class="headerlink" title="make运行机制"></a><code>make</code>运行机制</h3><p>在命令行输入<code>make</code>后,一般会按次序发生以下事件：</p><ol><li><p><code>make</code>在当前文件夹下搜索Makefile和makefile（GNU make还会包括GNUmakefile）文件并读取。搜寻顺序是GNUmakefile、makefile、Makefile，先找到哪个文件读哪个；</p></li><li><p>找到Makefile后，读取Makefile中<code>include</code>包含的文件；</p></li><li><p>初始化变量值，展开所有需要立即展开的变量；</p></li><li><p>以第一个规则中的目标作为最终目标，根据最终目标以及依赖关系，建立依赖关系列表；</p></li><li><p>执行除最终目标以外的所有目标的规则：规则中前提文件不存在，或者前提文件比目标文件新，则执行规则下的命令重建目标；</p></li><li><p>执行最终目标所在规则。</p></li></ol><h2 id="Makefile具体写法"><a href="#Makefile具体写法" class="headerlink" title="Makefile具体写法"></a>Makefile具体写法</h2><p>接下来以构造可执行程序<code>prime</code>为例，讲解Makefile的写法和<code>make</code>的运行。</p><h3 id="最直接的Makefile"><a href="#最直接的Makefile" class="headerlink" title="最直接的Makefile"></a>最直接的Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">prime: read_a.o isqrt.o judge_p.o main.o</span></span><br><span class="line">    gcc -o prime read_a.o isqrt.o main.o judge_p.o -lm</span><br><span class="line"></span><br><span class="line"><span class="section">read_a.o: read_a.c</span></span><br><span class="line">    gcc -c read.c</span><br><span class="line"></span><br><span class="line"><span class="section">isqrt.o: isqrt.c</span></span><br><span class="line">    gcc -c isqrt.c</span><br><span class="line"></span><br><span class="line"><span class="section">judge_p.o: judge_p.c</span></span><br><span class="line">    gcc -c judge_p.c</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c</span></span><br><span class="line">    gcc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f prime read_a.o isqrt.o judge_p.o  main.o</span><br></pre></td></tr></table></figure><p>此时在命令行输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>即可编译所有.o文件和<code>prime</code>。基本流程是：</p><ol><li><p>确定最终目标”prime”，确认前提文件.o是否存在；</p></li><li><p>初始时.o文件均未编译，因此<code>make</code>搜寻以read.o为目标的规则。这一规则只依赖于read_a.c，而read_a.c存在，因而执行该规则内的指令<code>gcc -c read_a.c</code>, 编译得到<code>read_a.o</code>；</p></li><li><p>同上，编译<code>isqrt.o, judge_p.o</code>和<code>main.o</code>；</p></li><li><p><code>.o</code>全部编译完成后，回到<code>prime</code>目标执行链接的命令，产生可执行程序<code>prime</code>。</p></li></ol><p>注意，<code>make</code>只会执行第一个规则，如果把prime放到后面，那么<code>make</code>将只会编译<code>read_a.c</code>，此时需要输入</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make prime</span><br></pre></td></tr></table></figure><p>在<code>make</code>后加上<code>-d</code>选项，可以查看<code>make</code>运行的具体流程</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -d</span><br></pre></td></tr></table></figure><h3 id="改进Makefile"><a href="#改进Makefile" class="headerlink" title="改进Makefile"></a>改进Makefile</h3><h4 id="定义显式变量"><a href="#定义显式变量" class="headerlink" title="定义显式变量"></a>定义显式变量</h4><p>在Makefile中定义变量<code>objects</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = read_a.o isqrt.o judge_p.o main.o</span><br></pre></td></tr></table></figure><p>用<code>$()</code>展开<code>objects</code>可以得到所有目标。</p><h4 id="利用预定义隐式规则"><a href="#利用预定义隐式规则" class="headerlink" title="利用预定义隐式规则"></a>利用预定义隐式规则</h4><p><code>make</code>对一系列程序的编译预定义了隐式规则，例如C程序编译的隐式规则为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> -c main.c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span></span><br></pre></td></tr></table></figure><p>且自动包含<code>.c</code>文件为前提文件。其中<code>CC,CFLAGS</code>和<code>CPPFLAGS</code>是<code>make</code>针对C程序编译的内建变量，其他的还有<code>CXX,FC,FFLAGS,LDFLAGS</code>等等。因此Makefile可以进一步简化为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objects = read_a.o isqrt.o judge_p.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">prime: <span class="variable">$(objects)</span></span></span><br><span class="line">    gcc -o prime <span class="variable">$(objects)</span> -lm</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f prime <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><p>事实上在<code>main.o</code>中我们省去了<code>prime.h</code>，这是因为它被包含在<code>main.c</code>中，<code>make</code>会将其自动加入前提文件。从而显式规则只剩下以<code>prime</code>和<code>clean</code>为目标的规则。</p><p>这里用<code>.PHONY</code>声明<strong>伪规则（Phony rules）</strong>，里面包含<code>clean</code>，以避免执行<code>make</code>时以<code>clean</code>作为最终目标。在这里并不是必要的，因为第一个目标是<code>prime</code>。但当工程较大、规则较多较杂时，声明伪规则可以避免不必要的问题。</p><h4 id="修改内置变量"><a href="#修改内置变量" class="headerlink" title="修改内置变量"></a>修改内置变量</h4><p><code>CC,CFLAGS,CXX,FC,FFLAGS,LDFLAGS</code>等等是<code>make</code>中内置的变量，在隐式规则中使用。我们同样可以修改它们，配合%匹配来自定义程序编译的隐式规则。例如在<code>makefile.include</code>里面定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC = icc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">LDFLAGS = -lm</span><br></pre></td></tr></table></figure><p>此时.o文件的隐式规则中执行的命令实际就变成了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icc -c -o main.o main.c -Wall -g</span><br></pre></td></tr></table></figure><p>在目标<code>prime</code>的规则中，用<code>$(LDFLAGS)</code>变量来包含数学库，编译器<code>$CC</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">prime:</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o prime <span class="variable">$(objects)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure><h4 id="模式规则"><a href="#模式规则" class="headerlink" title="模式规则"></a>模式规则</h4><p>我们看到对于.o文件我们可以利用隐式规则来编译，但是当我们需要使用比较复杂的编译选项时，隐式规则就不适用了。此时可以利用%进行模式匹配来定义隐式规则，如<code>prime.h</code>在<code>include</code>文件夹内，需要用<code>-I</code>选项将该文件夹加入头文件搜索路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INC= -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INC)</span></span><br></pre></td></tr></table></figure><p>其中<code>%.o: %.c</code>等价于以<code>stem.c</code>为前提产生目标文件<code>stem.o</code>。这样的规则称为模式规则(Pattern<br>rule)。我们可以用这种方法自定义执行命令，使之符合我们的需求。</p><h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>上面的命令中用到的<code>$@</code>和<code>$&lt;</code>是<code>make</code>的一个特殊功能，称为自动变量（automatic variable）。<code>make</code>中常用的自动变量见下表</p><table><thead><tr><th>自动变量</th><th>含义</th></tr></thead><tbody><tr><td><code>$@</code></td><td>目标文件名</td></tr><tr><td><code>$&lt;</code></td><td>第一个前提文件的名字</td></tr><tr><td><code>$^</code></td><td>所有前提文件，以空格分隔</td></tr><tr><td><code>$?</code></td><td>所有比目标文件新的前提文件，以空格分隔</td></tr></tbody></table><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>包括一般的Shell通配符, 如<code>*,?,[],[!]</code>。例如<code>clean</code>目标中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f prime *.o</span><br></pre></td></tr></table></figure><p>此外更为常用的通配符是wildcard和patsubst函数. 使用wildcard函数扩展通配符以及patsubst函数替换通配符。patsubst需要３个参数，第一个是个需要匹配的式样，第二个表示用什么来替换它，第三个是个需要被处理的由空格分隔的字列。以下<code>objects</code>定义的方法与显式定义等价</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sources = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">objects = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(sources)</span>)</span></span><br></pre></td></tr></table></figure><p>第一个<code>%</code>匹配非空字符串，每次匹配的字符串叫做”柄”（stem），第二个<code>%</code>将被解读为第一参数所匹配的柄。该命令中，<code>patsubst</code>将<code>$(sources)</code>中的<code>.c</code>文件列表替换成对应的<code>.o</code>文件。这里的<code>%</code>不能用<code>*</code>来代替。</p><h3 id="include外部文件"><a href="#include外部文件" class="headerlink" title="include外部文件"></a>include外部文件</h3><p>创建<code>makefile.include</code>文件，在里面定义变量：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># makefile.include</span></span><br><span class="line">sources = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">objects = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(sources)</span>)</span></span><br><span class="line">CC      = icc</span><br><span class="line">CFLAGS  = -Wall -g</span><br><span class="line">LDFLAGS = -lm</span><br><span class="line">INC     = -I./<span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>在Makefile里加入<code>include</code>指令把makefile.include中的变量包含进来。此时Makefile写成</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> makefile.<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">prime: <span class="variable">$(objects)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> -o prime <span class="variable">$(objects)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(INC)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f prime *.o</span><br></pre></td></tr></table></figure><h4 id="条件语法"><a href="#条件语法" class="headerlink" title="条件语法"></a>条件语法</h4><p><code>make</code>支持条件控制<code>ifeq..else..endif</code>，例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">debug=no</span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(debug)</span>,no)</span><br><span class="line">    CFLAGS += -O3</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    CFLAGS += -O0</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>直接用<code>make</code>编译时将默认执行激进的O3优化。可在命令行增加宏debug定义来覆盖Makefile里定义好的值，如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make debug=yes</span><br></pre></td></tr></table></figure><p>此时不会对程序进行优化。这样方便随时调试和比较优化带来的效率改进。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="代码附录"><a href="#代码附录" class="headerlink" title="代码附录"></a>代码附录</h3><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a><code>main.c</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* decide if an integer a is a prime number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"prime.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a = read_a();</span><br><span class="line">    b = isqrt(a);</span><br><span class="line">    judge_p(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="read-a-c"><a href="#read-a-c" class="headerlink" title="read_a.c"></a><code>read_a.c</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"prime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intmax 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" Type the number a (4&lt;=a&lt;%d): "</span>,intmax);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">4</span> || a &gt; intmax)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is not in range. Exit\n"</span>,a);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="isqrt-c"><a href="#isqrt-c" class="headerlink" title="isqrt.c"></a><code>isqrt.c</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"prime.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isqrt</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="judge-p-c"><a href="#judge-p-c" class="headerlink" title="judge_p.c"></a><code>judge_p.c</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"prime.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge_p</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> a_sqrt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">2</span>;i&lt;=a_sqrt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a%i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d is not prime.\n"</span>,a);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i==(a_sqrt+<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d is prime.\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prime-h"><a href="#prime-h" class="headerlink" title="prime.h"></a><code>prime.h</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FUNC_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FUNC_H</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isqrt</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge_p</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="TeX文件编译的Makefile举例"><a href="#TeX文件编译的Makefile举例" class="headerlink" title="TeX文件编译的Makefile举例"></a>TeX文件编译的Makefile举例</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译about_make.tex</span></span><br><span class="line">FILE = about_make.tex</span><br><span class="line">TEX  = xelatex</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(TEX)</span> <span class="variable">$(FILE)</span>;</span><br><span class="line">    <span class="variable">$(TEX)</span> <span class="variable">$(FILE)</span>; <span class="comment"># 需要连续编译两次以获得交叉引用的编号</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>GNU manual of make: <a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">https://www.gnu.org/software/make/manual/make.html</a></p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Make </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
